
Puzzle_Solver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00001174  00800200  00002bb4  00002c48  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00002bb4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000095  00801374  00801374  00003dbc  2**0
                  ALLOC
  3 .stab         000025a4  00000000  00000000  00003dbc  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      000007cb  00000000  00000000  00006360  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000108  00000000  00000000  00006b30  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00002473  00000000  00000000  00006c38  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000640  00000000  00000000  000090ab  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000f3a  00000000  00000000  000096eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000a68  00000000  00000000  0000a628  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000c83  00000000  00000000  0000b090  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002743  00000000  00000000  0000bd13  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000088  00000000  00000000  0000e456  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 36 02 	jmp	0x46c	; 0x46c <__ctors_end>
       4:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
       8:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
       c:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      10:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      14:	0c 94 e0 08 	jmp	0x11c0	; 0x11c0 <__vector_5>
      18:	0c 94 bb 08 	jmp	0x1176	; 0x1176 <__vector_6>
      1c:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      20:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      24:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      28:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      2c:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      30:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      34:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      38:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      3c:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      40:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      44:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      48:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      4c:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      50:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      54:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      58:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      5c:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      60:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      64:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      68:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      6c:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      70:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      74:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      78:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      7c:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      80:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      84:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      88:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      8c:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      90:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      94:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      98:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      9c:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      a0:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      a4:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      a8:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      ac:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      b0:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      b4:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      b8:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      bc:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      c0:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      c4:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      c8:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      cc:	0c 94 72 0a 	jmp	0x14e4	; 0x14e4 <__vector_51>
      d0:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      d4:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      d8:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      dc:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>
      e0:	0c 94 57 02 	jmp	0x4ae	; 0x4ae <__bad_interrupt>

000000e4 <ARR_GlcdFont_U8>:
      e4:	ff ff ff ff ff 00 ff ff ff ff ff ff 00 ff ff ff     ................
      f4:	ff ff ff 00 ff ff ff ff ff ff 00 ff ff ff ff ff     ................
     104:	ff 00 ff ff ff ff ff ff 00 ff ff ff ff ff ff 00     ................
     114:	ff ff ff ff ff ff 00 ff ff ff ff ff ff 00 ff ff     ................
     124:	ff ff ff ff 00 ff ff ff ff ff ff 00 ff ff ff ff     ................
     134:	ff ff 00 ff ff ff ff ff ff 00 ff ff ff ff ff ff     ................
     144:	00 ff ff ff ff ff ff 00 ff ff ff ff ff ff 00 ff     ................
     154:	ff ff ff ff ff 00 ff ff ff ff ff ff 00 ff ff ff     ................
     164:	ff ff ff 00 ff ff ff ff ff ff 00 ff ff ff ff ff     ................
     174:	ff 00 ff ff ff ff ff ff 00 ff ff ff ff ff ff 00     ................
     184:	ff ff ff ff ff ff 00 ff ff ff ff ff ff 00 ff ff     ................
     194:	ff ff ff ff 00 ff ff ff ff ff ff 00 ff ff ff ff     ................
     1a4:	ff ff 00 ff ff ff ff ff ff 00 ff ff ff ff ff ff     ................
     1b4:	00 ff ff ff ff ff ff 00 ff ff ff ff ff ff 00 ff     ................
     1c4:	00 00 00 00 00 ff ff 00 00 4f 00 00 00 ff 00 07     .........O......
     1d4:	00 07 00 00 ff 14 7f 14 7f 14 00 ff 24 2a 7f 2a     ............$*.*
     1e4:	12 00 ff 23 13 08 64 62 00 ff 36 49 55 22 20 00     ...#..db..6IU" .
     1f4:	ff 00 05 03 00 00 00 ff 00 1c 22 41 00 00 ff 00     .........."A....
     204:	41 22 1c 00 00 ff 14 08 3e 08 14 00 ff 08 08 3e     A"......>......>
     214:	08 08 00 ff 50 30 00 00 00 00 ff 08 08 08 08 08     ....P0..........
     224:	00 ff 00 60 60 00 00 00 ff 20 10 08 04 02 00 ff     ...``.... ......
     234:	3e 51 49 45 3e 00 ff 40 42 7f 40 40 00 ff 42 61     >QIE>..@B.@@..Ba
     244:	51 49 46 00 ff 21 41 45 4b 31 00 ff 18 14 12 7f     QIF..!AEK1......
     254:	10 00 ff 27 45 45 45 39 00 ff 3c 4a 49 49 30 00     ...'EEE9..<JII0.
     264:	ff 01 71 09 05 03 00 ff 36 49 49 49 36 00 ff 06     ..q.....6III6...
     274:	49 49 29 1e 00 ff 00 36 36 00 00 00 ff 00 56 36     II)....66.....V6
     284:	00 00 00 ff 08 14 22 41 00 00 ff 14 14 14 14 14     ......"A........
     294:	00 ff 00 41 22 14 08 00 ff 02 01 51 09 06 00 ff     ...A"......Q....
     2a4:	3e 41 5d 55 1e 00 ff 7e 11 11 11 7e 00 ff 7f 49     >A]U...~...~...I
     2b4:	49 49 36 00 ff 3e 41 41 41 22 00 ff 7f 41 41 22     II6..>AAA"...AA"
     2c4:	1c 00 ff 7f 49 49 49 41 00 ff 7f 09 09 09 01 00     ....IIIA........
     2d4:	ff 3e 41 49 49 7a 00 ff 7f 08 08 08 7f 00 ff 00     .>AIIz..........
     2e4:	41 7f 41 00 00 ff 20 40 41 3f 01 00 ff 7f 08 14     A.A... @A?......
     2f4:	22 41 00 ff 7f 40 40 40 40 00 ff 7f 02 0c 02 7f     "A...@@@@.......
     304:	00 ff 7f 04 08 10 7f 00 ff 3e 41 41 41 3e 00 ff     .........>AAA>..
     314:	7f 09 09 09 06 00 ff 3e 41 51 21 5e 00 ff 7f 09     .......>AQ!^....
     324:	19 29 46 00 ff 26 49 49 49 32 00 ff 01 01 7f 01     .)F..&III2......
     334:	01 00 ff 3f 40 40 40 3f 00 ff 1f 20 40 20 1f 00     ...?@@@?... @ ..
     344:	ff 3f 40 38 40 3f 00 ff 63 14 08 14 63 00 ff 07     .?@8@?..c...c...
     354:	08 70 08 07 00 ff 61 51 49 45 43 00 ff 00 7f 41     .p....aQIEC....A
     364:	41 00 00 ff 02 04 08 10 20 00 ff 00 41 41 7f 00     A....... ...AA..
     374:	00 ff 04 02 01 02 04 00 ff 40 40 40 40 40 00 ff     .........@@@@@..
     384:	00 00 03 05 00 00 ff 20 54 54 54 78 00 ff 7f 44     ....... TTTx...D
     394:	44 44 38 00 ff 38 44 44 44 44 00 ff 38 44 44 44     DD8..8DDDD..8DDD
     3a4:	7f 00 ff 38 54 54 54 18 00 ff 04 04 7e 05 05 00     ...8TTT.....~...
     3b4:	ff 08 54 54 54 3c 00 ff 7f 08 04 04 78 00 ff 00     ..TTT<......x...
     3c4:	44 7d 40 00 ff ff 20 40 44 3d 00 ff ff 7f 10 28     D}@... @D=.....(
     3d4:	44 00 ff ff 41 7f 40 00 ff ff ff 7c 04 7c 04 78     D...A.@....|.|.x
     3e4:	00 ff 7c 08 04 04 78 00 ff 38 44 44 44 38 00 ff     ..|...x..8DDD8..
     3f4:	7c 14 14 14 08 00 ff 08 14 14 14 7c 00 ff 7c 08     |..........|..|.
     404:	04 04 00 ff ff 48 54 54 54 24 00 ff 04 04 3f 44     .....HTTT$....?D
     414:	44 00 ff 3c 40 40 20 7c 00 ff 1c 20 40 20 1c 00     D..<@@ |... @ ..
     424:	ff 3c 40 30 40 3c 00 ff 44 28 10 28 44 00 ff 0c     .<@0@<..D(.(D...
     434:	50 50 50 3c 00 ff 44 64 54 4c 44 00 ff 08 36 41     PPP<..DdTLD...6A
     444:	41 00 00 ff 00 00 77 00 00 00 ff 00 41 41 36 08     A.....w.....AA6.
     454:	00 ff 08 08 2a 1c 08 00 ff 08 1c 2a 08 08 00 ff     ....*......*....
     464:	ff ff ff ff ff 00 ff 00                             ........

0000046c <__ctors_end>:
     46c:	11 24       	eor	r1, r1
     46e:	1f be       	out	0x3f, r1	; 63
     470:	cf ef       	ldi	r28, 0xFF	; 255
     472:	d1 e2       	ldi	r29, 0x21	; 33
     474:	de bf       	out	0x3e, r29	; 62
     476:	cd bf       	out	0x3d, r28	; 61
     478:	00 e0       	ldi	r16, 0x00	; 0
     47a:	0c bf       	out	0x3c, r16	; 60

0000047c <__do_copy_data>:
     47c:	13 e1       	ldi	r17, 0x13	; 19
     47e:	a0 e0       	ldi	r26, 0x00	; 0
     480:	b2 e0       	ldi	r27, 0x02	; 2
     482:	e4 eb       	ldi	r30, 0xB4	; 180
     484:	fb e2       	ldi	r31, 0x2B	; 43
     486:	00 e0       	ldi	r16, 0x00	; 0
     488:	0b bf       	out	0x3b, r16	; 59
     48a:	02 c0       	rjmp	.+4      	; 0x490 <__do_copy_data+0x14>
     48c:	07 90       	elpm	r0, Z+
     48e:	0d 92       	st	X+, r0
     490:	a4 37       	cpi	r26, 0x74	; 116
     492:	b1 07       	cpc	r27, r17
     494:	d9 f7       	brne	.-10     	; 0x48c <__do_copy_data+0x10>

00000496 <__do_clear_bss>:
     496:	14 e1       	ldi	r17, 0x14	; 20
     498:	a4 e7       	ldi	r26, 0x74	; 116
     49a:	b3 e1       	ldi	r27, 0x13	; 19
     49c:	01 c0       	rjmp	.+2      	; 0x4a0 <.do_clear_bss_start>

0000049e <.do_clear_bss_loop>:
     49e:	1d 92       	st	X+, r1

000004a0 <.do_clear_bss_start>:
     4a0:	a9 30       	cpi	r26, 0x09	; 9
     4a2:	b1 07       	cpc	r27, r17
     4a4:	e1 f7       	brne	.-8      	; 0x49e <.do_clear_bss_loop>
     4a6:	0e 94 8e 10 	call	0x211c	; 0x211c <main>
     4aa:	0c 94 d8 15 	jmp	0x2bb0	; 0x2bb0 <_exit>

000004ae <__bad_interrupt>:
     4ae:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000004b2 <glcd_SelectPage0>:
}


static void glcd_SelectPage0() 
 { 
   M_GlcdSetBit(M_GlcdControlBus1,GLCD_CS1); 
     4b2:	eb e0       	ldi	r30, 0x0B	; 11
     4b4:	f1 e0       	ldi	r31, 0x01	; 1
     4b6:	80 81       	ld	r24, Z
     4b8:	81 60       	ori	r24, 0x01	; 1
     4ba:	80 83       	st	Z, r24
   M_GlcdClearBit(M_GlcdControlBus1,GLCD_CS2); 
     4bc:	80 81       	ld	r24, Z
     4be:	8d 7f       	andi	r24, 0xFD	; 253
     4c0:	80 83       	st	Z, r24
 }
     4c2:	08 95       	ret

000004c4 <glcd_SelectPage1>:

static void glcd_SelectPage1() 
 {
   M_GlcdSetBit(M_GlcdControlBus1,GLCD_CS2);
     4c4:	eb e0       	ldi	r30, 0x0B	; 11
     4c6:	f1 e0       	ldi	r31, 0x01	; 1
     4c8:	80 81       	ld	r24, Z
     4ca:	82 60       	ori	r24, 0x02	; 2
     4cc:	80 83       	st	Z, r24
   M_GlcdClearBit(M_GlcdControlBus1,GLCD_CS1); 
     4ce:	80 81       	ld	r24, Z
     4d0:	8e 7f       	andi	r24, 0xFE	; 254
     4d2:	80 83       	st	Z, r24
 }
     4d4:	08 95       	ret

000004d6 <glcd_BusyCheck>:
{
    uint8_t busyflag;
    
#ifdef GLCD_RW                    //Perform Busy check if GLCD_RW pin is used

    util_UpdateBit(M_GlcdDataBusDirection,GLCD_D7,C_PinInput_U8); // Configure busy pin as input
     4d6:	e4 e0       	ldi	r30, 0x04	; 4
     4d8:	f1 e0       	ldi	r31, 0x01	; 1
     4da:	80 81       	ld	r24, Z
     4dc:	8f 77       	andi	r24, 0x7F	; 127
     4de:	80 83       	st	Z, r24
    M_GlcdClearBit(M_GlcdControlBus,GLCD_RS);           // Select the Command Register by pulling RS LOW
     4e0:	5d 98       	cbi	0x0b, 5	; 11
    M_GlcdSetBit(M_GlcdControlBus,GLCD_RW);             // Select the Read Operation for busy flag by setting RW
     4e2:	5e 9a       	sbi	0x0b, 6	; 11
    {
        M_GlcdClearBit(M_GlcdControlBus,GLCD_EN);             // Send a High-to-Low Pulse at Enable Pin
        DELAY_us(2);    
        M_GlcdSetBit(M_GlcdControlBus,GLCD_EN);
        DELAY_us(2);
        busyflag = util_GetBitStatus(M_GlcdDataBusInput,GLCD_D7);
     4e4:	e3 e0       	ldi	r30, 0x03	; 3
     4e6:	f1 e0       	ldi	r31, 0x01	; 1
    util_UpdateBit(M_GlcdDataBusDirection,GLCD_D7,C_PinInput_U8); // Configure busy pin as input
    M_GlcdClearBit(M_GlcdControlBus,GLCD_RS);           // Select the Command Register by pulling RS LOW
    M_GlcdSetBit(M_GlcdControlBus,GLCD_RW);             // Select the Read Operation for busy flag by setting RW
    do
    {
        M_GlcdClearBit(M_GlcdControlBus,GLCD_EN);             // Send a High-to-Low Pulse at Enable Pin
     4e8:	5f 98       	cbi	0x0b, 7	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     4ea:	8a e0       	ldi	r24, 0x0A	; 10
     4ec:	8a 95       	dec	r24
     4ee:	f1 f7       	brne	.-4      	; 0x4ec <glcd_BusyCheck+0x16>
        DELAY_us(2);    
        M_GlcdSetBit(M_GlcdControlBus,GLCD_EN);
     4f0:	5f 9a       	sbi	0x0b, 7	; 11
     4f2:	8a e0       	ldi	r24, 0x0A	; 10
     4f4:	8a 95       	dec	r24
     4f6:	f1 f7       	brne	.-4      	; 0x4f4 <glcd_BusyCheck+0x1e>
        DELAY_us(2);
        busyflag = util_GetBitStatus(M_GlcdDataBusInput,GLCD_D7);
     4f8:	80 81       	ld	r24, Z
    }while(busyflag);
     4fa:	88 23       	and	r24, r24
     4fc:	ac f3       	brlt	.-22     	; 0x4e8 <glcd_BusyCheck+0x12>

    util_UpdateBit(M_GlcdDataBusDirection,GLCD_D7,C_PinOutput_U8);
     4fe:	e4 e0       	ldi	r30, 0x04	; 4
     500:	f1 e0       	ldi	r31, 0x01	; 1
     502:	80 81       	ld	r24, Z
     504:	80 68       	ori	r24, 0x80	; 128
     506:	80 83       	st	Z, r24
#else
    /* Busy flag cannot be read as GLCD_RW is not available hence Extra delay of 1ms is added 
      to ensure the LCD completes previous operation and ready to receive new commands/data */
    DELAY_ms(1);  
#endif
}
     508:	08 95       	ret

0000050a <glcd_DataWrite>:
 * Return value    : none

 * description : This functions is used to send a byte of data to LCD.                 .    
 *************************************************************************************************/
static void glcd_DataWrite( uint8_t var_data_u8)
{
     50a:	cf 93       	push	r28
     50c:	c8 2f       	mov	r28, r24
    glcd_BusyCheck();
     50e:	0e 94 6b 02 	call	0x4d6	; 0x4d6 <glcd_BusyCheck>
    M_GlcdDataBus = var_data_u8 ;
     512:	c0 93 05 01 	sts	0x0105, r28
    M_GlcdSetBit(M_GlcdControlBus,GLCD_RS);           // Select the Data Register by pulling RS High
     516:	5d 9a       	sbi	0x0b, 5	; 11
#ifdef GLCD_RW
    M_GlcdClearBit(M_GlcdControlBus,GLCD_RW);           // Select the Write Operation  by pulling RW LOW
     518:	5e 98       	cbi	0x0b, 6	; 11
#endif
    M_GlcdSetBit(M_GlcdControlBus,GLCD_EN);             // Send a High-to-Low Pulse at Enable Pin
     51a:	5f 9a       	sbi	0x0b, 7	; 11
     51c:	8a e0       	ldi	r24, 0x0A	; 10
     51e:	8a 95       	dec	r24
     520:	f1 f7       	brne	.-4      	; 0x51e <glcd_DataWrite+0x14>
    DELAY_us(2);
    M_GlcdClearBit(M_GlcdControlBus,GLCD_EN);
     522:	5f 98       	cbi	0x0b, 7	; 11
}
     524:	cf 91       	pop	r28
     526:	08 95       	ret

00000528 <glcd_CmdWrite>:
                Some of the commonly used commands are defined in lcd.h.
                For more commands refer the data sheet and send the supported command.                
                The behavior is undefined if unsupported commands are sent.    
 ***************************************************************************************************/
static void glcd_CmdWrite( uint8_t var_cmd_u8)
{
     528:	cf 93       	push	r28
     52a:	c8 2f       	mov	r28, r24
    glcd_BusyCheck();
     52c:	0e 94 6b 02 	call	0x4d6	; 0x4d6 <glcd_BusyCheck>
    M_GlcdDataBus = var_cmd_u8;
     530:	c0 93 05 01 	sts	0x0105, r28
    M_GlcdClearBit(M_GlcdControlBus,GLCD_RS);           // Select the Command Register by pulling RS LOW
     534:	5d 98       	cbi	0x0b, 5	; 11
#ifdef GLCD_RW
    M_GlcdClearBit(M_GlcdControlBus,GLCD_RW);           // Select the Write Operation  by pulling RW LOW
     536:	5e 98       	cbi	0x0b, 6	; 11
#endif
    M_GlcdSetBit(M_GlcdControlBus,GLCD_EN);             // Send a High-to-Low Pulse at Enable Pin
     538:	5f 9a       	sbi	0x0b, 7	; 11
     53a:	8a e0       	ldi	r24, 0x0A	; 10
     53c:	8a 95       	dec	r24
     53e:	f1 f7       	brne	.-4      	; 0x53c <glcd_CmdWrite+0x14>
    DELAY_us(2);
    M_GlcdClearBit(M_GlcdControlBus,GLCD_EN);
     540:	5f 98       	cbi	0x0b, 7	; 11
}
     542:	cf 91       	pop	r28
     544:	08 95       	ret

00000546 <lcd_set_4bit>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     546:	86 e6       	ldi	r24, 0x66	; 102
     548:	9e e0       	ldi	r25, 0x0E	; 14
     54a:	01 97       	sbiw	r24, 0x01	; 1
     54c:	f1 f7       	brne	.-4      	; 0x54a <lcd_set_4bit+0x4>
     54e:	00 00       	nop
//Function to Reset LCD
void lcd_set_4bit()
{
	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     550:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     552:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     554:	80 e3       	ldi	r24, 0x30	; 48
     556:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     558:	42 9a       	sbi	0x08, 2	; 8
     55a:	ef ef       	ldi	r30, 0xFF	; 255
     55c:	f7 e4       	ldi	r31, 0x47	; 71
     55e:	31 97       	sbiw	r30, 0x01	; 1
     560:	f1 f7       	brne	.-4      	; 0x55e <lcd_set_4bit+0x18>
     562:	00 c0       	rjmp	.+0      	; 0x564 <lcd_set_4bit+0x1e>
     564:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     566:	42 98       	cbi	0x08, 2	; 8
     568:	e6 e6       	ldi	r30, 0x66	; 102
     56a:	fe e0       	ldi	r31, 0x0E	; 14
     56c:	31 97       	sbiw	r30, 0x01	; 1
     56e:	f1 f7       	brne	.-4      	; 0x56c <lcd_set_4bit+0x26>
     570:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     572:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     574:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     576:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     578:	42 9a       	sbi	0x08, 2	; 8
     57a:	ef ef       	ldi	r30, 0xFF	; 255
     57c:	f7 e4       	ldi	r31, 0x47	; 71
     57e:	31 97       	sbiw	r30, 0x01	; 1
     580:	f1 f7       	brne	.-4      	; 0x57e <lcd_set_4bit+0x38>
     582:	00 c0       	rjmp	.+0      	; 0x584 <lcd_set_4bit+0x3e>
     584:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     586:	42 98       	cbi	0x08, 2	; 8
     588:	e6 e6       	ldi	r30, 0x66	; 102
     58a:	fe e0       	ldi	r31, 0x0E	; 14
     58c:	31 97       	sbiw	r30, 0x01	; 1
     58e:	f1 f7       	brne	.-4      	; 0x58c <lcd_set_4bit+0x46>
     590:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     592:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     594:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x30;				//Sending 3
     596:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     598:	42 9a       	sbi	0x08, 2	; 8
     59a:	8f ef       	ldi	r24, 0xFF	; 255
     59c:	97 e4       	ldi	r25, 0x47	; 71
     59e:	01 97       	sbiw	r24, 0x01	; 1
     5a0:	f1 f7       	brne	.-4      	; 0x59e <lcd_set_4bit+0x58>
     5a2:	00 c0       	rjmp	.+0      	; 0x5a4 <lcd_set_4bit+0x5e>
     5a4:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     5a6:	42 98       	cbi	0x08, 2	; 8
     5a8:	e6 e6       	ldi	r30, 0x66	; 102
     5aa:	fe e0       	ldi	r31, 0x0E	; 14
     5ac:	31 97       	sbiw	r30, 0x01	; 1
     5ae:	f1 f7       	brne	.-4      	; 0x5ac <lcd_set_4bit+0x66>
     5b0:	00 00       	nop

	_delay_ms(1);

	cbit(lcd_port,RS);				//RS=0 --- Command Input
     5b2:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);				//RW=0 --- Writing to LCD
     5b4:	41 98       	cbi	0x08, 1	; 8
	lcd_port = 0x20;				//Sending 2 to initialise LCD 4-bit mode
     5b6:	80 e2       	ldi	r24, 0x20	; 32
     5b8:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,EN);				//Set Enable Pin
     5ba:	42 9a       	sbi	0x08, 2	; 8
     5bc:	8f ef       	ldi	r24, 0xFF	; 255
     5be:	97 e4       	ldi	r25, 0x47	; 71
     5c0:	01 97       	sbiw	r24, 0x01	; 1
     5c2:	f1 f7       	brne	.-4      	; 0x5c0 <lcd_set_4bit+0x7a>
     5c4:	00 c0       	rjmp	.+0      	; 0x5c6 <lcd_set_4bit+0x80>
     5c6:	00 00       	nop
	_delay_ms(5);					//Delay
	cbit(lcd_port,EN);				//Clear Enable Pin
     5c8:	42 98       	cbi	0x08, 2	; 8

	
}
     5ca:	08 95       	ret

000005cc <lcd_wr_command>:
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
	lcd_port &= 0x0F;
     5cc:	98 b1       	in	r25, 0x08	; 8
     5ce:	9f 70       	andi	r25, 0x0F	; 15
     5d0:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     5d2:	98 b1       	in	r25, 0x08	; 8
//Function to Write Command on LCD
void lcd_wr_command(unsigned char cmd)
{
	unsigned char temp;
	temp = cmd;
	temp = temp & 0xF0;
     5d4:	28 2f       	mov	r18, r24
     5d6:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     5d8:	92 2b       	or	r25, r18
     5da:	98 b9       	out	0x08, r25	; 8
	cbit(lcd_port,RS);
     5dc:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     5de:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     5e0:	42 9a       	sbi	0x08, 2	; 8
     5e2:	ef ef       	ldi	r30, 0xFF	; 255
     5e4:	f7 e4       	ldi	r31, 0x47	; 71
     5e6:	31 97       	sbiw	r30, 0x01	; 1
     5e8:	f1 f7       	brne	.-4      	; 0x5e6 <lcd_wr_command+0x1a>
     5ea:	00 c0       	rjmp	.+0      	; 0x5ec <lcd_wr_command+0x20>
     5ec:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     5ee:	42 98       	cbi	0x08, 2	; 8
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
	lcd_port &= 0x0F;
     5f0:	98 b1       	in	r25, 0x08	; 8
     5f2:	9f 70       	andi	r25, 0x0F	; 15
     5f4:	98 b9       	out	0x08, r25	; 8
	lcd_port |= cmd;
     5f6:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);
	
	cmd = cmd & 0x0F;
	cmd = cmd<<4;
     5f8:	82 95       	swap	r24
     5fa:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= cmd;
     5fc:	89 2b       	or	r24, r25
     5fe:	88 b9       	out	0x08, r24	; 8
	cbit(lcd_port,RS);
     600:	40 98       	cbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     602:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     604:	42 9a       	sbi	0x08, 2	; 8
     606:	8f ef       	ldi	r24, 0xFF	; 255
     608:	97 e4       	ldi	r25, 0x47	; 71
     60a:	01 97       	sbiw	r24, 0x01	; 1
     60c:	f1 f7       	brne	.-4      	; 0x60a <lcd_wr_command+0x3e>
     60e:	00 c0       	rjmp	.+0      	; 0x610 <lcd_wr_command+0x44>
     610:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     612:	42 98       	cbi	0x08, 2	; 8
}
     614:	08 95       	ret

00000616 <lcd_init>:
}

//Function to Initialize LCD
void lcd_init()
{
	lcd_set_4bit();
     616:	0e 94 a3 02 	call	0x546	; 0x546 <lcd_set_4bit>
     61a:	86 e6       	ldi	r24, 0x66	; 102
     61c:	9e e0       	ldi	r25, 0x0E	; 14
     61e:	01 97       	sbiw	r24, 0x01	; 1
     620:	f1 f7       	brne	.-4      	; 0x61e <lcd_init+0x8>
     622:	00 00       	nop
	_delay_ms(1);

	lcd_wr_command(0x28);			//LCD 4-bit mode and 2 lines.
     624:	88 e2       	ldi	r24, 0x28	; 40
     626:	0e 94 e6 02 	call	0x5cc	; 0x5cc <lcd_wr_command>
	lcd_wr_command(0x01);
     62a:	81 e0       	ldi	r24, 0x01	; 1
     62c:	0e 94 e6 02 	call	0x5cc	; 0x5cc <lcd_wr_command>
	lcd_wr_command(0x06);
     630:	86 e0       	ldi	r24, 0x06	; 6
     632:	0e 94 e6 02 	call	0x5cc	; 0x5cc <lcd_wr_command>
	lcd_wr_command(0x0E);
     636:	8e e0       	ldi	r24, 0x0E	; 14
     638:	0e 94 e6 02 	call	0x5cc	; 0x5cc <lcd_wr_command>
	lcd_wr_command(0x80);
     63c:	80 e8       	ldi	r24, 0x80	; 128
     63e:	0e 94 e6 02 	call	0x5cc	; 0x5cc <lcd_wr_command>
		
}
     642:	08 95       	ret

00000644 <lcd_wr_char>:
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
	lcd_port &= 0x0F;
     644:	98 b1       	in	r25, 0x08	; 8
     646:	9f 70       	andi	r25, 0x0F	; 15
     648:	98 b9       	out	0x08, r25	; 8
	lcd_port |= temp;
     64a:	98 b1       	in	r25, 0x08	; 8
//Function to Write Data on LCD
void lcd_wr_char(char letter)
{
	char temp;
	temp = letter;
	temp = (temp & 0xF0);
     64c:	28 2f       	mov	r18, r24
     64e:	20 7f       	andi	r18, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= temp;
     650:	92 2b       	or	r25, r18
     652:	98 b9       	out	0x08, r25	; 8
	sbit(lcd_port,RS);
     654:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     656:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     658:	42 9a       	sbi	0x08, 2	; 8
     65a:	ef ef       	ldi	r30, 0xFF	; 255
     65c:	f7 e4       	ldi	r31, 0x47	; 71
     65e:	31 97       	sbiw	r30, 0x01	; 1
     660:	f1 f7       	brne	.-4      	; 0x65e <lcd_wr_char+0x1a>
     662:	00 c0       	rjmp	.+0      	; 0x664 <lcd_wr_char+0x20>
     664:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     666:	42 98       	cbi	0x08, 2	; 8

	letter = letter & 0x0F;
	letter = letter<<4;
	lcd_port &= 0x0F;
     668:	98 b1       	in	r25, 0x08	; 8
     66a:	9f 70       	andi	r25, 0x0F	; 15
     66c:	98 b9       	out	0x08, r25	; 8
	lcd_port |= letter;
     66e:	98 b1       	in	r25, 0x08	; 8
	sbit(lcd_port,EN);
	_delay_ms(5);
	cbit(lcd_port,EN);

	letter = letter & 0x0F;
	letter = letter<<4;
     670:	82 95       	swap	r24
     672:	80 7f       	andi	r24, 0xF0	; 240
	lcd_port &= 0x0F;
	lcd_port |= letter;
     674:	89 2b       	or	r24, r25
     676:	88 b9       	out	0x08, r24	; 8
	sbit(lcd_port,RS);
     678:	40 9a       	sbi	0x08, 0	; 8
	cbit(lcd_port,RW);
     67a:	41 98       	cbi	0x08, 1	; 8
	sbit(lcd_port,EN);
     67c:	42 9a       	sbi	0x08, 2	; 8
     67e:	8f ef       	ldi	r24, 0xFF	; 255
     680:	97 e4       	ldi	r25, 0x47	; 71
     682:	01 97       	sbiw	r24, 0x01	; 1
     684:	f1 f7       	brne	.-4      	; 0x682 <lcd_wr_char+0x3e>
     686:	00 c0       	rjmp	.+0      	; 0x688 <lcd_wr_char+0x44>
     688:	00 00       	nop
	_delay_ms(5);
	cbit(lcd_port,EN);
     68a:	42 98       	cbi	0x08, 2	; 8
}
     68c:	08 95       	ret

0000068e <lcd_home>:


//Function to bring cursor at home position
void lcd_home()
{
	lcd_wr_command(0x80);
     68e:	80 e8       	ldi	r24, 0x80	; 128
     690:	0e 94 e6 02 	call	0x5cc	; 0x5cc <lcd_wr_command>
}
     694:	08 95       	ret

00000696 <lcd_string>:


//Function to Print String on LCD
void lcd_string(char *str)
{
     696:	cf 93       	push	r28
     698:	df 93       	push	r29
     69a:	ec 01       	movw	r28, r24
	while(*str != '\0')
     69c:	88 81       	ld	r24, Y
     69e:	88 23       	and	r24, r24
     6a0:	31 f0       	breq	.+12     	; 0x6ae <lcd_string+0x18>
	lcd_wr_command(0x80);
}


//Function to Print String on LCD
void lcd_string(char *str)
     6a2:	21 96       	adiw	r28, 0x01	; 1
{
	while(*str != '\0')
	{
		lcd_wr_char(*str);
     6a4:	0e 94 22 03 	call	0x644	; 0x644 <lcd_wr_char>


//Function to Print String on LCD
void lcd_string(char *str)
{
	while(*str != '\0')
     6a8:	89 91       	ld	r24, Y+
     6aa:	88 23       	and	r24, r24
     6ac:	d9 f7       	brne	.-10     	; 0x6a4 <lcd_string+0xe>
	{
		lcd_wr_char(*str);
		str++;
	}
}
     6ae:	df 91       	pop	r29
     6b0:	cf 91       	pop	r28
     6b2:	08 95       	ret

000006b4 <lcd_cursor>:

//Position the LCD cursor at "row", "column".

void lcd_cursor (char row, char column)
{
	switch (row) {
     6b4:	82 30       	cpi	r24, 0x02	; 2
     6b6:	79 f0       	breq	.+30     	; 0x6d6 <lcd_cursor+0x22>
     6b8:	83 30       	cpi	r24, 0x03	; 3
     6ba:	18 f4       	brcc	.+6      	; 0x6c2 <lcd_cursor+0xe>
     6bc:	81 30       	cpi	r24, 0x01	; 1
     6be:	c9 f4       	brne	.+50     	; 0x6f2 <lcd_cursor+0x3e>
     6c0:	05 c0       	rjmp	.+10     	; 0x6cc <lcd_cursor+0x18>
     6c2:	83 30       	cpi	r24, 0x03	; 3
     6c4:	69 f0       	breq	.+26     	; 0x6e0 <lcd_cursor+0x2c>
     6c6:	84 30       	cpi	r24, 0x04	; 4
     6c8:	a1 f4       	brne	.+40     	; 0x6f2 <lcd_cursor+0x3e>
     6ca:	0f c0       	rjmp	.+30     	; 0x6ea <lcd_cursor+0x36>
		case 1: lcd_wr_command (0x80 + column - 1); break;
     6cc:	86 2f       	mov	r24, r22
     6ce:	81 58       	subi	r24, 0x81	; 129
     6d0:	0e 94 e6 02 	call	0x5cc	; 0x5cc <lcd_wr_command>
     6d4:	08 95       	ret
		case 2: lcd_wr_command (0xc0 + column - 1); break;
     6d6:	86 2f       	mov	r24, r22
     6d8:	81 54       	subi	r24, 0x41	; 65
     6da:	0e 94 e6 02 	call	0x5cc	; 0x5cc <lcd_wr_command>
     6de:	08 95       	ret
		case 3: lcd_wr_command (0x94 + column - 1); break;
     6e0:	86 2f       	mov	r24, r22
     6e2:	8d 56       	subi	r24, 0x6D	; 109
     6e4:	0e 94 e6 02 	call	0x5cc	; 0x5cc <lcd_wr_command>
     6e8:	08 95       	ret
		case 4: lcd_wr_command (0xd4 + column - 1); break;
     6ea:	86 2f       	mov	r24, r22
     6ec:	8d 52       	subi	r24, 0x2D	; 45
     6ee:	0e 94 e6 02 	call	0x5cc	; 0x5cc <lcd_wr_command>
     6f2:	08 95       	ret

000006f4 <lcd_print>:
	}
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
     6f4:	0f 93       	push	r16
     6f6:	1f 93       	push	r17
     6f8:	cf 93       	push	r28
     6fa:	df 93       	push	r29
     6fc:	8a 01       	movw	r16, r20
     6fe:	e9 01       	movw	r28, r18
	unsigned char flag=0;
	if(row==0||coloumn==0)
     700:	88 23       	and	r24, r24
     702:	11 f0       	breq	.+4      	; 0x708 <lcd_print+0x14>
     704:	66 23       	and	r22, r22
     706:	19 f4       	brne	.+6      	; 0x70e <lcd_print+0x1a>
	{
		lcd_home();
     708:	0e 94 47 03 	call	0x68e	; 0x68e <lcd_home>
     70c:	02 c0       	rjmp	.+4      	; 0x712 <lcd_print+0x1e>
	}
	else
	{
		lcd_cursor(row,coloumn);
     70e:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <lcd_cursor>
	}
	if(digits==5 || flag==1)
     712:	c5 30       	cpi	r28, 0x05	; 5
     714:	d1 05       	cpc	r29, r1
     716:	71 f4       	brne	.+28     	; 0x734 <lcd_print+0x40>
	{
		million=value/10000+48;
     718:	c8 01       	movw	r24, r16
     71a:	60 e1       	ldi	r22, 0x10	; 16
     71c:	77 e2       	ldi	r23, 0x27	; 39
     71e:	0e 94 16 14 	call	0x282c	; 0x282c <__udivmodhi4>
     722:	cb 01       	movw	r24, r22
     724:	c0 96       	adiw	r24, 0x30	; 48
     726:	90 93 ea 13 	sts	0x13EA, r25
     72a:	80 93 e9 13 	sts	0x13E9, r24
		lcd_wr_char(million);
     72e:	0e 94 22 03 	call	0x644	; 0x644 <lcd_wr_char>
     732:	03 c0       	rjmp	.+6      	; 0x73a <lcd_print+0x46>
		flag=1;
	}
	if(digits==4 || flag==1)
     734:	c4 30       	cpi	r28, 0x04	; 4
     736:	d1 05       	cpc	r29, r1
     738:	b9 f4       	brne	.+46     	; 0x768 <lcd_print+0x74>
	{
		temp = value/1000;
     73a:	c8 01       	movw	r24, r16
     73c:	68 ee       	ldi	r22, 0xE8	; 232
     73e:	73 e0       	ldi	r23, 0x03	; 3
     740:	0e 94 16 14 	call	0x282c	; 0x282c <__udivmodhi4>
     744:	cb 01       	movw	r24, r22
     746:	70 93 f0 13 	sts	0x13F0, r23
     74a:	60 93 ef 13 	sts	0x13EF, r22
		thousand = temp%10 + 48;
     74e:	6a e0       	ldi	r22, 0x0A	; 10
     750:	70 e0       	ldi	r23, 0x00	; 0
     752:	0e 94 16 14 	call	0x282c	; 0x282c <__udivmodhi4>
     756:	c0 96       	adiw	r24, 0x30	; 48
     758:	90 93 04 14 	sts	0x1404, r25
     75c:	80 93 03 14 	sts	0x1403, r24
		lcd_wr_char(thousand);
     760:	0e 94 22 03 	call	0x644	; 0x644 <lcd_wr_char>
		flag=1;
     764:	81 e0       	ldi	r24, 0x01	; 1
     766:	01 c0       	rjmp	.+2      	; 0x76a <lcd_print+0x76>
}

//Function To Print Any input value upto the desired digit on LCD
void lcd_print (char row, char coloumn, unsigned int value, int digits)
{
	unsigned char flag=0;
     768:	80 e0       	ldi	r24, 0x00	; 0
		temp = value/1000;
		thousand = temp%10 + 48;
		lcd_wr_char(thousand);
		flag=1;
	}
	if(digits==3 || flag==1)
     76a:	c3 30       	cpi	r28, 0x03	; 3
     76c:	d1 05       	cpc	r29, r1
     76e:	11 f0       	breq	.+4      	; 0x774 <lcd_print+0x80>
     770:	81 30       	cpi	r24, 0x01	; 1
     772:	b1 f4       	brne	.+44     	; 0x7a0 <lcd_print+0xac>
	{
		temp = value/100;
     774:	c8 01       	movw	r24, r16
     776:	64 e6       	ldi	r22, 0x64	; 100
     778:	70 e0       	ldi	r23, 0x00	; 0
     77a:	0e 94 16 14 	call	0x282c	; 0x282c <__udivmodhi4>
     77e:	cb 01       	movw	r24, r22
     780:	70 93 f0 13 	sts	0x13F0, r23
     784:	60 93 ef 13 	sts	0x13EF, r22
		hundred = temp%10 + 48;
     788:	6a e0       	ldi	r22, 0x0A	; 10
     78a:	70 e0       	ldi	r23, 0x00	; 0
     78c:	0e 94 16 14 	call	0x282c	; 0x282c <__udivmodhi4>
     790:	c0 96       	adiw	r24, 0x30	; 48
     792:	90 93 00 14 	sts	0x1400, r25
     796:	80 93 ff 13 	sts	0x13FF, r24
		lcd_wr_char(hundred);
     79a:	0e 94 22 03 	call	0x644	; 0x644 <lcd_wr_char>
		flag=1;
     79e:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==2 || flag==1)
     7a0:	c2 30       	cpi	r28, 0x02	; 2
     7a2:	d1 05       	cpc	r29, r1
     7a4:	11 f0       	breq	.+4      	; 0x7aa <lcd_print+0xb6>
     7a6:	81 30       	cpi	r24, 0x01	; 1
     7a8:	b1 f4       	brne	.+44     	; 0x7d6 <lcd_print+0xe2>
	{
		temp = value/10;
     7aa:	2a e0       	ldi	r18, 0x0A	; 10
     7ac:	30 e0       	ldi	r19, 0x00	; 0
     7ae:	c8 01       	movw	r24, r16
     7b0:	b9 01       	movw	r22, r18
     7b2:	0e 94 16 14 	call	0x282c	; 0x282c <__udivmodhi4>
     7b6:	cb 01       	movw	r24, r22
     7b8:	70 93 f0 13 	sts	0x13F0, r23
     7bc:	60 93 ef 13 	sts	0x13EF, r22
		tens = temp%10 + 48;
     7c0:	b9 01       	movw	r22, r18
     7c2:	0e 94 16 14 	call	0x282c	; 0x282c <__udivmodhi4>
     7c6:	c0 96       	adiw	r24, 0x30	; 48
     7c8:	90 93 f7 13 	sts	0x13F7, r25
     7cc:	80 93 f6 13 	sts	0x13F6, r24
		lcd_wr_char(tens);
     7d0:	0e 94 22 03 	call	0x644	; 0x644 <lcd_wr_char>
		flag=1;
     7d4:	81 e0       	ldi	r24, 0x01	; 1
	}
	if(digits==1 || flag==1)
     7d6:	c1 30       	cpi	r28, 0x01	; 1
     7d8:	d1 05       	cpc	r29, r1
     7da:	11 f0       	breq	.+4      	; 0x7e0 <lcd_print+0xec>
     7dc:	81 30       	cpi	r24, 0x01	; 1
     7de:	61 f4       	brne	.+24     	; 0x7f8 <lcd_print+0x104>
	{
		unit = value%10 + 48;
     7e0:	c8 01       	movw	r24, r16
     7e2:	6a e0       	ldi	r22, 0x0A	; 10
     7e4:	70 e0       	ldi	r23, 0x00	; 0
     7e6:	0e 94 16 14 	call	0x282c	; 0x282c <__udivmodhi4>
     7ea:	c0 96       	adiw	r24, 0x30	; 48
     7ec:	90 93 02 14 	sts	0x1402, r25
     7f0:	80 93 01 14 	sts	0x1401, r24
		lcd_wr_char(unit);
     7f4:	0e 94 22 03 	call	0x644	; 0x644 <lcd_wr_char>
	}
	if(digits>5)
     7f8:	c6 30       	cpi	r28, 0x06	; 6
     7fa:	d1 05       	cpc	r29, r1
     7fc:	1c f0       	brlt	.+6      	; 0x804 <lcd_print+0x110>
	{
		lcd_wr_char('E');
     7fe:	85 e4       	ldi	r24, 0x45	; 69
     800:	0e 94 22 03 	call	0x644	; 0x644 <lcd_wr_char>
	}
	
}
     804:	df 91       	pop	r29
     806:	cf 91       	pop	r28
     808:	1f 91       	pop	r17
     80a:	0f 91       	pop	r16
     80c:	08 95       	ret

0000080e <GLCD_SetCursor>:
                   Note:If the Input(Line/Char number) are out of range 
                        then no action will be taken
 ***************************************************************************************************/
 /* TODO: change the var names, Add logic for page handling */
void GLCD_SetCursor(uint8_t pageNumber,uint8_t lineNumber,uint8_t CursorPosition)
{
     80e:	1f 93       	push	r17
     810:	cf 93       	push	r28
     812:	df 93       	push	r29
     814:	c8 2f       	mov	r28, r24
     816:	d6 2f       	mov	r29, r22
     818:	14 2f       	mov	r17, r20
    if(    ((pageNumber == 0x00)   || (pageNumber == 0x01))
     81a:	82 30       	cpi	r24, 0x02	; 2
     81c:	d0 f4       	brcc	.+52     	; 0x852 <GLCD_SetCursor+0x44>
	    && ((lineNumber >=0x00)    && (lineNumber <= C_GlcdLastLine_U8))
     81e:	68 30       	cpi	r22, 0x08	; 8
     820:	c0 f4       	brcc	.+48     	; 0x852 <GLCD_SetCursor+0x44>
	    && ((CursorPosition>=0x00) && (CursorPosition <= 63)) )
     822:	40 34       	cpi	r20, 0x40	; 64
     824:	b0 f4       	brcc	.+44     	; 0x852 <GLCD_SetCursor+0x44>
	  {
	    if(pageNumber==0x00)  /* Check for page number and set accordingly */
     826:	88 23       	and	r24, r24
     828:	19 f4       	brne	.+6      	; 0x830 <GLCD_SetCursor+0x22>
         {
           glcd_SelectPage0();
     82a:	0e 94 59 02 	call	0x4b2	; 0x4b2 <glcd_SelectPage0>
     82e:	02 c0       	rjmp	.+4      	; 0x834 <GLCD_SetCursor+0x26>
         }
        else
	     {
            glcd_SelectPage1();
     830:	0e 94 62 02 	call	0x4c4	; 0x4c4 <glcd_SelectPage1>
	      }	 

        GLCD.PageNum = pageNumber; /* Keep the track of page selected */
     834:	c0 93 f1 13 	sts	0x13F1, r28
        GLCD.LineNum=lineNumber | C_FirstLineNumberAddress_U8; /* Select the specified line number */
     838:	d8 6b       	ori	r29, 0xB8	; 184
     83a:	d0 93 f2 13 	sts	0x13F2, r29
        GLCD.CursorPos=CursorPosition |0x40; /* Select the specified cursor position */
     83e:	81 2f       	mov	r24, r17
     840:	80 64       	ori	r24, 0x40	; 64
     842:	80 93 f3 13 	sts	0x13F3, r24
        glcd_CmdWrite(GLCD.CursorPos); /* Command the LCD to move to specified page,line,cursor*/
     846:	0e 94 94 02 	call	0x528	; 0x528 <glcd_CmdWrite>
        glcd_CmdWrite(GLCD.LineNum);
     84a:	80 91 f2 13 	lds	r24, 0x13F2
     84e:	0e 94 94 02 	call	0x528	; 0x528 <glcd_CmdWrite>
	}
}
     852:	df 91       	pop	r29
     854:	cf 91       	pop	r28
     856:	1f 91       	pop	r17
     858:	08 95       	ret

0000085a <GLCD_GetCursor>:


void GLCD_GetCursor(uint8_t *page_ptr,uint8_t *line_ptr,uint8_t *cursor_ptr)
{

    *page_ptr=GLCD.PageNum;
     85a:	20 91 f1 13 	lds	r18, 0x13F1
     85e:	fc 01       	movw	r30, r24
     860:	20 83       	st	Z, r18
    *line_ptr=GLCD.LineNum;
     862:	80 91 f2 13 	lds	r24, 0x13F2
     866:	fb 01       	movw	r30, r22
     868:	80 83       	st	Z, r24
    *cursor_ptr=GLCD.CursorPos;
     86a:	80 91 f3 13 	lds	r24, 0x13F3
     86e:	fa 01       	movw	r30, r20
     870:	80 83       	st	Z, r24
}
     872:	08 95       	ret

00000874 <GLCD_GoToPage>:

     Note: The line numbers run from 1 to Maxlines,
 ***************************************************************************************************/
 /* TODO: change the desp and variable name */
void GLCD_GoToPage(uint8_t pageNumber)
{
     874:	cf 93       	push	r28
     876:	c8 2f       	mov	r28, r24

    if((pageNumber==0) || (pageNumber ==1))
     878:	82 30       	cpi	r24, 0x02	; 2
     87a:	a0 f4       	brcc	.+40     	; 0x8a4 <GLCD_GoToPage+0x30>
    { /* for 128/64 GLCD only page 0&1 are supported.
        Select the specified page and move the cursor accordingly */
        if(pageNumber == 0)
     87c:	88 23       	and	r24, r24
     87e:	19 f4       	brne	.+6      	; 0x886 <GLCD_GoToPage+0x12>
        {
            glcd_SelectPage0();
     880:	0e 94 59 02 	call	0x4b2	; 0x4b2 <glcd_SelectPage0>
     884:	02 c0       	rjmp	.+4      	; 0x88a <GLCD_GoToPage+0x16>
        }
        else
        {
            glcd_SelectPage1();
     886:	0e 94 62 02 	call	0x4c4	; 0x4c4 <glcd_SelectPage1>
        }
        GLCD.PageNum=pageNumber;
     88a:	c0 93 f1 13 	sts	0x13F1, r28
        GLCD.CursorPos=0x40;
     88e:	80 e4       	ldi	r24, 0x40	; 64
     890:	80 93 f3 13 	sts	0x13F3, r24
        glcd_CmdWrite(GLCD.LineNum);
     894:	80 91 f2 13 	lds	r24, 0x13F2
     898:	0e 94 94 02 	call	0x528	; 0x528 <glcd_CmdWrite>
        glcd_CmdWrite(GLCD.CursorPos);
     89c:	80 91 f3 13 	lds	r24, 0x13F3
     8a0:	0e 94 94 02 	call	0x528	; 0x528 <glcd_CmdWrite>
    }
}
     8a4:	cf 91       	pop	r28
     8a6:	08 95       	ret

000008a8 <GLCD_GoToLine>:
     Note: The line numbers run from 0 to Maxlines-1, For 128x64 the line numbers will be 0-7
***************************************************************************************************/
/* Todo: All constants for the magic numbers */
void  GLCD_GoToLine(uint8_t var_lineNumber_u8)
{
    if(var_lineNumber_u8 <= C_GlcdLastLine_U8)
     8a8:	88 30       	cpi	r24, 0x08	; 8
     8aa:	30 f4       	brcc	.+12     	; 0x8b8 <GLCD_GoToLine+0x10>
    {   /* If the line number is within range
         then move it to specified line on page0 and keep track*/
        GLCD.LineNum = var_lineNumber_u8+C_FirstLineNumberAddress_U8;
     8ac:	88 54       	subi	r24, 0x48	; 72
     8ae:	80 93 f2 13 	sts	0x13F2, r24
        GLCD_GoToPage(0);
     8b2:	80 e0       	ldi	r24, 0x00	; 0
     8b4:	0e 94 3a 04 	call	0x874	; 0x874 <GLCD_GoToPage>
     8b8:	08 95       	ret

000008ba <GLCD_Clear>:
 * Return value    : none

 * description  :This function clears the LCD and moves the cursor to beginning of first line on page0
 ***************************************************************************************************/
void GLCD_Clear()
{
     8ba:	0f 93       	push	r16
     8bc:	1f 93       	push	r17
     8be:	cf 93       	push	r28
     8c0:	df 93       	push	r29
    uint8_t line,cursor,inversion;

    inversion = GLCD.Invertdisplay;
     8c2:	00 91 f4 13 	lds	r16, 0x13F4
	GLCD.Invertdisplay = 0x00;
     8c6:	10 92 f4 13 	sts	0x13F4, r1
	
    for(line=0;line<8;line++)  /* loop through all the 8lines to clear the display */
     8ca:	10 e0       	ldi	r17, 0x00	; 0
    {
         GLCD_GoToLine(line);  /* Go to beginning of the specified line on page0 */
     8cc:	d1 e0       	ldi	r29, 0x01	; 1
     8ce:	81 2f       	mov	r24, r17
     8d0:	0e 94 54 04 	call	0x8a8	; 0x8a8 <GLCD_GoToLine>
     8d4:	cd 2f       	mov	r28, r29
     8d6:	01 c0       	rjmp	.+2      	; 0x8da <GLCD_Clear+0x20>
     8d8:	cf 5f       	subi	r28, 0xFF	; 255
        
        for(cursor=0;cursor<128;cursor++) /* Clear all the 128 pixels of selected line */
        {
            if(cursor==64)  /* Has the cursor reached end of page0 */
     8da:	c1 34       	cpi	r28, 0x41	; 65
     8dc:	39 f4       	brne	.+14     	; 0x8ec <GLCD_Clear+0x32>
            {
                GLCD_GoToPage(1); /*  then set it to beginning of page1 */
     8de:	8d 2f       	mov	r24, r29
     8e0:	0e 94 3a 04 	call	0x874	; 0x874 <GLCD_GoToPage>
                
            }
            glcd_DataWrite(0x00); /* Clear each pixel by displaying blank */
     8e4:	80 e0       	ldi	r24, 0x00	; 0
     8e6:	0e 94 85 02 	call	0x50a	; 0x50a <glcd_DataWrite>
     8ea:	f6 cf       	rjmp	.-20     	; 0x8d8 <GLCD_Clear+0x1e>
     8ec:	80 e0       	ldi	r24, 0x00	; 0
     8ee:	0e 94 85 02 	call	0x50a	; 0x50a <glcd_DataWrite>
	
    for(line=0;line<8;line++)  /* loop through all the 8lines to clear the display */
    {
         GLCD_GoToLine(line);  /* Go to beginning of the specified line on page0 */
        
        for(cursor=0;cursor<128;cursor++) /* Clear all the 128 pixels of selected line */
     8f2:	cc 23       	and	r28, r28
     8f4:	8c f7       	brge	.-30     	; 0x8d8 <GLCD_Clear+0x1e>
    uint8_t line,cursor,inversion;

    inversion = GLCD.Invertdisplay;
	GLCD.Invertdisplay = 0x00;
	
    for(line=0;line<8;line++)  /* loop through all the 8lines to clear the display */
     8f6:	1f 5f       	subi	r17, 0xFF	; 255
     8f8:	18 30       	cpi	r17, 0x08	; 8
     8fa:	49 f7       	brne	.-46     	; 0x8ce <GLCD_Clear+0x14>
            }
            glcd_DataWrite(0x00); /* Clear each pixel by displaying blank */
        }
    }
	
	GLCD.Invertdisplay = inversion;
     8fc:	00 93 f4 13 	sts	0x13F4, r16

    GLCD_GoToLine(0);
     900:	80 e0       	ldi	r24, 0x00	; 0
     902:	0e 94 54 04 	call	0x8a8	; 0x8a8 <GLCD_GoToLine>
}
     906:	df 91       	pop	r29
     908:	cf 91       	pop	r28
     90a:	1f 91       	pop	r17
     90c:	0f 91       	pop	r16
     90e:	08 95       	ret

00000910 <GLCD_Init>:
 * description  :This function is used to initialize the GLCD.
                 
**************************************************************************************************/
void GLCD_Init()
{
	M_GlcdControlBusDirection = C_PortOutput_U8; /* Configure the data bus and Control bus as Output */
     910:	8f ef       	ldi	r24, 0xFF	; 255
     912:	8a b9       	out	0x0a, r24	; 10
    M_GlcdDataBusDirection = C_PortOutput_U8;
     914:	80 93 04 01 	sts	0x0104, r24
	M_GlcdControlBusDirection1 = C_PortOutput_U8;
     918:	80 93 0a 01 	sts	0x010A, r24


    /* Select the Page0/Page1 and Enable the GLCD */
    glcd_SelectPage0();
     91c:	0e 94 59 02 	call	0x4b2	; 0x4b2 <glcd_SelectPage0>
    glcd_CmdWrite(0x3F);
     920:	8f e3       	ldi	r24, 0x3F	; 63
     922:	0e 94 94 02 	call	0x528	; 0x528 <glcd_CmdWrite>
    glcd_SelectPage1();
     926:	0e 94 62 02 	call	0x4c4	; 0x4c4 <glcd_SelectPage1>
    glcd_CmdWrite(0x3F);
     92a:	8f e3       	ldi	r24, 0x3F	; 63
     92c:	0e 94 94 02 	call	0x528	; 0x528 <glcd_CmdWrite>
     930:	8f ef       	ldi	r24, 0xFF	; 255
     932:	9f e8       	ldi	r25, 0x8F	; 143
     934:	01 97       	sbiw	r24, 0x01	; 1
     936:	f1 f7       	brne	.-4      	; 0x934 <GLCD_Init+0x24>
     938:	00 c0       	rjmp	.+0      	; 0x93a <GLCD_Init+0x2a>
     93a:	00 00       	nop
    DELAY_ms(10);

    /* Select the Page0/Page1 and Enable the GLCD */
    glcd_SelectPage0();
     93c:	0e 94 59 02 	call	0x4b2	; 0x4b2 <glcd_SelectPage0>
    glcd_CmdWrite(0xc0);
     940:	80 ec       	ldi	r24, 0xC0	; 192
     942:	0e 94 94 02 	call	0x528	; 0x528 <glcd_CmdWrite>
    glcd_SelectPage1();
     946:	0e 94 62 02 	call	0x4c4	; 0x4c4 <glcd_SelectPage1>
    glcd_CmdWrite(0xc0);
     94a:	80 ec       	ldi	r24, 0xC0	; 192
     94c:	0e 94 94 02 	call	0x528	; 0x528 <glcd_CmdWrite>

   /* Clear the complete LCD and move the cursor to beginning of page0*/
    GLCD_Clear();
     950:	0e 94 5d 04 	call	0x8ba	; 0x8ba <GLCD_Clear>
}
     954:	08 95       	ret

00000956 <GLCD_GoToNextLine>:
 ***************************************************************************************************/
void  GLCD_GoToNextLine()
{
    /*Increment the current line number.
      In case it exceeds the limit, rool it back to first line */
    GLCD.LineNum++;
     956:	80 91 f2 13 	lds	r24, 0x13F2
     95a:	8f 5f       	subi	r24, 0xFF	; 255
     95c:	80 93 f2 13 	sts	0x13F2, r24
    if(GLCD.LineNum > C_LastLineNumberAddress_U8)
     960:	80 3c       	cpi	r24, 0xC0	; 192
     962:	18 f0       	brcs	.+6      	; 0x96a <GLCD_GoToNextLine+0x14>
      GLCD.LineNum = C_FirstLineNumberAddress_U8;
     964:	88 eb       	ldi	r24, 0xB8	; 184
     966:	80 93 f2 13 	sts	0x13F2, r24
    GLCD_GoToPage(0); /* Finally move it to next line on page0 */
     96a:	80 e0       	ldi	r24, 0x00	; 0
     96c:	0e 94 3a 04 	call	0x874	; 0x874 <GLCD_GoToPage>
}
     970:	08 95       	ret

00000972 <GLCD_EnableDisplayInversion>:



void GLCD_EnableDisplayInversion()
{
	GLCD.Invertdisplay = 0xff;
     972:	8f ef       	ldi	r24, 0xFF	; 255
     974:	80 93 f4 13 	sts	0x13F4, r24
}
     978:	08 95       	ret

0000097a <GLCD_DisableDisplayInversion>:



void GLCD_DisableDisplayInversion()
{
	GLCD.Invertdisplay = 0x00;
     97a:	10 92 f4 13 	sts	0x13F4, r1
}
     97e:	08 95       	ret

00000980 <GLCD_DisplayChar>:
                  Any valid ascii value can be passed to display respective character

 ***************************************************************************************************/
 /* Add the comments for decoding the character, Even offset handling*/
void GLCD_DisplayChar(uint8_t var_lcdData_u8)
{
     980:	ef 92       	push	r14
     982:	ff 92       	push	r15
     984:	0f 93       	push	r16
     986:	1f 93       	push	r17
     988:	cf 93       	push	r28
     98a:	df 93       	push	r29
     98c:	c8 2f       	mov	r28, r24
    uint8_t dat;
	const uint8_t *ptr;

    if(((GLCD.PageNum == 0x01) && (GLCD.CursorPos>=0x7c)) || (var_lcdData_u8=='\n'))
     98e:	80 91 f1 13 	lds	r24, 0x13F1
     992:	81 30       	cpi	r24, 0x01	; 1
     994:	21 f4       	brne	.+8      	; 0x99e <GLCD_DisplayChar+0x1e>
     996:	80 91 f3 13 	lds	r24, 0x13F3
     99a:	8c 37       	cpi	r24, 0x7C	; 124
     99c:	18 f4       	brcc	.+6      	; 0x9a4 <GLCD_DisplayChar+0x24>
     99e:	ca 30       	cpi	r28, 0x0A	; 10
     9a0:	29 f4       	brne	.+10     	; 0x9ac <GLCD_DisplayChar+0x2c>
     9a2:	30 c0       	rjmp	.+96     	; 0xa04 <GLCD_DisplayChar+0x84>
    {
        /* If the cursor has reached to end of line on page1
        OR NewLine command is issued Then Move the cursor to next line */
        GLCD_GoToNextLine();
     9a4:	0e 94 ab 04 	call	0x956	; 0x956 <GLCD_GoToNextLine>
    }
       if(var_lcdData_u8!='\n') /* TODO */
     9a8:	ca 30       	cpi	r28, 0x0A	; 10
     9aa:	71 f1       	breq	.+92     	; 0xa08 <GLCD_DisplayChar+0x88>
    {
        ptr= &ARR_GlcdFont_U8[var_lcdData_u8][0]; /* Get the address of the Character pattern from LookUp */
     9ac:	8c 2f       	mov	r24, r28
     9ae:	90 e0       	ldi	r25, 0x00	; 0
     9b0:	ec 01       	movw	r28, r24
     9b2:	cc 0f       	add	r28, r28
     9b4:	dd 1f       	adc	r29, r29
     9b6:	cc 0f       	add	r28, r28
     9b8:	dd 1f       	adc	r29, r29
     9ba:	cc 0f       	add	r28, r28
     9bc:	dd 1f       	adc	r29, r29
     9be:	c8 1b       	sub	r28, r24
     9c0:	d9 0b       	sbc	r29, r25
     9c2:	cc 51       	subi	r28, 0x1C	; 28
     9c4:	df 4f       	sbci	r29, 0xFF	; 255
        //ptr= &Trebuchet_MS47x63[var_lcdData_u8][0]; /* Get the address of the Character pattern from LookUp */
        //ptr= &new_Font[var_lcdData_u8][0]; /* Get the address of the Character pattern from LookUp */
        //ptr= &new_Font[var_lcdData_u8]; /* Get the address of the Character pattern from LookUp */
        while(1)
        {
            if((GLCD.PageNum == 0x00) && (GLCD.CursorPos==0x80))
     9c6:	0f 2e       	mov	r0, r31
     9c8:	f1 ef       	ldi	r31, 0xF1	; 241
     9ca:	ef 2e       	mov	r14, r31
     9cc:	f3 e1       	ldi	r31, 0x13	; 19
     9ce:	ff 2e       	mov	r15, r31
     9d0:	f0 2d       	mov	r31, r0
     9d2:	03 ef       	ldi	r16, 0xF3	; 243
     9d4:	13 e1       	ldi	r17, 0x13	; 19
     9d6:	f7 01       	movw	r30, r14
     9d8:	80 81       	ld	r24, Z
     9da:	88 23       	and	r24, r24
     9dc:	39 f4       	brne	.+14     	; 0x9ec <GLCD_DisplayChar+0x6c>
     9de:	f8 01       	movw	r30, r16
     9e0:	80 81       	ld	r24, Z
     9e2:	80 38       	cpi	r24, 0x80	; 128
     9e4:	19 f4       	brne	.+6      	; 0x9ec <GLCD_DisplayChar+0x6c>
            {
                /* If the cursor has reached to end of line on page0
                     Then Move the cursor to Page1 */
                GLCD_GoToPage(1);
     9e6:	81 e0       	ldi	r24, 0x01	; 1
     9e8:	0e 94 3a 04 	call	0x874	; 0x874 <GLCD_GoToPage>
            }

            dat= pgm_read_byte(ptr++);/* Get the data to be displayed for LookUptable*/
     9ec:	fe 01       	movw	r30, r28
     9ee:	84 91       	lpm	r24, Z

            if(dat==0xff) /* Exit the loop if End of char is encountered */
     9f0:	8f 3f       	cpi	r24, 0xFF	; 255
     9f2:	51 f0       	breq	.+20     	; 0xa08 <GLCD_DisplayChar+0x88>
                /* If the cursor has reached to end of line on page0
                     Then Move the cursor to Page1 */
                GLCD_GoToPage(1);
            }

            dat= pgm_read_byte(ptr++);/* Get the data to be displayed for LookUptable*/
     9f4:	21 96       	adiw	r28, 0x01	; 1

            if(dat==0xff) /* Exit the loop if End of char is encountered */
                break;

            glcd_DataWrite(dat); /* Display the data and keep track of cursor */
     9f6:	0e 94 85 02 	call	0x50a	; 0x50a <glcd_DataWrite>
            GLCD.CursorPos++;
     9fa:	f8 01       	movw	r30, r16
     9fc:	80 81       	ld	r24, Z
     9fe:	8f 5f       	subi	r24, 0xFF	; 255
     a00:	80 83       	st	Z, r24
        }
     a02:	e9 cf       	rjmp	.-46     	; 0x9d6 <GLCD_DisplayChar+0x56>

    if(((GLCD.PageNum == 0x01) && (GLCD.CursorPos>=0x7c)) || (var_lcdData_u8=='\n'))
    {
        /* If the cursor has reached to end of line on page1
        OR NewLine command is issued Then Move the cursor to next line */
        GLCD_GoToNextLine();
     a04:	0e 94 ab 04 	call	0x956	; 0x956 <GLCD_GoToNextLine>

            glcd_DataWrite(dat); /* Display the data and keep track of cursor */
            GLCD.CursorPos++;
        }
    }
}
     a08:	df 91       	pop	r29
     a0a:	cf 91       	pop	r28
     a0c:	1f 91       	pop	r17
     a0e:	0f 91       	pop	r16
     a10:	ff 90       	pop	r15
     a12:	ef 90       	pop	r14
     a14:	08 95       	ret

00000a16 <GLCD_DisplayString>:
                    and traverses till the end(NULL CHAR)and displays a char each time.

 ***************************************************************************************************/
#if (Enable_GLCD_DisplayString==1)
void GLCD_DisplayString(char *ptr_stringPointer_u8)
{
     a16:	cf 93       	push	r28
     a18:	df 93       	push	r29
     a1a:	ec 01       	movw	r28, r24
    while((*ptr_stringPointer_u8)!=0)
     a1c:	88 81       	ld	r24, Y
     a1e:	88 23       	and	r24, r24
     a20:	31 f0       	breq	.+12     	; 0xa2e <GLCD_DisplayString+0x18>
                 1.The ptr_stringPointer_u8 points to the first char of the string
                    and traverses till the end(NULL CHAR)and displays a char each time.

 ***************************************************************************************************/
#if (Enable_GLCD_DisplayString==1)
void GLCD_DisplayString(char *ptr_stringPointer_u8)
     a22:	21 96       	adiw	r28, 0x01	; 1
{
    while((*ptr_stringPointer_u8)!=0)
        GLCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
     a24:	0e 94 c0 04 	call	0x980	; 0x980 <GLCD_DisplayChar>

 ***************************************************************************************************/
#if (Enable_GLCD_DisplayString==1)
void GLCD_DisplayString(char *ptr_stringPointer_u8)
{
    while((*ptr_stringPointer_u8)!=0)
     a28:	89 91       	ld	r24, Y+
     a2a:	88 23       	and	r24, r24
     a2c:	d9 f7       	brne	.-10     	; 0xa24 <GLCD_DisplayString+0xe>
        GLCD_DisplayChar(*ptr_stringPointer_u8++); // Loop through the string and display char by char
}
     a2e:	df 91       	pop	r29
     a30:	cf 91       	pop	r28
     a32:	08 95       	ret

00000a34 <GLCD_DisplayDecimalNumber>:
                2.(12345,6) then 6-digits ie. 012345 will be displayed
                3.(12345,C_DisplayDefaultDigits_U8) then 12345 will be displayed.
 ***************************************************************************************************/
#if ((Enable_GLCD_DisplayDecimalNumber == 1) || (Enable_GLCD_DisplayFloatNumber == 1))
void GLCD_DisplayDecimalNumber(uint32_t var_DecNumber_u32, uint8_t var_numOfDigitsToDisplay_u8)
{
     a34:	8f 92       	push	r8
     a36:	9f 92       	push	r9
     a38:	af 92       	push	r10
     a3a:	bf 92       	push	r11
     a3c:	ef 92       	push	r14
     a3e:	ff 92       	push	r15
     a40:	0f 93       	push	r16
     a42:	1f 93       	push	r17
     a44:	cf 93       	push	r28
     a46:	df 93       	push	r29
     a48:	cd b7       	in	r28, 0x3d	; 61
     a4a:	de b7       	in	r29, 0x3e	; 62
     a4c:	2a 97       	sbiw	r28, 0x0a	; 10
     a4e:	0f b6       	in	r0, 0x3f	; 63
     a50:	f8 94       	cli
     a52:	de bf       	out	0x3e, r29	; 62
     a54:	0f be       	out	0x3f, r0	; 63
     a56:	cd bf       	out	0x3d, r28	; 61
     a58:	dc 01       	movw	r26, r24
     a5a:	cb 01       	movw	r24, r22
     a5c:	04 2f       	mov	r16, r20
    uint8_t i=0,a[10];

    if(var_DecNumber_u32==0)
     a5e:	00 97       	sbiw	r24, 0x00	; 0
     a60:	a1 05       	cpc	r26, r1
     a62:	b1 05       	cpc	r27, r1
     a64:	19 f0       	breq	.+6      	; 0xa6c <GLCD_DisplayDecimalNumber+0x38>
        for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_GlcdMaxDigitsToDisplay_U8));i++)
            a[i] = 0x00;
    }
    else
    {
        for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
     a66:	44 23       	and	r20, r20
     a68:	71 f4       	brne	.+28     	; 0xa86 <GLCD_DisplayDecimalNumber+0x52>
     a6a:	43 c0       	rjmp	.+134    	; 0xaf2 <GLCD_DisplayDecimalNumber+0xbe>
    uint8_t i=0,a[10];

    if(var_DecNumber_u32==0)
    {
        /* If the number is zero then update the array with the same for displaying */
        for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_GlcdMaxDigitsToDisplay_U8));i++)
     a6c:	44 23       	and	r20, r20
     a6e:	09 f4       	brne	.+2      	; 0xa72 <GLCD_DisplayDecimalNumber+0x3e>
     a70:	40 c0       	rjmp	.+128    	; 0xaf2 <GLCD_DisplayDecimalNumber+0xbe>
     a72:	fe 01       	movw	r30, r28
     a74:	31 96       	adiw	r30, 0x01	; 1
     a76:	10 e0       	ldi	r17, 0x00	; 0
            a[i] = 0x00;
     a78:	11 92       	st	Z+, r1
    uint8_t i=0,a[10];

    if(var_DecNumber_u32==0)
    {
        /* If the number is zero then update the array with the same for displaying */
        for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_GlcdMaxDigitsToDisplay_U8));i++)
     a7a:	1f 5f       	subi	r17, 0xFF	; 255
     a7c:	10 17       	cp	r17, r16
     a7e:	81 f1       	breq	.+96     	; 0xae0 <GLCD_DisplayDecimalNumber+0xac>
     a80:	1a 30       	cpi	r17, 0x0A	; 10
     a82:	d1 f7       	brne	.-12     	; 0xa78 <GLCD_DisplayDecimalNumber+0x44>
     a84:	2d c0       	rjmp	.+90     	; 0xae0 <GLCD_DisplayDecimalNumber+0xac>
     a86:	7e 01       	movw	r14, r28
     a88:	08 94       	sec
     a8a:	e1 1c       	adc	r14, r1
     a8c:	f1 1c       	adc	r15, r1
            a[i] = 0x00;
    }
    else
    {
        for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
     a8e:	10 e0       	ldi	r17, 0x00	; 0
            {
                /* Extract the digits from the number till it becomes zero.
                First get the remainder and divide the number by 10 each time.
                If var_num_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(var_DecNumber_u32,10);
     a90:	0f 2e       	mov	r0, r31
     a92:	fa e0       	ldi	r31, 0x0A	; 10
     a94:	8f 2e       	mov	r8, r31
     a96:	f0 e0       	ldi	r31, 0x00	; 0
     a98:	9f 2e       	mov	r9, r31
     a9a:	f0 e0       	ldi	r31, 0x00	; 0
     a9c:	af 2e       	mov	r10, r31
     a9e:	f0 e0       	ldi	r31, 0x00	; 0
     aa0:	bf 2e       	mov	r11, r31
     aa2:	f0 2d       	mov	r31, r0
    {
        for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
        {
            /* Continue extracting the digits from right side
               till the Specified var_numOfDigitsToDisplay_u8 */
            if(var_DecNumber_u32!=0)
     aa4:	00 97       	sbiw	r24, 0x00	; 0
     aa6:	a1 05       	cpc	r26, r1
     aa8:	b1 05       	cpc	r27, r1
     aaa:	69 f0       	breq	.+26     	; 0xac6 <GLCD_DisplayDecimalNumber+0x92>
            {
                /* Extract the digits from the number till it becomes zero.
                First get the remainder and divide the number by 10 each time.
                If var_num_u32 = 123 then extracted remainder will be 3 and number will be 12.
                The process continues till it becomes zero or max digits reached*/
                a[i]=util_GetMod32(var_DecNumber_u32,10);
     aac:	bc 01       	movw	r22, r24
     aae:	cd 01       	movw	r24, r26
     ab0:	a5 01       	movw	r20, r10
     ab2:	94 01       	movw	r18, r8
     ab4:	0e 94 2a 14 	call	0x2854	; 0x2854 <__udivmodsi4>
     ab8:	f7 01       	movw	r30, r14
     aba:	60 83       	st	Z, r22
                var_DecNumber_u32=var_DecNumber_u32/10;
     abc:	82 2f       	mov	r24, r18
     abe:	93 2f       	mov	r25, r19
     ac0:	a4 2f       	mov	r26, r20
     ac2:	b5 2f       	mov	r27, r21
     ac4:	04 c0       	rjmp	.+8      	; 0xace <GLCD_DisplayDecimalNumber+0x9a>
            }
            else if( (var_numOfDigitsToDisplay_u8 == C_GlcdDisplayDefaultDigits_U8) ||
     ac6:	0b 30       	cpi	r16, 0x0B	; 11
     ac8:	48 f4       	brcc	.+18     	; 0xadc <GLCD_DisplayDecimalNumber+0xa8>
            else
            {
                /* In case user expects more digits to be displayed than the actual digits in number,
                  then update the remaining digits with zero.
               Ex: var_num_u32 is 123 and user wants five digits then 00123 has to be displayed */
                a[i]=0;
     aca:	f7 01       	movw	r30, r14
     acc:	10 82       	st	Z, r1
        for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_GlcdMaxDigitsToDisplay_U8));i++)
            a[i] = 0x00;
    }
    else
    {
        for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
     ace:	1f 5f       	subi	r17, 0xFF	; 255
     ad0:	08 94       	sec
     ad2:	e1 1c       	adc	r14, r1
     ad4:	f1 1c       	adc	r15, r1
     ad6:	10 17       	cp	r17, r16
     ad8:	29 f7       	brne	.-54     	; 0xaa4 <GLCD_DisplayDecimalNumber+0x70>
     ada:	02 c0       	rjmp	.+4      	; 0xae0 <GLCD_DisplayDecimalNumber+0xac>
            }
        }
    }


    while(i)
     adc:	11 23       	and	r17, r17
     ade:	49 f0       	breq	.+18     	; 0xaf2 <GLCD_DisplayDecimalNumber+0xbe>
    { 
        /* Finally get the ascii values of the digits and display*/
        GLCD_DisplayChar(util_Dec2Ascii(a[i-1]));
     ae0:	fe 01       	movw	r30, r28
     ae2:	e1 0f       	add	r30, r17
     ae4:	f1 1d       	adc	r31, r1
     ae6:	80 81       	ld	r24, Z
     ae8:	80 5d       	subi	r24, 0xD0	; 208
     aea:	0e 94 c0 04 	call	0x980	; 0x980 <GLCD_DisplayChar>
        i--;
     aee:	11 50       	subi	r17, 0x01	; 1
            }
        }
    }


    while(i)
     af0:	b9 f7       	brne	.-18     	; 0xae0 <GLCD_DisplayDecimalNumber+0xac>
    { 
        /* Finally get the ascii values of the digits and display*/
        GLCD_DisplayChar(util_Dec2Ascii(a[i-1]));
        i--;
    }
}
     af2:	2a 96       	adiw	r28, 0x0a	; 10
     af4:	0f b6       	in	r0, 0x3f	; 63
     af6:	f8 94       	cli
     af8:	de bf       	out	0x3e, r29	; 62
     afa:	0f be       	out	0x3f, r0	; 63
     afc:	cd bf       	out	0x3d, r28	; 61
     afe:	df 91       	pop	r29
     b00:	cf 91       	pop	r28
     b02:	1f 91       	pop	r17
     b04:	0f 91       	pop	r16
     b06:	ff 90       	pop	r15
     b08:	ef 90       	pop	r14
     b0a:	bf 90       	pop	r11
     b0c:	af 90       	pop	r10
     b0e:	9f 90       	pop	r9
     b10:	8f 90       	pop	r8
     b12:	08 95       	ret

00000b14 <GLCD_DisplayHexNumber>:
                2.(0x12AB,6) then 6-digits ie. 0012AB will be displayed
                3.(0x12AB,C_DisplayDefaultDigits_U8) then 12AB will be displayed.
 ***************************************************************************************************/
#if ( Enable_GLCD_DisplayHexNumber == 1 ) 
void GLCD_DisplayHexNumber(uint32_t var_hexNumber_u32,uint8_t var_numOfDigitsToDisplay_u8)
{
     b14:	1f 93       	push	r17
     b16:	cf 93       	push	r28
     b18:	df 93       	push	r29
     b1a:	cd b7       	in	r28, 0x3d	; 61
     b1c:	de b7       	in	r29, 0x3e	; 62
     b1e:	2a 97       	sbiw	r28, 0x0a	; 10
     b20:	0f b6       	in	r0, 0x3f	; 63
     b22:	f8 94       	cli
     b24:	de bf       	out	0x3e, r29	; 62
     b26:	0f be       	out	0x3f, r0	; 63
     b28:	cd bf       	out	0x3d, r28	; 61
     b2a:	dc 01       	movw	r26, r24
     b2c:	cb 01       	movw	r24, r22
    uint8_t i=0,a[10];

    if(var_hexNumber_u32==0)
     b2e:	00 97       	sbiw	r24, 0x00	; 0
     b30:	a1 05       	cpc	r26, r1
     b32:	b1 05       	cpc	r27, r1
     b34:	19 f0       	breq	.+6      	; 0xb3c <GLCD_DisplayHexNumber+0x28>
        for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_GlcdMaxDigitsToDisplay_U8));i++)
            a[i] = 0x00;
    }
    else
    {
        for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
     b36:	44 23       	and	r20, r20
     b38:	69 f4       	brne	.+26     	; 0xb54 <GLCD_DisplayHexNumber+0x40>
     b3a:	36 c0       	rjmp	.+108    	; 0xba8 <GLCD_DisplayHexNumber+0x94>
    uint8_t i=0,a[10];

    if(var_hexNumber_u32==0)
    {
        /* If the number zero then update the array with the same for displaying */
        for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_GlcdMaxDigitsToDisplay_U8));i++)
     b3c:	44 23       	and	r20, r20
     b3e:	a1 f1       	breq	.+104    	; 0xba8 <GLCD_DisplayHexNumber+0x94>
     b40:	fe 01       	movw	r30, r28
     b42:	31 96       	adiw	r30, 0x01	; 1
     b44:	10 e0       	ldi	r17, 0x00	; 0
            a[i] = 0x00;
     b46:	11 92       	st	Z+, r1
    uint8_t i=0,a[10];

    if(var_hexNumber_u32==0)
    {
        /* If the number zero then update the array with the same for displaying */
        for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_GlcdMaxDigitsToDisplay_U8));i++)
     b48:	1f 5f       	subi	r17, 0xFF	; 255
     b4a:	14 17       	cp	r17, r20
     b4c:	01 f1       	breq	.+64     	; 0xb8e <GLCD_DisplayHexNumber+0x7a>
     b4e:	1a 30       	cpi	r17, 0x0A	; 10
     b50:	d1 f7       	brne	.-12     	; 0xb46 <GLCD_DisplayHexNumber+0x32>
     b52:	1d c0       	rjmp	.+58     	; 0xb8e <GLCD_DisplayHexNumber+0x7a>
     b54:	fe 01       	movw	r30, r28
     b56:	31 96       	adiw	r30, 0x01	; 1
            a[i] = 0x00;
    }
    else
    {
        for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
     b58:	10 e0       	ldi	r17, 0x00	; 0
        {
            /* Continue extracting the digits from right side
               till the Specified var_numOfDigitsToDisplay_u8 */
            if(var_hexNumber_u32!=0)
     b5a:	00 97       	sbiw	r24, 0x00	; 0
     b5c:	a1 05       	cpc	r26, r1
     b5e:	b1 05       	cpc	r27, r1
     b60:	61 f0       	breq	.+24     	; 0xb7a <GLCD_DisplayHexNumber+0x66>
            {
                /* Extract the digits from the number till it becomes zero.
               First get the lower nibble and shift the number 4 times.
               if var_num_u32 = 0xABC then extracted digit will be 0x0C and number will become 0xAB.
               The process continues till it becomes zero or max digits reached*/
                a[i]=(uint8_t)(var_hexNumber_u32 & 0x0f);
     b62:	28 2f       	mov	r18, r24
     b64:	2f 70       	andi	r18, 0x0F	; 15
     b66:	20 83       	st	Z, r18
                var_hexNumber_u32=var_hexNumber_u32 >> 4;
     b68:	68 94       	set
     b6a:	13 f8       	bld	r1, 3
     b6c:	b6 95       	lsr	r27
     b6e:	a7 95       	ror	r26
     b70:	97 95       	ror	r25
     b72:	87 95       	ror	r24
     b74:	16 94       	lsr	r1
     b76:	d1 f7       	brne	.-12     	; 0xb6c <GLCD_DisplayHexNumber+0x58>
     b78:	03 c0       	rjmp	.+6      	; 0xb80 <GLCD_DisplayHexNumber+0x6c>
            }
            else if( (var_numOfDigitsToDisplay_u8 == C_GlcdDisplayDefaultDigits_U8) ||
     b7a:	4b 30       	cpi	r20, 0x0B	; 11
     b7c:	30 f4       	brcc	.+12     	; 0xb8a <GLCD_DisplayHexNumber+0x76>
            else
            {
                /* In case user expects more digits to be displayed than the actual digits in number,
                  then update the remaining digits with zero.
                Ex: var_num_u32 is 0x123 and user wants five digits then 00123 has to be displayed */
                a[i]=0x00;
     b7e:	10 82       	st	Z, r1
        for(i=0;((i<var_numOfDigitsToDisplay_u8) && (i<C_GlcdMaxDigitsToDisplay_U8));i++)
            a[i] = 0x00;
    }
    else
    {
        for(i=0;i<var_numOfDigitsToDisplay_u8;i++)
     b80:	1f 5f       	subi	r17, 0xFF	; 255
     b82:	31 96       	adiw	r30, 0x01	; 1
     b84:	14 17       	cp	r17, r20
     b86:	49 f7       	brne	.-46     	; 0xb5a <GLCD_DisplayHexNumber+0x46>
     b88:	02 c0       	rjmp	.+4      	; 0xb8e <GLCD_DisplayHexNumber+0x7a>
                a[i]=0x00;
            }
        }
    }

    while(i!=0)
     b8a:	11 23       	and	r17, r17
     b8c:	69 f0       	breq	.+26     	; 0xba8 <GLCD_DisplayHexNumber+0x94>
    {
        /* Finally get the ascii values of the digits and display*/
        GLCD_DisplayChar(util_Hex2Ascii(a[i-1]));
     b8e:	fe 01       	movw	r30, r28
     b90:	e1 0f       	add	r30, r17
     b92:	f1 1d       	adc	r31, r1
     b94:	80 81       	ld	r24, Z
     b96:	8a 30       	cpi	r24, 0x0A	; 10
     b98:	10 f0       	brcs	.+4      	; 0xb9e <GLCD_DisplayHexNumber+0x8a>
     b9a:	89 5c       	subi	r24, 0xC9	; 201
     b9c:	01 c0       	rjmp	.+2      	; 0xba0 <GLCD_DisplayHexNumber+0x8c>
     b9e:	80 5d       	subi	r24, 0xD0	; 208
     ba0:	0e 94 c0 04 	call	0x980	; 0x980 <GLCD_DisplayChar>
        i--;
     ba4:	11 50       	subi	r17, 0x01	; 1
                a[i]=0x00;
            }
        }
    }

    while(i!=0)
     ba6:	99 f7       	brne	.-26     	; 0xb8e <GLCD_DisplayHexNumber+0x7a>
    {
        /* Finally get the ascii values of the digits and display*/
        GLCD_DisplayChar(util_Hex2Ascii(a[i-1]));
        i--;
    }
}
     ba8:	2a 96       	adiw	r28, 0x0a	; 10
     baa:	0f b6       	in	r0, 0x3f	; 63
     bac:	f8 94       	cli
     bae:	de bf       	out	0x3e, r29	; 62
     bb0:	0f be       	out	0x3f, r0	; 63
     bb2:	cd bf       	out	0x3d, r28	; 61
     bb4:	df 91       	pop	r29
     bb6:	cf 91       	pop	r28
     bb8:	1f 91       	pop	r17
     bba:	08 95       	ret

00000bbc <GLCD_DisplayBinaryNumber>:
                2.(10,8) then 8-LSB will be displayed ie. 00001010
                3.(10,2) then 2-LSB will be displayed ie. 10
 *************************************************************************************************/
#if (Enable_GLCD_DisplayBinaryNumber == 1)
void GLCD_DisplayBinaryNumber(uint32_t var_binNumber_u32, uint8_t var_numOfBitsToDisplay_u8)
{
     bbc:	bf 92       	push	r11
     bbe:	cf 92       	push	r12
     bc0:	df 92       	push	r13
     bc2:	ef 92       	push	r14
     bc4:	ff 92       	push	r15
     bc6:	0f 93       	push	r16
     bc8:	1f 93       	push	r17
     bca:	cf 93       	push	r28
     bcc:	df 93       	push	r29
     bce:	6b 01       	movw	r12, r22
     bd0:	7c 01       	movw	r14, r24
     bd2:	c4 2f       	mov	r28, r20
    uint8_t ch;
      
    while(var_numOfBitsToDisplay_u8!=0)
     bd4:	44 23       	and	r20, r20
     bd6:	19 f1       	breq	.+70     	; 0xc1e <GLCD_DisplayBinaryNumber+0x62>
    {
        /* Start Extracting the bits from the specified bit positions.
         Get the Acsii values of the bits and display */
        ch = util_GetBitStatus(var_binNumber_u32,(var_numOfBitsToDisplay_u8-1));
     bd8:	01 e0       	ldi	r16, 0x01	; 1
     bda:	10 e0       	ldi	r17, 0x00	; 0
     bdc:	d1 e0       	ldi	r29, 0x01	; 1
     bde:	bb 24       	eor	r11, r11
     be0:	4c 2f       	mov	r20, r28
     be2:	50 e0       	ldi	r21, 0x00	; 0
     be4:	41 50       	subi	r20, 0x01	; 1
     be6:	50 40       	sbci	r21, 0x00	; 0
     be8:	c8 01       	movw	r24, r16
     bea:	02 c0       	rjmp	.+4      	; 0xbf0 <GLCD_DisplayBinaryNumber+0x34>
     bec:	88 0f       	add	r24, r24
     bee:	99 1f       	adc	r25, r25
     bf0:	4a 95       	dec	r20
     bf2:	e2 f7       	brpl	.-8      	; 0xbec <GLCD_DisplayBinaryNumber+0x30>
     bf4:	ac 01       	movw	r20, r24
     bf6:	66 27       	eor	r22, r22
     bf8:	57 fd       	sbrc	r21, 7
     bfa:	60 95       	com	r22
     bfc:	76 2f       	mov	r23, r22
     bfe:	4c 21       	and	r20, r12
     c00:	5d 21       	and	r21, r13
     c02:	6e 21       	and	r22, r14
     c04:	7f 21       	and	r23, r15
     c06:	8d 2f       	mov	r24, r29
     c08:	41 15       	cp	r20, r1
     c0a:	51 05       	cpc	r21, r1
     c0c:	61 05       	cpc	r22, r1
     c0e:	71 05       	cpc	r23, r1
     c10:	09 f4       	brne	.+2      	; 0xc14 <GLCD_DisplayBinaryNumber+0x58>
     c12:	8b 2d       	mov	r24, r11
        GLCD_DisplayChar(util_Dec2Ascii(ch));
     c14:	80 5d       	subi	r24, 0xD0	; 208
     c16:	0e 94 c0 04 	call	0x980	; 0x980 <GLCD_DisplayChar>
        var_numOfBitsToDisplay_u8--;
     c1a:	c1 50       	subi	r28, 0x01	; 1
#if (Enable_GLCD_DisplayBinaryNumber == 1)
void GLCD_DisplayBinaryNumber(uint32_t var_binNumber_u32, uint8_t var_numOfBitsToDisplay_u8)
{
    uint8_t ch;
      
    while(var_numOfBitsToDisplay_u8!=0)
     c1c:	09 f7       	brne	.-62     	; 0xbe0 <GLCD_DisplayBinaryNumber+0x24>
         Get the Acsii values of the bits and display */
        ch = util_GetBitStatus(var_binNumber_u32,(var_numOfBitsToDisplay_u8-1));
        GLCD_DisplayChar(util_Dec2Ascii(ch));
        var_numOfBitsToDisplay_u8--;
    }
}
     c1e:	df 91       	pop	r29
     c20:	cf 91       	pop	r28
     c22:	1f 91       	pop	r17
     c24:	0f 91       	pop	r16
     c26:	ff 90       	pop	r15
     c28:	ef 90       	pop	r14
     c2a:	df 90       	pop	r13
     c2c:	cf 90       	pop	r12
     c2e:	bf 90       	pop	r11
     c30:	08 95       	ret

00000c32 <GLCD_DisplayFloatNumber>:
    Note: Float will be disabled by default as it takes huge controller resources
         It can be enabled by changing value of Enable_GLCD_DisplayFloatNumber to 1 in lcd.h
 **************************************************************************************************/
#if (Enable_GLCD_DisplayFloatNumber == 1)  
void GLCD_DisplayFloatNumber(double var_floatNum_f32)
{
     c32:	cf 92       	push	r12
     c34:	df 92       	push	r13
     c36:	ef 92       	push	r14
     c38:	ff 92       	push	r15
     c3a:	0f 93       	push	r16
     c3c:	1f 93       	push	r17
     c3e:	cf 93       	push	r28
     c40:	df 93       	push	r29
     c42:	6b 01       	movw	r12, r22
     c44:	7c 01       	movw	r14, r24
      1.Type cast the number to int to get the integer part.
      2.Display the extracted integer part followed by a decimal point(.).
      3.Later the integer part is made zero by subtracting with the extracted integer value.
      4.Finally the fractional part is multiplied by 100000 to support 6-digit precision */

    var_temp_u32 = (uint32_t) var_floatNum_f32;
     c46:	0e 94 f9 12 	call	0x25f2	; 0x25f2 <__fixunssfsi>
     c4a:	06 2f       	mov	r16, r22
     c4c:	17 2f       	mov	r17, r23
     c4e:	d8 2f       	mov	r29, r24
     c50:	c9 2f       	mov	r28, r25
    GLCD_DisplayDecimalNumber(var_temp_u32,C_GlcdDisplayDefaultDigits_U8);
     c52:	4f ef       	ldi	r20, 0xFF	; 255
     c54:	0e 94 1a 05 	call	0xa34	; 0xa34 <GLCD_DisplayDecimalNumber>

    GLCD_DisplayChar('.');
     c58:	8e e2       	ldi	r24, 0x2E	; 46
     c5a:	0e 94 c0 04 	call	0x980	; 0x980 <GLCD_DisplayChar>

    var_floatNum_f32 = var_floatNum_f32 - var_temp_u32;
     c5e:	60 2f       	mov	r22, r16
     c60:	71 2f       	mov	r23, r17
     c62:	8d 2f       	mov	r24, r29
     c64:	9c 2f       	mov	r25, r28
     c66:	0e 94 25 13 	call	0x264a	; 0x264a <__floatunsisf>
     c6a:	9b 01       	movw	r18, r22
     c6c:	ac 01       	movw	r20, r24
     c6e:	c7 01       	movw	r24, r14
     c70:	b6 01       	movw	r22, r12
     c72:	0e 94 2c 12 	call	0x2458	; 0x2458 <__subsf3>
    var_temp_u32 = var_floatNum_f32 * 1000000;
     c76:	20 e0       	ldi	r18, 0x00	; 0
     c78:	34 e2       	ldi	r19, 0x24	; 36
     c7a:	44 e7       	ldi	r20, 0x74	; 116
     c7c:	59 e4       	ldi	r21, 0x49	; 73
     c7e:	0e 94 b3 13 	call	0x2766	; 0x2766 <__mulsf3>
     c82:	46 2f       	mov	r20, r22
     c84:	57 2f       	mov	r21, r23
     c86:	68 2f       	mov	r22, r24
     c88:	79 2f       	mov	r23, r25
     c8a:	cb 01       	movw	r24, r22
     c8c:	ba 01       	movw	r22, r20
     c8e:	0e 94 f9 12 	call	0x25f2	; 0x25f2 <__fixunssfsi>
    GLCD_DisplayDecimalNumber(var_temp_u32,C_GlcdDisplayDefaultDigits_U8);
     c92:	4f ef       	ldi	r20, 0xFF	; 255
     c94:	0e 94 1a 05 	call	0xa34	; 0xa34 <GLCD_DisplayDecimalNumber>
}
     c98:	df 91       	pop	r29
     c9a:	cf 91       	pop	r28
     c9c:	1f 91       	pop	r17
     c9e:	0f 91       	pop	r16
     ca0:	ff 90       	pop	r15
     ca2:	ef 90       	pop	r14
     ca4:	df 90       	pop	r13
     ca6:	cf 90       	pop	r12
     ca8:	08 95       	ret

00000caa <GLCD_Printf>:
        uint8_t var_Num_u8;
        GLCD_Printf("num1:%u",(uint16_t)var_Num_u8);          
 *************************************************************************************************/
#if ( Enable_GLCD_Printf   == 1 ) 
void GLCD_Printf(const char *argList, ...)
{
     caa:	5f 92       	push	r5
     cac:	6f 92       	push	r6
     cae:	7f 92       	push	r7
     cb0:	8f 92       	push	r8
     cb2:	9f 92       	push	r9
     cb4:	af 92       	push	r10
     cb6:	bf 92       	push	r11
     cb8:	cf 92       	push	r12
     cba:	df 92       	push	r13
     cbc:	ef 92       	push	r14
     cbe:	ff 92       	push	r15
     cc0:	0f 93       	push	r16
     cc2:	1f 93       	push	r17
     cc4:	cf 93       	push	r28
     cc6:	df 93       	push	r29
     cc8:	cd b7       	in	r28, 0x3d	; 61
     cca:	de b7       	in	r29, 0x3e	; 62
     ccc:	0f 2e       	mov	r0, r31
     cce:	f3 e1       	ldi	r31, 0x13	; 19
     cd0:	cf 2e       	mov	r12, r31
     cd2:	dd 24       	eor	r13, r13
     cd4:	f0 2d       	mov	r31, r0
     cd6:	cc 0e       	add	r12, r28
     cd8:	dd 1e       	adc	r13, r29
     cda:	d6 01       	movw	r26, r12
     cdc:	ed 91       	ld	r30, X+
     cde:	fd 91       	ld	r31, X+
     ce0:	6d 01       	movw	r12, r26
    uint8_t var_numOfDigitsToDisp_u8;

    va_start(argp, argList);

    /* Loop through the list to extract all the input arguments */
    for(ptr = argList; *ptr != '\0'; ptr++)
     ce2:	80 81       	ld	r24, Z
     ce4:	88 23       	and	r24, r24
     ce6:	09 f4       	brne	.+2      	; 0xcea <GLCD_Printf+0x40>
     ce8:	2f c1       	rjmp	.+606    	; 0xf48 <GLCD_Printf+0x29e>
     cea:	8f 01       	movw	r16, r30
            
            case 'b':  /* Argument type is of binary,Read int and convert to binary */
                var_num_u16 = va_arg(argp, uint16_t);
#if (Enable_GLCD_DisplayBinaryNumber == 1)                        
                if(var_numOfDigitsToDisp_u8 == C_GlcdMaxDigitsToDisplayUsingPrintf_U8)
                   var_numOfDigitsToDisp_u8 = 16;
     cec:	55 24       	eor	r5, r5
     cee:	68 94       	set
     cf0:	54 f8       	bld	r5, 4
                   ch = *ptr;
                }
            }
            else
            {
              var_numOfDigitsToDisp_u8 = C_GlcdMaxDigitsToDisplayUsingPrintf_U8;
     cf2:	99 24       	eor	r9, r9
     cf4:	9a 94       	dec	r9
 #####: In case of printing the variables(8-bit) its recommended to type cast and promote them to uint16_t.
        uint8_t var_Num_u8;
        GLCD_Printf("num1:%u",(uint16_t)var_Num_u8);          
 *************************************************************************************************/
#if ( Enable_GLCD_Printf   == 1 ) 
void GLCD_Printf(const char *argList, ...)
     cf6:	88 24       	eor	r8, r8
    /* Loop through the list to extract all the input arguments */
    for(ptr = argList; *ptr != '\0'; ptr++)
    {

        ch= *ptr;
        if(ch == '%')         /*Check for '%' as there will be format specifier after it */
     cf8:	85 32       	cpi	r24, 0x25	; 37
     cfa:	09 f0       	breq	.+2      	; 0xcfe <GLCD_Printf+0x54>
     cfc:	18 c1       	rjmp	.+560    	; 0xf2e <GLCD_Printf+0x284>
        {
            ptr++;
     cfe:	58 01       	movw	r10, r16
     d00:	08 94       	sec
     d02:	a1 1c       	adc	r10, r1
     d04:	b1 1c       	adc	r11, r1
            ch = *ptr;
     d06:	f8 01       	movw	r30, r16
     d08:	81 81       	ldd	r24, Z+1	; 0x01
           if((ch>=0x30) && (ch<=0x39))
     d0a:	98 2f       	mov	r25, r24
     d0c:	90 53       	subi	r25, 0x30	; 48
     d0e:	9a 30       	cpi	r25, 0x0A	; 10
     d10:	80 f4       	brcc	.+32     	; 0xd32 <GLCD_Printf+0x88>
 #####: In case of printing the variables(8-bit) its recommended to type cast and promote them to uint16_t.
        uint8_t var_Num_u8;
        GLCD_Printf("num1:%u",(uint16_t)var_Num_u8);          
 *************************************************************************************************/
#if ( Enable_GLCD_Printf   == 1 ) 
void GLCD_Printf(const char *argList, ...)
     d12:	32 96       	adiw	r30, 0x02	; 2
     d14:	18 2d       	mov	r17, r8
           if((ch>=0x30) && (ch<=0x39))
            {
               var_numOfDigitsToDisp_u8 = 0;
               while((ch>=0x30) && (ch<=0x39))
                {
                   var_numOfDigitsToDisp_u8 = (var_numOfDigitsToDisp_u8 * 10) + (ch-0x30);
     d16:	11 0f       	add	r17, r17
     d18:	91 2f       	mov	r25, r17
     d1a:	99 0f       	add	r25, r25
     d1c:	99 0f       	add	r25, r25
     d1e:	19 0f       	add	r17, r25
     d20:	80 53       	subi	r24, 0x30	; 48
     d22:	18 0f       	add	r17, r24
                   ptr++;
     d24:	5f 01       	movw	r10, r30
                   ch = *ptr;
     d26:	81 91       	ld	r24, Z+
            ptr++;
            ch = *ptr;
           if((ch>=0x30) && (ch<=0x39))
            {
               var_numOfDigitsToDisp_u8 = 0;
               while((ch>=0x30) && (ch<=0x39))
     d28:	98 2f       	mov	r25, r24
     d2a:	90 53       	subi	r25, 0x30	; 48
     d2c:	9a 30       	cpi	r25, 0x0A	; 10
     d2e:	98 f3       	brcs	.-26     	; 0xd16 <GLCD_Printf+0x6c>
     d30:	01 c0       	rjmp	.+2      	; 0xd34 <GLCD_Printf+0x8a>
                   ch = *ptr;
                }
            }
            else
            {
              var_numOfDigitsToDisp_u8 = C_GlcdMaxDigitsToDisplayUsingPrintf_U8;
     d32:	19 2d       	mov	r17, r9
            }


            switch(ch)       /* Decode the type of the argument */
     d34:	88 35       	cpi	r24, 0x58	; 88
     d36:	09 f4       	brne	.+2      	; 0xd3a <GLCD_Printf+0x90>
     d38:	a8 c0       	rjmp	.+336    	; 0xe8a <GLCD_Printf+0x1e0>
     d3a:	89 35       	cpi	r24, 0x59	; 89
     d3c:	c0 f4       	brcc	.+48     	; 0xd6e <GLCD_Printf+0xc4>
     d3e:	84 34       	cpi	r24, 0x44	; 68
     d40:	09 f4       	brne	.+2      	; 0xd44 <GLCD_Printf+0x9a>
     d42:	51 c0       	rjmp	.+162    	; 0xde6 <GLCD_Printf+0x13c>
     d44:	85 34       	cpi	r24, 0x45	; 69
     d46:	48 f4       	brcc	.+18     	; 0xd5a <GLCD_Printf+0xb0>
     d48:	82 34       	cpi	r24, 0x42	; 66
     d4a:	09 f4       	brne	.+2      	; 0xd4e <GLCD_Printf+0xa4>
     d4c:	c2 c0       	rjmp	.+388    	; 0xed2 <GLCD_Printf+0x228>
     d4e:	83 34       	cpi	r24, 0x43	; 67
     d50:	28 f5       	brcc	.+74     	; 0xd9c <GLCD_Printf+0xf2>
     d52:	85 32       	cpi	r24, 0x25	; 37
     d54:	09 f0       	breq	.+2      	; 0xd58 <GLCD_Printf+0xae>
     d56:	ee c0       	rjmp	.+476    	; 0xf34 <GLCD_Printf+0x28a>
     d58:	e6 c0       	rjmp	.+460    	; 0xf26 <GLCD_Printf+0x27c>
     d5a:	83 35       	cpi	r24, 0x53	; 83
     d5c:	09 f4       	brne	.+2      	; 0xd60 <GLCD_Printf+0xb6>
     d5e:	d9 c0       	rjmp	.+434    	; 0xf12 <GLCD_Printf+0x268>
     d60:	85 35       	cpi	r24, 0x55	; 85
     d62:	09 f4       	brne	.+2      	; 0xd66 <GLCD_Printf+0xbc>
     d64:	71 c0       	rjmp	.+226    	; 0xe48 <GLCD_Printf+0x19e>
     d66:	86 34       	cpi	r24, 0x46	; 70
     d68:	09 f0       	breq	.+2      	; 0xd6c <GLCD_Printf+0xc2>
     d6a:	e4 c0       	rjmp	.+456    	; 0xf34 <GLCD_Printf+0x28a>
     d6c:	c6 c0       	rjmp	.+396    	; 0xefa <GLCD_Printf+0x250>
     d6e:	86 36       	cpi	r24, 0x66	; 102
     d70:	09 f4       	brne	.+2      	; 0xd74 <GLCD_Printf+0xca>
     d72:	c3 c0       	rjmp	.+390    	; 0xefa <GLCD_Printf+0x250>
     d74:	87 36       	cpi	r24, 0x67	; 103
     d76:	40 f4       	brcc	.+16     	; 0xd88 <GLCD_Printf+0xde>
     d78:	83 36       	cpi	r24, 0x63	; 99
     d7a:	81 f0       	breq	.+32     	; 0xd9c <GLCD_Printf+0xf2>
     d7c:	84 36       	cpi	r24, 0x64	; 100
     d7e:	b9 f0       	breq	.+46     	; 0xdae <GLCD_Printf+0x104>
     d80:	82 36       	cpi	r24, 0x62	; 98
     d82:	09 f0       	breq	.+2      	; 0xd86 <GLCD_Printf+0xdc>
     d84:	d7 c0       	rjmp	.+430    	; 0xf34 <GLCD_Printf+0x28a>
     d86:	91 c0       	rjmp	.+290    	; 0xeaa <GLCD_Printf+0x200>
     d88:	85 37       	cpi	r24, 0x75	; 117
     d8a:	09 f4       	brne	.+2      	; 0xd8e <GLCD_Printf+0xe4>
     d8c:	4c c0       	rjmp	.+152    	; 0xe26 <GLCD_Printf+0x17c>
     d8e:	88 37       	cpi	r24, 0x78	; 120
     d90:	09 f4       	brne	.+2      	; 0xd94 <GLCD_Printf+0xea>
     d92:	6a c0       	rjmp	.+212    	; 0xe68 <GLCD_Printf+0x1be>
     d94:	83 37       	cpi	r24, 0x73	; 115
     d96:	09 f0       	breq	.+2      	; 0xd9a <GLCD_Printf+0xf0>
     d98:	cd c0       	rjmp	.+410    	; 0xf34 <GLCD_Printf+0x28a>
     d9a:	bb c0       	rjmp	.+374    	; 0xf12 <GLCD_Printf+0x268>
            {
            case 'C':
            case 'c':     /* Argument type is of char, hence read char data from the argp */
                ch = va_arg(argp, uint16_t);
     d9c:	86 01       	movw	r16, r12
     d9e:	0e 5f       	subi	r16, 0xFE	; 254
     da0:	1f 4f       	sbci	r17, 0xFF	; 255
                GLCD_DisplayChar(ch);
     da2:	d6 01       	movw	r26, r12
     da4:	8c 91       	ld	r24, X
     da6:	0e 94 c0 04 	call	0x980	; 0x980 <GLCD_DisplayChar>

            switch(ch)       /* Decode the type of the argument */
            {
            case 'C':
            case 'c':     /* Argument type is of char, hence read char data from the argp */
                ch = va_arg(argp, uint16_t);
     daa:	68 01       	movw	r12, r16
                GLCD_DisplayChar(ch);
                break;
     dac:	c3 c0       	rjmp	.+390    	; 0xf34 <GLCD_Printf+0x28a>

            case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
                var_num_s16 = va_arg(argp, sint16_t);
     dae:	ee 24       	eor	r14, r14
     db0:	ff 24       	eor	r15, r15
     db2:	68 94       	set
     db4:	e1 f8       	bld	r14, 1
     db6:	ec 0c       	add	r14, r12
     db8:	fd 1c       	adc	r15, r13
     dba:	f6 01       	movw	r30, r12
     dbc:	c0 80       	ld	r12, Z
     dbe:	d1 80       	ldd	r13, Z+1	; 0x01
#if (Enable_GLCD_DisplayDecimalNumber == 1)
                if(var_num_s16<0)
     dc0:	dd 20       	and	r13, r13
     dc2:	3c f4       	brge	.+14     	; 0xdd2 <GLCD_Printf+0x128>
                 { /* If the number is -ve then display the 2's complement along with '-' sign */ 
                   var_num_s16 = -var_num_s16;
     dc4:	d0 94       	com	r13
     dc6:	c1 94       	neg	r12
     dc8:	d1 08       	sbc	r13, r1
     dca:	d3 94       	inc	r13
                   GLCD_DisplayChar('-');
     dcc:	8d e2       	ldi	r24, 0x2D	; 45
     dce:	0e 94 c0 04 	call	0x980	; 0x980 <GLCD_DisplayChar>
                 }
                GLCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
     dd2:	b6 01       	movw	r22, r12
     dd4:	88 27       	eor	r24, r24
     dd6:	77 fd       	sbrc	r23, 7
     dd8:	80 95       	com	r24
     dda:	98 2f       	mov	r25, r24
     ddc:	41 2f       	mov	r20, r17
     dde:	0e 94 1a 05 	call	0xa34	; 0xa34 <GLCD_DisplayDecimalNumber>
                ch = va_arg(argp, uint16_t);
                GLCD_DisplayChar(ch);
                break;

            case 'd':    /* Argument type is of signed integer, hence read 16bit data from the argp */
                var_num_s16 = va_arg(argp, sint16_t);
     de2:	67 01       	movw	r12, r14
                   var_num_s16 = -var_num_s16;
                   GLCD_DisplayChar('-');
                 }
                GLCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
#endif
                break;
     de4:	a7 c0       	rjmp	.+334    	; 0xf34 <GLCD_Printf+0x28a>
                
            case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
                var_num_s32 = va_arg(argp, sint32_t);
     de6:	66 24       	eor	r6, r6
     de8:	77 24       	eor	r7, r7
     dea:	68 94       	set
     dec:	62 f8       	bld	r6, 2
     dee:	6c 0c       	add	r6, r12
     df0:	7d 1c       	adc	r7, r13
     df2:	d6 01       	movw	r26, r12
     df4:	cd 90       	ld	r12, X+
     df6:	dd 90       	ld	r13, X+
     df8:	ed 90       	ld	r14, X+
     dfa:	fc 90       	ld	r15, X
     dfc:	13 97       	sbiw	r26, 0x03	; 3
#if (Enable_GLCD_DisplayDecimalNumber == 1)                
                if(var_num_s32<0)
     dfe:	ff 20       	and	r15, r15
     e00:	5c f4       	brge	.+22     	; 0xe18 <GLCD_Printf+0x16e>
                 { /* If the number is -ve then display the 2's complement along with '-' sign */
                   var_num_s32 = -var_num_s32;
     e02:	f0 94       	com	r15
     e04:	e0 94       	com	r14
     e06:	d0 94       	com	r13
     e08:	c0 94       	com	r12
     e0a:	c1 1c       	adc	r12, r1
     e0c:	d1 1c       	adc	r13, r1
     e0e:	e1 1c       	adc	r14, r1
     e10:	f1 1c       	adc	r15, r1
                   GLCD_DisplayChar('-');
     e12:	8d e2       	ldi	r24, 0x2D	; 45
     e14:	0e 94 c0 04 	call	0x980	; 0x980 <GLCD_DisplayChar>
                 }
                GLCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
     e18:	c7 01       	movw	r24, r14
     e1a:	b6 01       	movw	r22, r12
     e1c:	41 2f       	mov	r20, r17
     e1e:	0e 94 1a 05 	call	0xa34	; 0xa34 <GLCD_DisplayDecimalNumber>
                GLCD_DisplayDecimalNumber(var_num_s16,var_numOfDigitsToDisp_u8);
#endif
                break;
                
            case 'D':    /* Argument type is of integer, hence read 16bit data from the argp */
                var_num_s32 = va_arg(argp, sint32_t);
     e22:	63 01       	movw	r12, r6
                   var_num_s32 = -var_num_s32;
                   GLCD_DisplayChar('-');
                 }
                GLCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
#endif                
                break;    
     e24:	87 c0       	rjmp	.+270    	; 0xf34 <GLCD_Printf+0x28a>

            case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
                var_num_u16 = va_arg(argp, uint16_t);
     e26:	ee 24       	eor	r14, r14
     e28:	ff 24       	eor	r15, r15
     e2a:	68 94       	set
     e2c:	e1 f8       	bld	r14, 1
     e2e:	ec 0c       	add	r14, r12
     e30:	fd 1c       	adc	r15, r13
#if (Enable_GLCD_DisplayDecimalNumber == 1)                
                GLCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
     e32:	f6 01       	movw	r30, r12
     e34:	80 81       	ld	r24, Z
     e36:	91 81       	ldd	r25, Z+1	; 0x01
     e38:	bc 01       	movw	r22, r24
     e3a:	80 e0       	ldi	r24, 0x00	; 0
     e3c:	90 e0       	ldi	r25, 0x00	; 0
     e3e:	41 2f       	mov	r20, r17
     e40:	0e 94 1a 05 	call	0xa34	; 0xa34 <GLCD_DisplayDecimalNumber>
                GLCD_DisplayDecimalNumber(var_num_s32,var_numOfDigitsToDisp_u8);
#endif                
                break;    

            case 'u':    /* Argument type is of unsigned integer, hence read 16bit unsigned data */
                var_num_u16 = va_arg(argp, uint16_t);
     e44:	67 01       	movw	r12, r14
#if (Enable_GLCD_DisplayDecimalNumber == 1)                
                GLCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif                
                break;
     e46:	76 c0       	rjmp	.+236    	; 0xf34 <GLCD_Printf+0x28a>
            
            case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
                var_num_u32 = va_arg(argp, uint32_t);
     e48:	ee 24       	eor	r14, r14
     e4a:	ff 24       	eor	r15, r15
     e4c:	68 94       	set
     e4e:	e2 f8       	bld	r14, 2
     e50:	ec 0c       	add	r14, r12
     e52:	fd 1c       	adc	r15, r13
#if (Enable_GLCD_DisplayDecimalNumber == 1)                
                GLCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
     e54:	d6 01       	movw	r26, r12
     e56:	6d 91       	ld	r22, X+
     e58:	7d 91       	ld	r23, X+
     e5a:	8d 91       	ld	r24, X+
     e5c:	9c 91       	ld	r25, X
     e5e:	41 2f       	mov	r20, r17
     e60:	0e 94 1a 05 	call	0xa34	; 0xa34 <GLCD_DisplayDecimalNumber>
                GLCD_DisplayDecimalNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif                
                break;
            
            case 'U':    /* Argument type is of integer, hence read 32bit unsigend data */
                var_num_u32 = va_arg(argp, uint32_t);
     e64:	67 01       	movw	r12, r14
#if (Enable_GLCD_DisplayDecimalNumber == 1)                
                GLCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
#endif                
                break;            
     e66:	66 c0       	rjmp	.+204    	; 0xf34 <GLCD_Printf+0x28a>

            case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
                var_num_u16 = va_arg(argp, uint16_t);
     e68:	ee 24       	eor	r14, r14
     e6a:	ff 24       	eor	r15, r15
     e6c:	68 94       	set
     e6e:	e1 f8       	bld	r14, 1
     e70:	ec 0c       	add	r14, r12
     e72:	fd 1c       	adc	r15, r13
#if (Enable_GLCD_DisplayHexNumber == 1)                
                GLCD_DisplayHexNumber(var_num_u16,var_numOfDigitsToDisp_u8);
     e74:	f6 01       	movw	r30, r12
     e76:	80 81       	ld	r24, Z
     e78:	91 81       	ldd	r25, Z+1	; 0x01
     e7a:	bc 01       	movw	r22, r24
     e7c:	80 e0       	ldi	r24, 0x00	; 0
     e7e:	90 e0       	ldi	r25, 0x00	; 0
     e80:	41 2f       	mov	r20, r17
     e82:	0e 94 8a 05 	call	0xb14	; 0xb14 <GLCD_DisplayHexNumber>
                GLCD_DisplayDecimalNumber(var_num_u32,var_numOfDigitsToDisp_u8);
#endif                
                break;            

            case 'x':  /* Argument type is of hex, hence hexadecimal data from the argp */
                var_num_u16 = va_arg(argp, uint16_t);
     e86:	67 01       	movw	r12, r14
#if (Enable_GLCD_DisplayHexNumber == 1)                
                GLCD_DisplayHexNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif                
                break;
     e88:	55 c0       	rjmp	.+170    	; 0xf34 <GLCD_Printf+0x28a>

            case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
                var_num_u32 = va_arg(argp, uint32_t);
     e8a:	ee 24       	eor	r14, r14
     e8c:	ff 24       	eor	r15, r15
     e8e:	68 94       	set
     e90:	e2 f8       	bld	r14, 2
     e92:	ec 0c       	add	r14, r12
     e94:	fd 1c       	adc	r15, r13
#if (Enable_GLCD_DisplayHexNumber == 1)                        
                GLCD_DisplayHexNumber(var_num_u32,var_numOfDigitsToDisp_u8);
     e96:	d6 01       	movw	r26, r12
     e98:	6d 91       	ld	r22, X+
     e9a:	7d 91       	ld	r23, X+
     e9c:	8d 91       	ld	r24, X+
     e9e:	9c 91       	ld	r25, X
     ea0:	41 2f       	mov	r20, r17
     ea2:	0e 94 8a 05 	call	0xb14	; 0xb14 <GLCD_DisplayHexNumber>
                GLCD_DisplayHexNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif                
                break;

            case 'X':  /* Argument type is of hex, hence hexadecimal data from the argp */
                var_num_u32 = va_arg(argp, uint32_t);
     ea6:	67 01       	movw	r12, r14
#if (Enable_GLCD_DisplayHexNumber == 1)                        
                GLCD_DisplayHexNumber(var_num_u32,var_numOfDigitsToDisp_u8);
#endif                
                break;
     ea8:	45 c0       	rjmp	.+138    	; 0xf34 <GLCD_Printf+0x28a>

            
            case 'b':  /* Argument type is of binary,Read int and convert to binary */
                var_num_u16 = va_arg(argp, uint16_t);
     eaa:	ee 24       	eor	r14, r14
     eac:	ff 24       	eor	r15, r15
     eae:	68 94       	set
     eb0:	e1 f8       	bld	r14, 1
     eb2:	ec 0c       	add	r14, r12
     eb4:	fd 1c       	adc	r15, r13
     eb6:	f6 01       	movw	r30, r12
     eb8:	80 81       	ld	r24, Z
     eba:	91 81       	ldd	r25, Z+1	; 0x01
#if (Enable_GLCD_DisplayBinaryNumber == 1)                        
                if(var_numOfDigitsToDisp_u8 == C_GlcdMaxDigitsToDisplayUsingPrintf_U8)
     ebc:	1f 3f       	cpi	r17, 0xFF	; 255
     ebe:	09 f4       	brne	.+2      	; 0xec2 <GLCD_Printf+0x218>
                   var_numOfDigitsToDisp_u8 = 16;
     ec0:	15 2d       	mov	r17, r5
                GLCD_DisplayBinaryNumber(var_num_u16,var_numOfDigitsToDisp_u8);
     ec2:	bc 01       	movw	r22, r24
     ec4:	80 e0       	ldi	r24, 0x00	; 0
     ec6:	90 e0       	ldi	r25, 0x00	; 0
     ec8:	41 2f       	mov	r20, r17
     eca:	0e 94 de 05 	call	0xbbc	; 0xbbc <GLCD_DisplayBinaryNumber>
#endif                
                break;

            
            case 'b':  /* Argument type is of binary,Read int and convert to binary */
                var_num_u16 = va_arg(argp, uint16_t);
     ece:	67 01       	movw	r12, r14
#if (Enable_GLCD_DisplayBinaryNumber == 1)                        
                if(var_numOfDigitsToDisp_u8 == C_GlcdMaxDigitsToDisplayUsingPrintf_U8)
                   var_numOfDigitsToDisp_u8 = 16;
                GLCD_DisplayBinaryNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif                
                break;
     ed0:	31 c0       	rjmp	.+98     	; 0xf34 <GLCD_Printf+0x28a>

            case 'B':  /* Argument type is of binary,Read int and convert to binary */
                var_num_u32 = va_arg(argp, uint32_t);
     ed2:	ee 24       	eor	r14, r14
     ed4:	ff 24       	eor	r15, r15
     ed6:	68 94       	set
     ed8:	e2 f8       	bld	r14, 2
     eda:	ec 0c       	add	r14, r12
     edc:	fd 1c       	adc	r15, r13
     ede:	d6 01       	movw	r26, r12
     ee0:	6d 91       	ld	r22, X+
     ee2:	7d 91       	ld	r23, X+
     ee4:	8d 91       	ld	r24, X+
     ee6:	9c 91       	ld	r25, X
     ee8:	13 97       	sbiw	r26, 0x03	; 3
#if (Enable_GLCD_DisplayBinaryNumber == 1)                
                if(var_numOfDigitsToDisp_u8 == C_GlcdMaxDigitsToDisplayUsingPrintf_U8)
     eea:	1f 3f       	cpi	r17, 0xFF	; 255
     eec:	09 f4       	brne	.+2      	; 0xef0 <GLCD_Printf+0x246>
                   var_numOfDigitsToDisp_u8 = 16;                
     eee:	15 2d       	mov	r17, r5
                GLCD_DisplayBinaryNumber(var_num_u32,var_numOfDigitsToDisp_u8);    
     ef0:	41 2f       	mov	r20, r17
     ef2:	0e 94 de 05 	call	0xbbc	; 0xbbc <GLCD_DisplayBinaryNumber>
                GLCD_DisplayBinaryNumber(var_num_u16,var_numOfDigitsToDisp_u8);
#endif                
                break;

            case 'B':  /* Argument type is of binary,Read int and convert to binary */
                var_num_u32 = va_arg(argp, uint32_t);
     ef6:	67 01       	movw	r12, r14
#if (Enable_GLCD_DisplayBinaryNumber == 1)                
                if(var_numOfDigitsToDisp_u8 == C_GlcdMaxDigitsToDisplayUsingPrintf_U8)
                   var_numOfDigitsToDisp_u8 = 16;                
                GLCD_DisplayBinaryNumber(var_num_u32,var_numOfDigitsToDisp_u8);    
#endif                
                break;
     ef8:	1d c0       	rjmp	.+58     	; 0xf34 <GLCD_Printf+0x28a>


            case 'F':
            case 'f': /* Argument type is of float, hence read double data from the argp */
                var_floatNum_f32 = va_arg(argp, double);
     efa:	86 01       	movw	r16, r12
     efc:	0c 5f       	subi	r16, 0xFC	; 252
     efe:	1f 4f       	sbci	r17, 0xFF	; 255
#if (Enable_GLCD_DisplayFloatNumber == 1)                
                GLCD_DisplayFloatNumber(var_floatNum_f32);
     f00:	f6 01       	movw	r30, r12
     f02:	60 81       	ld	r22, Z
     f04:	71 81       	ldd	r23, Z+1	; 0x01
     f06:	82 81       	ldd	r24, Z+2	; 0x02
     f08:	93 81       	ldd	r25, Z+3	; 0x03
     f0a:	0e 94 19 06 	call	0xc32	; 0xc32 <GLCD_DisplayFloatNumber>
                break;


            case 'F':
            case 'f': /* Argument type is of float, hence read double data from the argp */
                var_floatNum_f32 = va_arg(argp, double);
     f0e:	68 01       	movw	r12, r16
#if (Enable_GLCD_DisplayFloatNumber == 1)                
                GLCD_DisplayFloatNumber(var_floatNum_f32);
#endif
                break;
     f10:	11 c0       	rjmp	.+34     	; 0xf34 <GLCD_Printf+0x28a>


            case 'S':
            case 's': /* Argument type is of string, hence get the pointer to sting passed */
                str = va_arg(argp, char *);
     f12:	f6 01       	movw	r30, r12
     f14:	82 e0       	ldi	r24, 0x02	; 2
     f16:	90 e0       	ldi	r25, 0x00	; 0
     f18:	c8 0e       	add	r12, r24
     f1a:	d9 1e       	adc	r13, r25
#if (Enable_GLCD_DisplayString == 1)
                GLCD_DisplayString(str);
     f1c:	80 81       	ld	r24, Z
     f1e:	91 81       	ldd	r25, Z+1	; 0x01
     f20:	0e 94 0b 05 	call	0xa16	; 0xa16 <GLCD_DisplayString>
#endif                
                break;
     f24:	07 c0       	rjmp	.+14     	; 0xf34 <GLCD_Printf+0x28a>

            case '%':
                GLCD_DisplayChar('%');
     f26:	85 e2       	ldi	r24, 0x25	; 37
     f28:	0e 94 c0 04 	call	0x980	; 0x980 <GLCD_DisplayChar>
                break;
     f2c:	03 c0       	rjmp	.+6      	; 0xf34 <GLCD_Printf+0x28a>
            }
        }
        else
        {
            /* As '%' is not detected display/transmit the char passed */
            GLCD_DisplayChar(ch);
     f2e:	0e 94 c0 04 	call	0x980	; 0x980 <GLCD_DisplayChar>
     f32:	58 01       	movw	r10, r16
    uint8_t var_numOfDigitsToDisp_u8;

    va_start(argp, argList);

    /* Loop through the list to extract all the input arguments */
    for(ptr = argList; *ptr != '\0'; ptr++)
     f34:	85 01       	movw	r16, r10
     f36:	0f 5f       	subi	r16, 0xFF	; 255
     f38:	1f 4f       	sbci	r17, 0xFF	; 255
     f3a:	d5 01       	movw	r26, r10
     f3c:	11 96       	adiw	r26, 0x01	; 1
     f3e:	8c 91       	ld	r24, X
     f40:	11 97       	sbiw	r26, 0x01	; 1
     f42:	88 23       	and	r24, r24
     f44:	09 f0       	breq	.+2      	; 0xf48 <GLCD_Printf+0x29e>
     f46:	d8 ce       	rjmp	.-592    	; 0xcf8 <GLCD_Printf+0x4e>
            GLCD_DisplayChar(ch);
        }
    }

    va_end(argp);
}
     f48:	df 91       	pop	r29
     f4a:	cf 91       	pop	r28
     f4c:	1f 91       	pop	r17
     f4e:	0f 91       	pop	r16
     f50:	ff 90       	pop	r15
     f52:	ef 90       	pop	r14
     f54:	df 90       	pop	r13
     f56:	cf 90       	pop	r12
     f58:	bf 90       	pop	r11
     f5a:	af 90       	pop	r10
     f5c:	9f 90       	pop	r9
     f5e:	8f 90       	pop	r8
     f60:	7f 90       	pop	r7
     f62:	6f 90       	pop	r6
     f64:	5f 90       	pop	r5
     f66:	08 95       	ret

00000f68 <GLCD_DisplayBitmap>:
 *							if cursor position reached to end of page0, change page to page1
 *							write last half 64 byte data from deposit_msg, n-th line
 *							increase cursor position
 * Example Call:	GLCD_DisplayBitmap(9)
 */
void GLCD_DisplayBitmap(int msg) { // msg = 0-9 or DEPOSIT(-1)
     f68:	6f 92       	push	r6
     f6a:	7f 92       	push	r7
     f6c:	8f 92       	push	r8
     f6e:	9f 92       	push	r9
     f70:	bf 92       	push	r11
     f72:	cf 92       	push	r12
     f74:	df 92       	push	r13
     f76:	ef 92       	push	r14
     f78:	ff 92       	push	r15
     f7a:	0f 93       	push	r16
     f7c:	1f 93       	push	r17
     f7e:	cf 93       	push	r28
     f80:	df 93       	push	r29
    uint8_t line, cursor, padding, width;
	width = 42;  // width of the numbers stored in big_digits bit map are 32 pixels
	padding = (128 - width) / 2; // padding is used to align the number center in the GLCD
	
	if (msg != -1) { // if digits
     f82:	2f ef       	ldi	r18, 0xFF	; 255
     f84:	8f 3f       	cpi	r24, 0xFF	; 255
     f86:	92 07       	cpc	r25, r18
     f88:	09 f4       	brne	.+2      	; 0xf8c <GLCD_DisplayBitmap+0x24>
     f8a:	4f c0       	rjmp	.+158    	; 0x102a <GLCD_DisplayBitmap+0xc2>
     f8c:	88 24       	eor	r8, r8
     f8e:	99 24       	eor	r9, r9
     f90:	bb 24       	eor	r11, r11
			GLCD_GoToLine(line); // selects the current line

			// skip padding value by writing null bytes
			for (int k=0; k<padding; k++) {
				glcd_DataWrite(0x00);
				GLCD.CursorPos++;
     f92:	03 ef       	ldi	r16, 0xF3	; 243
     f94:	13 e1       	ldi	r17, 0x13	; 19
 *							if cursor position reached to end of page0, change page to page1
 *							write last half 64 byte data from deposit_msg, n-th line
 *							increase cursor position
 * Example Call:	GLCD_DisplayBitmap(9)
 */
void GLCD_DisplayBitmap(int msg) { // msg = 0-9 or DEPOSIT(-1)
     f96:	20 e5       	ldi	r18, 0x50	; 80
     f98:	31 e0       	ldi	r19, 0x01	; 1
     f9a:	82 9f       	mul	r24, r18
     f9c:	30 01       	movw	r6, r0
     f9e:	83 9f       	mul	r24, r19
     fa0:	70 0c       	add	r7, r0
     fa2:	92 9f       	mul	r25, r18
     fa4:	70 0c       	add	r7, r0
     fa6:	11 24       	eor	r1, r1
			}
			
			// writing the number after padding value
			for(cursor=0; cursor<width; cursor++) {
				// change page to page 1 if cursor position reached to the end of page 0
				if((GLCD.PageNum == 0x00) && (GLCD.CursorPos==0x80)) {
     fa8:	0f 2e       	mov	r0, r31
     faa:	f1 ef       	ldi	r31, 0xF1	; 241
     fac:	cf 2e       	mov	r12, r31
     fae:	f3 e1       	ldi	r31, 0x13	; 19
     fb0:	df 2e       	mov	r13, r31
     fb2:	f0 2d       	mov	r31, r0
	width = 42;  // width of the numbers stored in big_digits bit map are 32 pixels
	padding = (128 - width) / 2; // padding is used to align the number center in the GLCD
	
	if (msg != -1) { // if digits
		for(line=0; line<8; line++) {  // iterating through 8 lines
			GLCD_GoToLine(line); // selects the current line
     fb4:	8b 2d       	mov	r24, r11
     fb6:	0e 94 54 04 	call	0x8a8	; 0x8a8 <GLCD_GoToLine>
     fba:	cb e2       	ldi	r28, 0x2B	; 43
     fbc:	d0 e0       	ldi	r29, 0x00	; 0

			// skip padding value by writing null bytes
			for (int k=0; k<padding; k++) {
				glcd_DataWrite(0x00);
     fbe:	80 e0       	ldi	r24, 0x00	; 0
     fc0:	0e 94 85 02 	call	0x50a	; 0x50a <glcd_DataWrite>
				GLCD.CursorPos++;
     fc4:	f8 01       	movw	r30, r16
     fc6:	80 81       	ld	r24, Z
     fc8:	8f 5f       	subi	r24, 0xFF	; 255
     fca:	80 83       	st	Z, r24
     fcc:	21 97       	sbiw	r28, 0x01	; 1
	if (msg != -1) { // if digits
		for(line=0; line<8; line++) {  // iterating through 8 lines
			GLCD_GoToLine(line); // selects the current line

			// skip padding value by writing null bytes
			for (int k=0; k<padding; k++) {
     fce:	b9 f7       	brne	.-18     	; 0xfbe <GLCD_DisplayBitmap+0x56>
 *							if cursor position reached to end of page0, change page to page1
 *							write last half 64 byte data from deposit_msg, n-th line
 *							increase cursor position
 * Example Call:	GLCD_DisplayBitmap(9)
 */
void GLCD_DisplayBitmap(int msg) { // msg = 0-9 or DEPOSIT(-1)
     fd0:	c3 01       	movw	r24, r6
     fd2:	88 0d       	add	r24, r8
     fd4:	99 1d       	adc	r25, r9
     fd6:	0f 2e       	mov	r0, r31
     fd8:	fe e4       	ldi	r31, 0x4E	; 78
     fda:	ef 2e       	mov	r14, r31
     fdc:	f6 e0       	ldi	r31, 0x06	; 6
     fde:	ff 2e       	mov	r15, r31
     fe0:	f0 2d       	mov	r31, r0
     fe2:	e8 0e       	add	r14, r24
     fe4:	f9 1e       	adc	r15, r25
     fe6:	ca e2       	ldi	r28, 0x2A	; 42
			}
			
			// writing the number after padding value
			for(cursor=0; cursor<width; cursor++) {
				// change page to page 1 if cursor position reached to the end of page 0
				if((GLCD.PageNum == 0x00) && (GLCD.CursorPos==0x80)) {
     fe8:	f6 01       	movw	r30, r12
     fea:	80 81       	ld	r24, Z
     fec:	88 23       	and	r24, r24
     fee:	39 f4       	brne	.+14     	; 0xffe <GLCD_DisplayBitmap+0x96>
     ff0:	f8 01       	movw	r30, r16
     ff2:	80 81       	ld	r24, Z
     ff4:	80 38       	cpi	r24, 0x80	; 128
     ff6:	19 f4       	brne	.+6      	; 0xffe <GLCD_DisplayBitmap+0x96>
					GLCD_GoToPage(1);
     ff8:	81 e0       	ldi	r24, 0x01	; 1
     ffa:	0e 94 3a 04 	call	0x874	; 0x874 <GLCD_GoToPage>
				}
				
				// write byte to the GLCD and increase cusror position
				glcd_DataWrite(big_digits[msg][(width*line)+cursor]);
     ffe:	f7 01       	movw	r30, r14
    1000:	81 91       	ld	r24, Z+
    1002:	7f 01       	movw	r14, r30
    1004:	0e 94 85 02 	call	0x50a	; 0x50a <glcd_DataWrite>
				GLCD.CursorPos++;
    1008:	f8 01       	movw	r30, r16
    100a:	80 81       	ld	r24, Z
    100c:	8f 5f       	subi	r24, 0xFF	; 255
    100e:	80 83       	st	Z, r24
    1010:	c1 50       	subi	r28, 0x01	; 1
				glcd_DataWrite(0x00);
				GLCD.CursorPos++;
			}
			
			// writing the number after padding value
			for(cursor=0; cursor<width; cursor++) {
    1012:	51 f7       	brne	.-44     	; 0xfe8 <GLCD_DisplayBitmap+0x80>
				glcd_DataWrite(big_digits[msg][(width*line)+cursor]);
				GLCD.CursorPos++;
			}
			
			// skip cursor position by adding padding to it
			GLCD.CursorPos += padding;
    1014:	85 5d       	subi	r24, 0xD5	; 213
    1016:	80 83       	st	Z, r24
    uint8_t line, cursor, padding, width;
	width = 42;  // width of the numbers stored in big_digits bit map are 32 pixels
	padding = (128 - width) / 2; // padding is used to align the number center in the GLCD
	
	if (msg != -1) { // if digits
		for(line=0; line<8; line++) {  // iterating through 8 lines
    1018:	b3 94       	inc	r11
    101a:	8a e2       	ldi	r24, 0x2A	; 42
    101c:	90 e0       	ldi	r25, 0x00	; 0
    101e:	88 0e       	add	r8, r24
    1020:	99 1e       	adc	r9, r25
    1022:	98 e0       	ldi	r25, 0x08	; 8
    1024:	b9 16       	cp	r11, r25
    1026:	31 f6       	brne	.-116    	; 0xfb4 <GLCD_DisplayBitmap+0x4c>
    1028:	38 c0       	rjmp	.+112    	; 0x109a <GLCD_DisplayBitmap+0x132>
void GLCD_DisplayBitmap(int msg) { // msg = 0-9 or DEPOSIT(-1)
    uint8_t line, cursor, padding, width;
	width = 42;  // width of the numbers stored in big_digits bit map are 32 pixels
	padding = (128 - width) / 2; // padding is used to align the number center in the GLCD
	
	if (msg != -1) { // if digits
    102a:	88 24       	eor	r8, r8
    102c:	99 24       	eor	r9, r9
    102e:	d2 e0       	ldi	r29, 0x02	; 2
 *							if cursor position reached to end of page0, change page to page1
 *							write last half 64 byte data from deposit_msg, n-th line
 *							increase cursor position
 * Example Call:	GLCD_DisplayBitmap(9)
 */
void GLCD_DisplayBitmap(int msg) { // msg = 0-9 or DEPOSIT(-1)
    1030:	0f 2e       	mov	r0, r31
    1032:	f0 e8       	ldi	r31, 0x80	; 128
    1034:	bf 2e       	mov	r11, r31
    1036:	f0 2d       	mov	r31, r0
		for(line=2; line<6; line++) {
			GLCD_GoToLine(line); // selects the current line
			
			for(cursor=0; cursor<width; cursor++) {
				// change page to page 1 if cursor position reached to the end of page 0
				if((GLCD.PageNum == 0x00) && (GLCD.CursorPos==0x80)) {
    1038:	0f 2e       	mov	r0, r31
    103a:	f1 ef       	ldi	r31, 0xF1	; 241
    103c:	cf 2e       	mov	r12, r31
    103e:	f3 e1       	ldi	r31, 0x13	; 19
    1040:	df 2e       	mov	r13, r31
    1042:	f0 2d       	mov	r31, r0
    1044:	03 ef       	ldi	r16, 0xF3	; 243
    1046:	13 e1       	ldi	r17, 0x13	; 19
	} else { // if DEPOSIT message
		width = 128; // width of the DEPOSIT message stored in deposit_msg bit map is 128 pixels
		
		// iterating through 4 lines skipping line 0, 1, 6, and 7
		for(line=2; line<6; line++) {
			GLCD_GoToLine(line); // selects the current line
    1048:	8d 2f       	mov	r24, r29
    104a:	0e 94 54 04 	call	0x8a8	; 0x8a8 <GLCD_GoToLine>
 *							if cursor position reached to end of page0, change page to page1
 *							write last half 64 byte data from deposit_msg, n-th line
 *							increase cursor position
 * Example Call:	GLCD_DisplayBitmap(9)
 */
void GLCD_DisplayBitmap(int msg) { // msg = 0-9 or DEPOSIT(-1)
    104e:	0f 2e       	mov	r0, r31
    1050:	fe e4       	ldi	r31, 0x4E	; 78
    1052:	ef 2e       	mov	r14, r31
    1054:	f4 e0       	ldi	r31, 0x04	; 4
    1056:	ff 2e       	mov	r15, r31
    1058:	f0 2d       	mov	r31, r0
    105a:	e8 0c       	add	r14, r8
    105c:	f9 1c       	adc	r15, r9
    105e:	cb 2d       	mov	r28, r11
		for(line=2; line<6; line++) {
			GLCD_GoToLine(line); // selects the current line
			
			for(cursor=0; cursor<width; cursor++) {
				// change page to page 1 if cursor position reached to the end of page 0
				if((GLCD.PageNum == 0x00) && (GLCD.CursorPos==0x80)) {
    1060:	f6 01       	movw	r30, r12
    1062:	80 81       	ld	r24, Z
    1064:	88 23       	and	r24, r24
    1066:	39 f4       	brne	.+14     	; 0x1076 <GLCD_DisplayBitmap+0x10e>
    1068:	f8 01       	movw	r30, r16
    106a:	80 81       	ld	r24, Z
    106c:	80 38       	cpi	r24, 0x80	; 128
    106e:	19 f4       	brne	.+6      	; 0x1076 <GLCD_DisplayBitmap+0x10e>
					GLCD_GoToPage(1);
    1070:	81 e0       	ldi	r24, 0x01	; 1
    1072:	0e 94 3a 04 	call	0x874	; 0x874 <GLCD_GoToPage>
				}
				
				// write byte to the GLCD and increase cusror position
				glcd_DataWrite(deposit_msg[(width*(line-2))+cursor]);
    1076:	f7 01       	movw	r30, r14
    1078:	81 91       	ld	r24, Z+
    107a:	7f 01       	movw	r14, r30
    107c:	0e 94 85 02 	call	0x50a	; 0x50a <glcd_DataWrite>
				GLCD.CursorPos++;
    1080:	f8 01       	movw	r30, r16
    1082:	80 81       	ld	r24, Z
    1084:	8f 5f       	subi	r24, 0xFF	; 255
    1086:	80 83       	st	Z, r24
    1088:	c1 50       	subi	r28, 0x01	; 1
		
		// iterating through 4 lines skipping line 0, 1, 6, and 7
		for(line=2; line<6; line++) {
			GLCD_GoToLine(line); // selects the current line
			
			for(cursor=0; cursor<width; cursor++) {
    108a:	51 f7       	brne	.-44     	; 0x1060 <GLCD_DisplayBitmap+0xf8>
		}
	} else { // if DEPOSIT message
		width = 128; // width of the DEPOSIT message stored in deposit_msg bit map is 128 pixels
		
		// iterating through 4 lines skipping line 0, 1, 6, and 7
		for(line=2; line<6; line++) {
    108c:	df 5f       	subi	r29, 0xFF	; 255
    108e:	80 e8       	ldi	r24, 0x80	; 128
    1090:	90 e0       	ldi	r25, 0x00	; 0
    1092:	88 0e       	add	r8, r24
    1094:	99 1e       	adc	r9, r25
    1096:	d6 30       	cpi	r29, 0x06	; 6
    1098:	b9 f6       	brne	.-82     	; 0x1048 <GLCD_DisplayBitmap+0xe0>
				GLCD.CursorPos++;
			}			
		}
	}

    GLCD_GoToLine(0);
    109a:	80 e0       	ldi	r24, 0x00	; 0
    109c:	0e 94 54 04 	call	0x8a8	; 0x8a8 <GLCD_GoToLine>
    10a0:	df 91       	pop	r29
    10a2:	cf 91       	pop	r28
    10a4:	1f 91       	pop	r17
    10a6:	0f 91       	pop	r16
    10a8:	ff 90       	pop	r15
    10aa:	ef 90       	pop	r14
    10ac:	df 90       	pop	r13
    10ae:	cf 90       	pop	r12
    10b0:	bf 90       	pop	r11
    10b2:	9f 90       	pop	r9
    10b4:	8f 90       	pop	r8
    10b6:	7f 90       	pop	r7
    10b8:	6f 90       	pop	r6
    10ba:	08 95       	ret

000010bc <lcd_port_config>:
char input_str[100] = ""; // stores the raw input string

//Function to configure LCD port
void lcd_port_config (void)
{
	DDRC = DDRC | 0xF7; //all the LCD pin's direction set as output
    10bc:	87 b1       	in	r24, 0x07	; 7
    10be:	87 6f       	ori	r24, 0xF7	; 247
    10c0:	87 b9       	out	0x07, r24	; 7
	PORTC = PORTC & 0x80; // all the LCD pins are set to logic 0 except PORTC 7
    10c2:	88 b1       	in	r24, 0x08	; 8
    10c4:	80 78       	andi	r24, 0x80	; 128
    10c6:	88 b9       	out	0x08, r24	; 8
}
    10c8:	08 95       	ret

000010ca <adc_pin_config>:

//ADC pin configuration
void adc_pin_config (void)
{
	DDRF = 0x00;
    10ca:	10 ba       	out	0x10, r1	; 16
	PORTF = 0x00;
    10cc:	11 ba       	out	0x11, r1	; 17
	DDRK = 0x00;
    10ce:	10 92 07 01 	sts	0x0107, r1
	PORTK = 0x00;
    10d2:	10 92 08 01 	sts	0x0108, r1
}
    10d6:	08 95       	ret

000010d8 <motion_pin_config>:

//Function to configure ports to enable robot's motion
void motion_pin_config (void) 
{
	DDRA = DDRA | 0x0F;
    10d8:	81 b1       	in	r24, 0x01	; 1
    10da:	8f 60       	ori	r24, 0x0F	; 15
    10dc:	81 b9       	out	0x01, r24	; 1
	PORTA = PORTA & 0xF0;
    10de:	82 b1       	in	r24, 0x02	; 2
    10e0:	80 7f       	andi	r24, 0xF0	; 240
    10e2:	82 b9       	out	0x02, r24	; 2
	DDRL = DDRL | 0x18;   //Setting PL3 and PL4 pins as output for PWM generation
    10e4:	ea e0       	ldi	r30, 0x0A	; 10
    10e6:	f1 e0       	ldi	r31, 0x01	; 1
    10e8:	80 81       	ld	r24, Z
    10ea:	88 61       	ori	r24, 0x18	; 24
    10ec:	80 83       	st	Z, r24
	PORTL = PORTL | 0x18; //PL3 and PL4 pins are for velocity control using PWM.
    10ee:	eb e0       	ldi	r30, 0x0B	; 11
    10f0:	f1 e0       	ldi	r31, 0x01	; 1
    10f2:	80 81       	ld	r24, Z
    10f4:	88 61       	ori	r24, 0x18	; 24
    10f6:	80 83       	st	Z, r24
}
    10f8:	08 95       	ret

000010fa <left_encoder_pin_config>:


//Function to configure INT4 (PORTE 4) pin as input for the left position encoder
void left_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xEF;  //Set the direction of the PORTE 4 pin as input
    10fa:	6c 98       	cbi	0x0d, 4	; 13
	PORTE = PORTE | 0x10; //Enable internal pull-up for PORTE 4 pin
    10fc:	74 9a       	sbi	0x0e, 4	; 14
}
    10fe:	08 95       	ret

00001100 <right_encoder_pin_config>:

//Function to configure INT5 (PORTE 5) pin as input for the right position encoder
void right_encoder_pin_config (void)
{
	DDRE  = DDRE & 0xDF;  //Set the direction of the PORTE 4 pin as input
    1100:	6d 98       	cbi	0x0d, 5	; 13
	PORTE = PORTE | 0x20; //Enable internal pull-up for PORTE 4 pin
    1102:	75 9a       	sbi	0x0e, 5	; 14
}
    1104:	08 95       	ret

00001106 <buzzer_pin_config>:

//Function to initialize Buzzer
void buzzer_pin_config (void)
{
	DDRC = DDRC | 0x08;		//Setting PORTC 3 as output
    1106:	3b 9a       	sbi	0x07, 3	; 7
	PORTC = PORTC & 0xF7;		//Setting PORTC 3 logic low to turnoff buzzer
    1108:	43 98       	cbi	0x08, 3	; 8
}
    110a:	08 95       	ret

0000110c <interrupt_switch_config>:

//Function to configure Interrupt switch
void interrupt_switch_config (void)
{
	DDRE = DDRE & 0x7F;  //PORTE 7 pin set as input
    110c:	6f 98       	cbi	0x0d, 7	; 13
	PORTE = PORTE | 0x80; //PORTE7 internal pull-up enabled
    110e:	77 9a       	sbi	0x0e, 7	; 14
}
    1110:	08 95       	ret

00001112 <LED_pin_config>:

//Function to configure LED port i.e. pg0 and pg1 for left and right LEDs respectively
void LED_pin_config (void) {
	DDRG |= 0b00000011; // all the LED pin's direction set as output
    1112:	83 b3       	in	r24, 0x13	; 19
    1114:	83 60       	ori	r24, 0x03	; 3
    1116:	83 bb       	out	0x13, r24	; 19
	PORTG &= 0b11111100; // all the LED pins are set to logic 0
    1118:	84 b3       	in	r24, 0x14	; 20
    111a:	8c 7f       	andi	r24, 0xFC	; 252
    111c:	84 bb       	out	0x14, r24	; 20
}
    111e:	08 95       	ret

00001120 <port_init>:

//Function to Initialize PORTS
void port_init()
{
	lcd_port_config();
    1120:	0e 94 5e 08 	call	0x10bc	; 0x10bc <lcd_port_config>
	adc_pin_config();
    1124:	0e 94 65 08 	call	0x10ca	; 0x10ca <adc_pin_config>
	motion_pin_config();	
    1128:	0e 94 6c 08 	call	0x10d8	; 0x10d8 <motion_pin_config>
	left_encoder_pin_config(); //left encoder pin config
    112c:	0e 94 7d 08 	call	0x10fa	; 0x10fa <left_encoder_pin_config>
	right_encoder_pin_config(); //right encoder pin config
    1130:	0e 94 80 08 	call	0x1100	; 0x1100 <right_encoder_pin_config>
	buzzer_pin_config();
    1134:	0e 94 83 08 	call	0x1106	; 0x1106 <buzzer_pin_config>
	LED_pin_config();
    1138:	0e 94 89 08 	call	0x1112	; 0x1112 <LED_pin_config>
	interrupt_switch_config();
    113c:	0e 94 86 08 	call	0x110c	; 0x110c <interrupt_switch_config>
}
    1140:	08 95       	ret

00001142 <left_position_encoder_interrupt_init>:

void left_position_encoder_interrupt_init (void) //Interrupt 4 enable
{
	cli(); //Clears the global interrupt
    1142:	f8 94       	cli
	EICRB = EICRB | 0x02; // INT4 is set to trigger with falling edge
    1144:	ea e6       	ldi	r30, 0x6A	; 106
    1146:	f0 e0       	ldi	r31, 0x00	; 0
    1148:	80 81       	ld	r24, Z
    114a:	82 60       	ori	r24, 0x02	; 2
    114c:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x10; // Enable Interrupt INT4 for left position encoder
    114e:	ec 9a       	sbi	0x1d, 4	; 29
	sei();   // Enables the global interrupt
    1150:	78 94       	sei
}
    1152:	08 95       	ret

00001154 <right_position_encoder_interrupt_init>:

void right_position_encoder_interrupt_init (void) //Interrupt 5 enable
{
	cli(); //Clears the global interrupt
    1154:	f8 94       	cli
	EICRB = EICRB | 0x08; // INT5 is set to trigger with falling edge
    1156:	ea e6       	ldi	r30, 0x6A	; 106
    1158:	f0 e0       	ldi	r31, 0x00	; 0
    115a:	80 81       	ld	r24, Z
    115c:	88 60       	ori	r24, 0x08	; 8
    115e:	80 83       	st	Z, r24
	EIMSK = EIMSK | 0x20; // Enable Interrupt INT5 for right position encoder
    1160:	ed 9a       	sbi	0x1d, 5	; 29
	sei();   // Enables the global interrupt
    1162:	78 94       	sei
}
    1164:	08 95       	ret

00001166 <buzzer_on>:


void buzzer_on (void)
{
	unsigned char port_restore = 0;
	port_restore = PINC;
    1166:	86 b1       	in	r24, 0x06	; 6
	port_restore = port_restore | 0x08;
    1168:	88 60       	ori	r24, 0x08	; 8
	PORTC = port_restore;
    116a:	88 b9       	out	0x08, r24	; 8
}
    116c:	08 95       	ret

0000116e <buzzer_off>:

void buzzer_off (void)
{
	unsigned char port_restore = 0;
	port_restore = PINC;
    116e:	86 b1       	in	r24, 0x06	; 6
	port_restore = port_restore & 0xF7;
    1170:	87 7f       	andi	r24, 0xF7	; 247
	PORTC = port_restore;
    1172:	88 b9       	out	0x08, r24	; 8
}
    1174:	08 95       	ret

00001176 <__vector_6>:


//ISR for right position encoder
ISR(INT5_vect)
{
    1176:	1f 92       	push	r1
    1178:	0f 92       	push	r0
    117a:	0f b6       	in	r0, 0x3f	; 63
    117c:	0f 92       	push	r0
    117e:	11 24       	eor	r1, r1
    1180:	8f 93       	push	r24
    1182:	9f 93       	push	r25
    1184:	af 93       	push	r26
    1186:	bf 93       	push	r27
	ShaftCountRight++;  //increment right shaft position count
    1188:	80 91 d9 13 	lds	r24, 0x13D9
    118c:	90 91 da 13 	lds	r25, 0x13DA
    1190:	a0 91 db 13 	lds	r26, 0x13DB
    1194:	b0 91 dc 13 	lds	r27, 0x13DC
    1198:	01 96       	adiw	r24, 0x01	; 1
    119a:	a1 1d       	adc	r26, r1
    119c:	b1 1d       	adc	r27, r1
    119e:	80 93 d9 13 	sts	0x13D9, r24
    11a2:	90 93 da 13 	sts	0x13DA, r25
    11a6:	a0 93 db 13 	sts	0x13DB, r26
    11aa:	b0 93 dc 13 	sts	0x13DC, r27
}
    11ae:	bf 91       	pop	r27
    11b0:	af 91       	pop	r26
    11b2:	9f 91       	pop	r25
    11b4:	8f 91       	pop	r24
    11b6:	0f 90       	pop	r0
    11b8:	0f be       	out	0x3f, r0	; 63
    11ba:	0f 90       	pop	r0
    11bc:	1f 90       	pop	r1
    11be:	18 95       	reti

000011c0 <__vector_5>:


//ISR for left position encoder
ISR(INT4_vect)
{
    11c0:	1f 92       	push	r1
    11c2:	0f 92       	push	r0
    11c4:	0f b6       	in	r0, 0x3f	; 63
    11c6:	0f 92       	push	r0
    11c8:	11 24       	eor	r1, r1
    11ca:	8f 93       	push	r24
    11cc:	9f 93       	push	r25
    11ce:	af 93       	push	r26
    11d0:	bf 93       	push	r27
	ShaftCountLeft++;  //increment left shaft position count
    11d2:	80 91 dd 13 	lds	r24, 0x13DD
    11d6:	90 91 de 13 	lds	r25, 0x13DE
    11da:	a0 91 df 13 	lds	r26, 0x13DF
    11de:	b0 91 e0 13 	lds	r27, 0x13E0
    11e2:	01 96       	adiw	r24, 0x01	; 1
    11e4:	a1 1d       	adc	r26, r1
    11e6:	b1 1d       	adc	r27, r1
    11e8:	80 93 dd 13 	sts	0x13DD, r24
    11ec:	90 93 de 13 	sts	0x13DE, r25
    11f0:	a0 93 df 13 	sts	0x13DF, r26
    11f4:	b0 93 e0 13 	sts	0x13E0, r27
}
    11f8:	bf 91       	pop	r27
    11fa:	af 91       	pop	r26
    11fc:	9f 91       	pop	r25
    11fe:	8f 91       	pop	r24
    1200:	0f 90       	pop	r0
    1202:	0f be       	out	0x3f, r0	; 63
    1204:	0f 90       	pop	r0
    1206:	1f 90       	pop	r1
    1208:	18 95       	reti

0000120a <timer5_init>:
// Prescale:256
// PWM 8bit fast, TOP=0x00FF
// Timer Frequency:225.000Hz
void timer5_init()
{
	TCCR5B = 0x00;	//Stop
    120a:	e1 e2       	ldi	r30, 0x21	; 33
    120c:	f1 e0       	ldi	r31, 0x01	; 1
    120e:	10 82       	st	Z, r1
	TCNT5H = 0xFF;	//Counter higher 8-bit value to which OCR5xH value is compared with
    1210:	8f ef       	ldi	r24, 0xFF	; 255
    1212:	80 93 25 01 	sts	0x0125, r24
	TCNT5L = 0x01;	//Counter lower 8-bit value to which OCR5xH value is compared with
    1216:	91 e0       	ldi	r25, 0x01	; 1
    1218:	90 93 24 01 	sts	0x0124, r25
	OCR5AH = 0x00;	//Output compare register high value for Left Motor
    121c:	10 92 29 01 	sts	0x0129, r1
	OCR5AL = 0xFF;	//Output compare register low value for Left Motor
    1220:	80 93 28 01 	sts	0x0128, r24
	OCR5BH = 0x00;	//Output compare register high value for Right Motor
    1224:	10 92 2b 01 	sts	0x012B, r1
	OCR5BL = 0xFF;	//Output compare register low value for Right Motor
    1228:	80 93 2a 01 	sts	0x012A, r24
	OCR5CH = 0x00;	//Output compare register high value for Motor C1
    122c:	10 92 2d 01 	sts	0x012D, r1
	OCR5CL = 0xFF;	//Output compare register low value for Motor C1
    1230:	80 93 2c 01 	sts	0x012C, r24
	TCCR5A = 0xA9;	/*{COM5A1=1, COM5A0=0; COM5B1=1, COM5B0=0; COM5C1=1 COM5C0=0}
    1234:	89 ea       	ldi	r24, 0xA9	; 169
    1236:	80 93 20 01 	sts	0x0120, r24
 					  For Overriding normal port functionality to OCRnA outputs.
				  	  {WGM51=0, WGM50=1} Along With WGM52 in TCCR5B for Selecting FAST PWM 8-bit Mode*/
	
	TCCR5B = 0x0B;	//WGM12=1; CS12=0, CS11=1, CS10=1 (Prescaler=64)
    123a:	8b e0       	ldi	r24, 0x0B	; 11
    123c:	80 83       	st	Z, r24
}
    123e:	08 95       	ret

00001240 <adc_init>:

void adc_init()
{
	ADCSRA = 0x00;
    1240:	ea e7       	ldi	r30, 0x7A	; 122
    1242:	f0 e0       	ldi	r31, 0x00	; 0
    1244:	10 82       	st	Z, r1
	ADCSRB = 0x00;		//MUX5 = 0
    1246:	10 92 7b 00 	sts	0x007B, r1
	ADMUX = 0x20;		//Vref=5V external --- ADLAR=1 --- MUX4:0 = 0000
    124a:	80 e2       	ldi	r24, 0x20	; 32
    124c:	80 93 7c 00 	sts	0x007C, r24
	ACSR = 0x80;
    1250:	80 e8       	ldi	r24, 0x80	; 128
    1252:	80 bf       	out	0x30, r24	; 48
	ADCSRA = 0x86;		//ADEN=1 --- ADIE=1 --- ADPS2:0 = 1 1 0
    1254:	86 e8       	ldi	r24, 0x86	; 134
    1256:	80 83       	st	Z, r24
}
    1258:	08 95       	ret

0000125a <ADC_Conversion>:

//Function For ADC Conversion
unsigned char ADC_Conversion(unsigned char Ch) 
{
	unsigned char a;
	if(Ch>7)
    125a:	88 30       	cpi	r24, 0x08	; 8
    125c:	18 f0       	brcs	.+6      	; 0x1264 <ADC_Conversion+0xa>
	{
		ADCSRB = 0x08;
    125e:	98 e0       	ldi	r25, 0x08	; 8
    1260:	90 93 7b 00 	sts	0x007B, r25
	}
	Ch = Ch & 0x07;  			
    1264:	87 70       	andi	r24, 0x07	; 7
	ADMUX= 0x20| Ch;	   		
    1266:	80 62       	ori	r24, 0x20	; 32
    1268:	80 93 7c 00 	sts	0x007C, r24
	ADCSRA = ADCSRA | 0x40;		//Set start conversion bit
    126c:	ea e7       	ldi	r30, 0x7A	; 122
    126e:	f0 e0       	ldi	r31, 0x00	; 0
    1270:	80 81       	ld	r24, Z
    1272:	80 64       	ori	r24, 0x40	; 64
    1274:	80 83       	st	Z, r24
	while((ADCSRA&0x10)==0);	//Wait for conversion to complete
    1276:	80 81       	ld	r24, Z
    1278:	84 ff       	sbrs	r24, 4
    127a:	fd cf       	rjmp	.-6      	; 0x1276 <ADC_Conversion+0x1c>
	a=ADCH;
    127c:	80 91 79 00 	lds	r24, 0x0079
	ADCSRA = ADCSRA|0x10; //clear ADIF (ADC Interrupt Flag) by writing 1 to it
    1280:	ea e7       	ldi	r30, 0x7A	; 122
    1282:	f0 e0       	ldi	r31, 0x00	; 0
    1284:	90 81       	ld	r25, Z
    1286:	90 61       	ori	r25, 0x10	; 16
    1288:	90 83       	st	Z, r25
	ADCSRB = 0x00;
    128a:	10 92 7b 00 	sts	0x007B, r1
	return a;
}
    128e:	08 95       	ret

00001290 <print_sensor>:

//Function To Print Sensor Values At Desired Row And Column Location on LCD
void print_sensor(char row, char coloumn,unsigned char channel)
{
    1290:	cf 93       	push	r28
    1292:	df 93       	push	r29
    1294:	d8 2f       	mov	r29, r24
    1296:	c6 2f       	mov	r28, r22
    1298:	84 2f       	mov	r24, r20
	ADC_Value = ADC_Conversion(channel);
    129a:	0e 94 2d 09 	call	0x125a	; 0x125a <ADC_Conversion>
    129e:	48 2f       	mov	r20, r24
    12a0:	80 93 f5 13 	sts	0x13F5, r24
	lcd_print(row, coloumn, ADC_Value, 3);
    12a4:	8d 2f       	mov	r24, r29
    12a6:	6c 2f       	mov	r22, r28
    12a8:	50 e0       	ldi	r21, 0x00	; 0
    12aa:	23 e0       	ldi	r18, 0x03	; 3
    12ac:	30 e0       	ldi	r19, 0x00	; 0
    12ae:	0e 94 7a 03 	call	0x6f4	; 0x6f4 <lcd_print>
}
    12b2:	df 91       	pop	r29
    12b4:	cf 91       	pop	r28
    12b6:	08 95       	ret

000012b8 <velocity>:

//Function for velocity control
void velocity (unsigned char left_motor, unsigned char right_motor)
{
	OCR5AL = (unsigned char)left_motor;
    12b8:	80 93 28 01 	sts	0x0128, r24
	OCR5BL = (unsigned char)right_motor;
    12bc:	60 93 2a 01 	sts	0x012A, r22
}
    12c0:	08 95       	ret

000012c2 <motion_set>:
void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 		// removing upper nibbel for the protection
	PortARestore = PORTA; 		// reading the PORTA original status
    12c2:	92 b1       	in	r25, 0x02	; 2
	PortARestore &= 0xF0; 		// making lower direction nibbel to 0
    12c4:	90 7f       	andi	r25, 0xF0	; 240
//Function used for setting motor's direction
void motion_set (unsigned char Direction)
{
	unsigned char PortARestore = 0;

	Direction &= 0x0F; 		// removing upper nibbel for the protection
    12c6:	8f 70       	andi	r24, 0x0F	; 15
	PortARestore = PORTA; 		// reading the PORTA original status
	PortARestore &= 0xF0; 		// making lower direction nibbel to 0
	PortARestore |= Direction; // adding lower nibbel for forward command and restoring the PORTA status
    12c8:	98 2b       	or	r25, r24
	PORTA = PortARestore; 		// executing the command
    12ca:	92 b9       	out	0x02, r25	; 2
}
    12cc:	08 95       	ret

000012ce <forward>:

void forward (void) //both wheels forward
{
	motion_set(0x06);
    12ce:	86 e0       	ldi	r24, 0x06	; 6
    12d0:	0e 94 61 09 	call	0x12c2	; 0x12c2 <motion_set>
}
    12d4:	08 95       	ret

000012d6 <back>:

void back (void) //both wheels backward
{
	motion_set(0x09);
    12d6:	89 e0       	ldi	r24, 0x09	; 9
    12d8:	0e 94 61 09 	call	0x12c2	; 0x12c2 <motion_set>
}
    12dc:	08 95       	ret

000012de <left>:

void left (void) //Left wheel backward, Right wheel forward
{
	motion_set(0x05);
    12de:	85 e0       	ldi	r24, 0x05	; 5
    12e0:	0e 94 61 09 	call	0x12c2	; 0x12c2 <motion_set>
}
    12e4:	08 95       	ret

000012e6 <right>:

void right (void) //Left wheel forward, Right wheel backward
{
	motion_set(0x0A);
    12e6:	8a e0       	ldi	r24, 0x0A	; 10
    12e8:	0e 94 61 09 	call	0x12c2	; 0x12c2 <motion_set>
}
    12ec:	08 95       	ret

000012ee <soft_left>:

void soft_left (void) //Left wheel stationary, Right wheel forward
{
	motion_set(0x04);
    12ee:	84 e0       	ldi	r24, 0x04	; 4
    12f0:	0e 94 61 09 	call	0x12c2	; 0x12c2 <motion_set>
}
    12f4:	08 95       	ret

000012f6 <soft_right>:

void soft_right (void) //Left wheel forward, Right wheel is stationary
{
	motion_set(0x02);
    12f6:	82 e0       	ldi	r24, 0x02	; 2
    12f8:	0e 94 61 09 	call	0x12c2	; 0x12c2 <motion_set>
}
    12fc:	08 95       	ret

000012fe <soft_left_2>:

void soft_left_2 (void) //Left wheel backward, right wheel stationary
{
	motion_set(0x01);
    12fe:	81 e0       	ldi	r24, 0x01	; 1
    1300:	0e 94 61 09 	call	0x12c2	; 0x12c2 <motion_set>
}
    1304:	08 95       	ret

00001306 <soft_right_2>:

void soft_right_2 (void) //Left wheel stationary, Right wheel backward
{
	motion_set(0x08);
    1306:	88 e0       	ldi	r24, 0x08	; 8
    1308:	0e 94 61 09 	call	0x12c2	; 0x12c2 <motion_set>
}
    130c:	08 95       	ret

0000130e <stop>:

void stop (void)
{
	motion_set(0x00);
    130e:	80 e0       	ldi	r24, 0x00	; 0
    1310:	0e 94 61 09 	call	0x12c2	; 0x12c2 <motion_set>
}
    1314:	08 95       	ret

00001316 <angle_rotate>:


//Function used for turning robot by specified degrees
void angle_rotate(unsigned int Degrees)
{
    1316:	0f 93       	push	r16
    1318:	1f 93       	push	r17
    131a:	cf 93       	push	r28
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = (float) Degrees/ 4.090; // division by resolution to get shaft count
    131c:	bc 01       	movw	r22, r24
    131e:	80 e0       	ldi	r24, 0x00	; 0
    1320:	90 e0       	ldi	r25, 0x00	; 0
    1322:	0e 94 25 13 	call	0x264a	; 0x264a <__floatunsisf>
    1326:	28 e4       	ldi	r18, 0x48	; 72
    1328:	31 ee       	ldi	r19, 0xE1	; 225
    132a:	42 e8       	ldi	r20, 0x82	; 130
    132c:	50 e4       	ldi	r21, 0x40	; 64
    132e:	0e 94 91 12 	call	0x2522	; 0x2522 <__divsf3>
	ReqdShaftCountInt = (unsigned int) ReqdShaftCount;
    1332:	0e 94 f9 12 	call	0x25f2	; 0x25f2 <__fixunssfsi>
    1336:	dc 01       	movw	r26, r24
    1338:	cb 01       	movw	r24, r22
    133a:	a0 e0       	ldi	r26, 0x00	; 0
    133c:	b0 e0       	ldi	r27, 0x00	; 0
	ShaftCountRight = 0;
    133e:	10 92 d9 13 	sts	0x13D9, r1
    1342:	10 92 da 13 	sts	0x13DA, r1
    1346:	10 92 db 13 	sts	0x13DB, r1
    134a:	10 92 dc 13 	sts	0x13DC, r1
	ShaftCountLeft = 0;
    134e:	10 92 dd 13 	sts	0x13DD, r1
    1352:	10 92 de 13 	sts	0x13DE, r1
    1356:	10 92 df 13 	sts	0x13DF, r1
    135a:	10 92 e0 13 	sts	0x13E0, r1

	while (1)
	{
		if((ShaftCountRight >= ReqdShaftCountInt) | (ShaftCountLeft >= ReqdShaftCountInt))
    135e:	f1 e0       	ldi	r31, 0x01	; 1
    1360:	c0 e0       	ldi	r28, 0x00	; 0
    1362:	40 91 d9 13 	lds	r20, 0x13D9
    1366:	50 91 da 13 	lds	r21, 0x13DA
    136a:	60 91 db 13 	lds	r22, 0x13DB
    136e:	70 91 dc 13 	lds	r23, 0x13DC
    1372:	00 91 dd 13 	lds	r16, 0x13DD
    1376:	10 91 de 13 	lds	r17, 0x13DE
    137a:	20 91 df 13 	lds	r18, 0x13DF
    137e:	30 91 e0 13 	lds	r19, 0x13E0
    1382:	ef 2f       	mov	r30, r31
    1384:	48 17       	cp	r20, r24
    1386:	59 07       	cpc	r21, r25
    1388:	6a 07       	cpc	r22, r26
    138a:	7b 07       	cpc	r23, r27
    138c:	08 f4       	brcc	.+2      	; 0x1390 <angle_rotate+0x7a>
    138e:	ec 2f       	mov	r30, r28
    1390:	ee 23       	and	r30, r30
    1392:	49 f4       	brne	.+18     	; 0x13a6 <angle_rotate+0x90>
    1394:	4f 2f       	mov	r20, r31
    1396:	08 17       	cp	r16, r24
    1398:	19 07       	cpc	r17, r25
    139a:	2a 07       	cpc	r18, r26
    139c:	3b 07       	cpc	r19, r27
    139e:	08 f4       	brcc	.+2      	; 0x13a2 <angle_rotate+0x8c>
    13a0:	4c 2f       	mov	r20, r28
    13a2:	44 23       	and	r20, r20
    13a4:	f1 f2       	breq	.-68     	; 0x1362 <angle_rotate+0x4c>
		break;
	}
	stop(); //Stop robot
    13a6:	0e 94 87 09 	call	0x130e	; 0x130e <stop>
}
    13aa:	cf 91       	pop	r28
    13ac:	1f 91       	pop	r17
    13ae:	0f 91       	pop	r16
    13b0:	08 95       	ret

000013b2 <linear_distance_mm>:
void linear_distance_mm(unsigned int DistanceInMM)
{
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
    13b2:	bc 01       	movw	r22, r24
    13b4:	80 e0       	ldi	r24, 0x00	; 0
    13b6:	90 e0       	ldi	r25, 0x00	; 0
    13b8:	0e 94 25 13 	call	0x264a	; 0x264a <__floatunsisf>
    13bc:	25 ee       	ldi	r18, 0xE5	; 229
    13be:	30 ed       	ldi	r19, 0xD0	; 208
    13c0:	4a ea       	ldi	r20, 0xAA	; 170
    13c2:	50 e4       	ldi	r21, 0x40	; 64
    13c4:	0e 94 91 12 	call	0x2522	; 0x2522 <__divsf3>
	ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
    13c8:	0e 94 f9 12 	call	0x25f2	; 0x25f2 <__fixunssfsi>
    13cc:	46 2f       	mov	r20, r22
    13ce:	57 2f       	mov	r21, r23
    13d0:	68 2f       	mov	r22, r24
    13d2:	79 2f       	mov	r23, r25
	
	ShaftCountRight = 0;
    13d4:	10 92 d9 13 	sts	0x13D9, r1
    13d8:	10 92 da 13 	sts	0x13DA, r1
    13dc:	10 92 db 13 	sts	0x13DB, r1
    13e0:	10 92 dc 13 	sts	0x13DC, r1
	while(1)
	{
		if(ShaftCountRight > ReqdShaftCountInt)
    13e4:	80 91 d9 13 	lds	r24, 0x13D9
    13e8:	90 91 da 13 	lds	r25, 0x13DA
    13ec:	a0 91 db 13 	lds	r26, 0x13DB
    13f0:	b0 91 dc 13 	lds	r27, 0x13DC
    13f4:	48 17       	cp	r20, r24
    13f6:	59 07       	cpc	r21, r25
    13f8:	6a 07       	cpc	r22, r26
    13fa:	7b 07       	cpc	r23, r27
    13fc:	98 f7       	brcc	.-26     	; 0x13e4 <linear_distance_mm+0x32>
		{
			break;
		}
	}
	stop(); //Stop robot
    13fe:	0e 94 87 09 	call	0x130e	; 0x130e <stop>
}
    1402:	08 95       	ret

00001404 <forward_mm>:


void forward_mm(unsigned int DistanceInMM)
{
    1404:	cf 93       	push	r28
    1406:	df 93       	push	r29
    1408:	ec 01       	movw	r28, r24
	forward();
    140a:	0e 94 67 09 	call	0x12ce	; 0x12ce <forward>
	linear_distance_mm(DistanceInMM);
    140e:	ce 01       	movw	r24, r28
    1410:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <linear_distance_mm>
}
    1414:	df 91       	pop	r29
    1416:	cf 91       	pop	r28
    1418:	08 95       	ret

0000141a <back_mm>:

void back_mm(unsigned int DistanceInMM)
{
    141a:	cf 93       	push	r28
    141c:	df 93       	push	r29
    141e:	ec 01       	movw	r28, r24
	back();
    1420:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <back>
	linear_distance_mm(DistanceInMM);
    1424:	ce 01       	movw	r24, r28
    1426:	0e 94 d9 09 	call	0x13b2	; 0x13b2 <linear_distance_mm>
}
    142a:	df 91       	pop	r29
    142c:	cf 91       	pop	r28
    142e:	08 95       	ret

00001430 <left_degrees>:

void left_degrees(unsigned int Degrees)
{
    1430:	cf 93       	push	r28
    1432:	df 93       	push	r29
    1434:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	left(); //Turn left
    1436:	0e 94 6f 09 	call	0x12de	; 0x12de <left>
	angle_rotate(Degrees);
    143a:	ce 01       	movw	r24, r28
    143c:	0e 94 8b 09 	call	0x1316	; 0x1316 <angle_rotate>
}
    1440:	df 91       	pop	r29
    1442:	cf 91       	pop	r28
    1444:	08 95       	ret

00001446 <right_degrees>:


void right_degrees(unsigned int Degrees)
{
    1446:	cf 93       	push	r28
    1448:	df 93       	push	r29
    144a:	ec 01       	movw	r28, r24
	// 88 pulses for 360 degrees rotation 4.090 degrees per count
	right(); //Turn right
    144c:	0e 94 73 09 	call	0x12e6	; 0x12e6 <right>
	angle_rotate(Degrees);
    1450:	ce 01       	movw	r24, r28
    1452:	0e 94 8b 09 	call	0x1316	; 0x1316 <angle_rotate>
}
    1456:	df 91       	pop	r29
    1458:	cf 91       	pop	r28
    145a:	08 95       	ret

0000145c <soft_left_degrees>:


void soft_left_degrees(unsigned int Degrees)
{
    145c:	cf 93       	push	r28
    145e:	df 93       	push	r29
    1460:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left(); //Turn soft left
    1462:	0e 94 77 09 	call	0x12ee	; 0x12ee <soft_left>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
    1466:	ce 01       	movw	r24, r28
    1468:	88 0f       	add	r24, r24
    146a:	99 1f       	adc	r25, r25
    146c:	0e 94 8b 09 	call	0x1316	; 0x1316 <angle_rotate>
}
    1470:	df 91       	pop	r29
    1472:	cf 91       	pop	r28
    1474:	08 95       	ret

00001476 <soft_right_degrees>:

void soft_right_degrees(unsigned int Degrees)
{
    1476:	cf 93       	push	r28
    1478:	df 93       	push	r29
    147a:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right();  //Turn soft right
    147c:	0e 94 7b 09 	call	0x12f6	; 0x12f6 <soft_right>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
    1480:	ce 01       	movw	r24, r28
    1482:	88 0f       	add	r24, r24
    1484:	99 1f       	adc	r25, r25
    1486:	0e 94 8b 09 	call	0x1316	; 0x1316 <angle_rotate>
}
    148a:	df 91       	pop	r29
    148c:	cf 91       	pop	r28
    148e:	08 95       	ret

00001490 <soft_left_2_degrees>:

void soft_left_2_degrees(unsigned int Degrees)
{
    1490:	cf 93       	push	r28
    1492:	df 93       	push	r29
    1494:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_left_2(); //Turn reverse soft left
    1496:	0e 94 7f 09 	call	0x12fe	; 0x12fe <soft_left_2>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
    149a:	ce 01       	movw	r24, r28
    149c:	88 0f       	add	r24, r24
    149e:	99 1f       	adc	r25, r25
    14a0:	0e 94 8b 09 	call	0x1316	; 0x1316 <angle_rotate>
}
    14a4:	df 91       	pop	r29
    14a6:	cf 91       	pop	r28
    14a8:	08 95       	ret

000014aa <soft_right_2_degrees>:

void soft_right_2_degrees(unsigned int Degrees)
{
    14aa:	cf 93       	push	r28
    14ac:	df 93       	push	r29
    14ae:	ec 01       	movw	r28, r24
	// 176 pulses for 360 degrees rotation 2.045 degrees per count
	soft_right_2();  //Turn reverse soft right
    14b0:	0e 94 83 09 	call	0x1306	; 0x1306 <soft_right_2>
	Degrees=Degrees*2;
	angle_rotate(Degrees);
    14b4:	ce 01       	movw	r24, r28
    14b6:	88 0f       	add	r24, r24
    14b8:	99 1f       	adc	r25, r25
    14ba:	0e 94 8b 09 	call	0x1316	; 0x1316 <angle_rotate>
}
    14be:	df 91       	pop	r29
    14c0:	cf 91       	pop	r28
    14c2:	08 95       	ret

000014c4 <uart2_init>:
// actual baud rate:9600 (error 0.0%)
// char size: 8 bit
// parity: Disabled
void uart2_init(void)
{
	UCSR2B = 0x00; //disable while setting baud rate
    14c4:	e1 ed       	ldi	r30, 0xD1	; 209
    14c6:	f0 e0       	ldi	r31, 0x00	; 0
    14c8:	10 82       	st	Z, r1
	UCSR2A = 0x00;
    14ca:	10 92 d0 00 	sts	0x00D0, r1
	UCSR2C = 0x06;
    14ce:	86 e0       	ldi	r24, 0x06	; 6
    14d0:	80 93 d2 00 	sts	0x00D2, r24
	UBRR2L = 0x5F; //set baud rate lo
    14d4:	8f e5       	ldi	r24, 0x5F	; 95
    14d6:	80 93 d4 00 	sts	0x00D4, r24
	UBRR2H = 0x00; //set baud rate hi
    14da:	10 92 d5 00 	sts	0x00D5, r1
	UCSR2B = 0x98;
    14de:	88 e9       	ldi	r24, 0x98	; 152
    14e0:	80 83       	st	Z, r24
}
    14e2:	08 95       	ret

000014e4 <__vector_51>:

SIGNAL(SIG_USART2_RECV) {		// ISR for receive complete interrupt
    14e4:	1f 92       	push	r1
    14e6:	0f 92       	push	r0
    14e8:	0f b6       	in	r0, 0x3f	; 63
    14ea:	0f 92       	push	r0
    14ec:	0b b6       	in	r0, 0x3b	; 59
    14ee:	0f 92       	push	r0
    14f0:	11 24       	eor	r1, r1
    14f2:	2f 93       	push	r18
    14f4:	3f 93       	push	r19
    14f6:	4f 93       	push	r20
    14f8:	5f 93       	push	r21
    14fa:	6f 93       	push	r22
    14fc:	7f 93       	push	r23
    14fe:	8f 93       	push	r24
    1500:	9f 93       	push	r25
    1502:	af 93       	push	r26
    1504:	bf 93       	push	r27
    1506:	ef 93       	push	r30
    1508:	ff 93       	push	r31
	data = UDR2; 				// making copy of data from UDR2 in 'data' variable
    150a:	e6 ed       	ldi	r30, 0xD6	; 214
    150c:	f0 e0       	ldi	r31, 0x00	; 0
    150e:	80 81       	ld	r24, Z
    1510:	80 93 fd 13 	sts	0x13FD, r24
	UDR2 = data; 				// echo data back to PC
    1514:	80 83       	st	Z, r24
	strcat(input_str, &data);	// concatenate each ascii character received to string input_str
    1516:	85 e7       	ldi	r24, 0x75	; 117
    1518:	93 e1       	ldi	r25, 0x13	; 19
    151a:	6d ef       	ldi	r22, 0xFD	; 253
    151c:	73 e1       	ldi	r23, 0x13	; 19
    151e:	0e 94 9e 15 	call	0x2b3c	; 0x2b3c <strcat>
	//GLCD_DisplayChar(data);
}
    1522:	ff 91       	pop	r31
    1524:	ef 91       	pop	r30
    1526:	bf 91       	pop	r27
    1528:	af 91       	pop	r26
    152a:	9f 91       	pop	r25
    152c:	8f 91       	pop	r24
    152e:	7f 91       	pop	r23
    1530:	6f 91       	pop	r22
    1532:	5f 91       	pop	r21
    1534:	4f 91       	pop	r20
    1536:	3f 91       	pop	r19
    1538:	2f 91       	pop	r18
    153a:	0f 90       	pop	r0
    153c:	0b be       	out	0x3b, r0	; 59
    153e:	0f 90       	pop	r0
    1540:	0f be       	out	0x3f, r0	; 63
    1542:	0f 90       	pop	r0
    1544:	1f 90       	pop	r1
    1546:	18 95       	reti

00001548 <init_devices>:

void init_devices (void)
{
 	cli(); //Clears the global interrupts
    1548:	f8 94       	cli
	port_init();
    154a:	0e 94 90 08 	call	0x1120	; 0x1120 <port_init>
	lcd_set_4bit();
    154e:	0e 94 a3 02 	call	0x546	; 0x546 <lcd_set_4bit>
	lcd_init();
    1552:	0e 94 0b 03 	call	0x616	; 0x616 <lcd_init>
	GLCD_Init();
    1556:	0e 94 88 04 	call	0x910	; 0x910 <GLCD_Init>
	uart2_init(); //Initialize UART2 for serial communication
    155a:	0e 94 62 0a 	call	0x14c4	; 0x14c4 <uart2_init>
	adc_init();
    155e:	0e 94 20 09 	call	0x1240	; 0x1240 <adc_init>
	timer5_init();
    1562:	0e 94 05 09 	call	0x120a	; 0x120a <timer5_init>
	left_position_encoder_interrupt_init();
    1566:	0e 94 a1 08 	call	0x1142	; 0x1142 <left_position_encoder_interrupt_init>
	right_position_encoder_interrupt_init();
    156a:	0e 94 aa 08 	call	0x1154	; 0x1154 <right_position_encoder_interrupt_init>
	sei();   //Enables the global interrupts
    156e:	78 94       	sei
}
    1570:	08 95       	ret

00001572 <left_led_on>:
 * Logic:			PORT G0 is configured for left RGB LED, writing logic high to PG0
 * Example Call:	left_led_on()
 */
void left_led_on (void) {
	unsigned char port_restore = 0;
	port_restore = PING;
    1572:	82 b3       	in	r24, 0x12	; 18
	port_restore |= 0b00000001;
    1574:	81 60       	ori	r24, 0x01	; 1
	PORTG = port_restore;
    1576:	84 bb       	out	0x14, r24	; 20
}
    1578:	08 95       	ret

0000157a <left_led_off>:
 * Logic:			PORT G0 is configured for left RGB LED, writing logic low to PG0		
 * Example Call:	left_led_on()
 */
void left_led_off (void) {
	unsigned char port_restore = 0;
	port_restore = PING;
    157a:	82 b3       	in	r24, 0x12	; 18
	port_restore &= 0b11111110;
    157c:	8e 7f       	andi	r24, 0xFE	; 254
	PORTG = port_restore;
    157e:	84 bb       	out	0x14, r24	; 20
}
    1580:	08 95       	ret

00001582 <right_led_on>:
 * Logic:			PORT G1 is configured for right RGB LED, writing logic high to PG1			
 * Example Call:	right_led_on()
 */
void right_led_on (void) {
	unsigned char port_restore = 0;
	port_restore = PING;
    1582:	82 b3       	in	r24, 0x12	; 18
	port_restore |= 0b00000010;
    1584:	82 60       	ori	r24, 0x02	; 2
	PORTG = port_restore;
    1586:	84 bb       	out	0x14, r24	; 20
}
    1588:	08 95       	ret

0000158a <right_led_off>:
 * Logic:			PORT G1 is configured for right RGB LED, writing logic low to PG1			
 * Example Call:	right_led_off()
 */
void right_led_off (void) {
	unsigned char port_restore = 0;
	port_restore = PING;
    158a:	82 b3       	in	r24, 0x12	; 18
	port_restore &= 0b11111101;
    158c:	8d 7f       	andi	r24, 0xFD	; 253
	PORTG = port_restore;
    158e:	84 bb       	out	0x14, r24	; 20
}
    1590:	08 95       	ret

00001592 <get_point_cost>:
 * Output:			total_cost - int which is the calculated cost between current and target coordinate point
 * Logic:			It calculates the cost of traveling between two points i.e. calculating row difference and  
 *					column difference and make sum of them
 * Example Call:	get_point_cost(current_point, target_point)
 */
int get_point_cost (int current_point[2], int target_point[2]) {
    1592:	fc 01       	movw	r30, r24
    1594:	db 01       	movw	r26, r22
	int total_cost;	
	total_cost = abs(current_point[0] - target_point[0]) + abs(current_point[1] - target_point[1]);
    1596:	80 81       	ld	r24, Z
    1598:	91 81       	ldd	r25, Z+1	; 0x01
    159a:	2d 91       	ld	r18, X+
    159c:	3c 91       	ld	r19, X
    159e:	11 97       	sbiw	r26, 0x01	; 1
    15a0:	82 1b       	sub	r24, r18
    15a2:	93 0b       	sbc	r25, r19
    15a4:	1a f4       	brpl	.+6      	; 0x15ac <get_point_cost+0x1a>
    15a6:	90 95       	com	r25
    15a8:	81 95       	neg	r24
    15aa:	9f 4f       	sbci	r25, 0xFF	; 255
    15ac:	22 81       	ldd	r18, Z+2	; 0x02
    15ae:	33 81       	ldd	r19, Z+3	; 0x03
    15b0:	12 96       	adiw	r26, 0x02	; 2
    15b2:	4d 91       	ld	r20, X+
    15b4:	5c 91       	ld	r21, X
    15b6:	13 97       	sbiw	r26, 0x03	; 3
    15b8:	24 1b       	sub	r18, r20
    15ba:	35 0b       	sbc	r19, r21
    15bc:	1a f4       	brpl	.+6      	; 0x15c4 <get_point_cost+0x32>
    15be:	30 95       	com	r19
    15c0:	21 95       	neg	r18
    15c2:	3f 4f       	sbci	r19, 0xFF	; 255
    15c4:	82 0f       	add	r24, r18
    15c6:	93 1f       	adc	r25, r19
	return total_cost;
}
    15c8:	08 95       	ret

000015ca <get_nearest_point>:
 * Output:			nearest_point - int array containing row & column number of nearest coordinate point among 4 points of target_cell
 * Logic:			We are calculating traveling cost i.e. distance between current point and each of target cell's 4 points (top-left,
 *					top-right, bottom-right, bottom-left) and returning that point with lowest cost
 * Example Call:	get_nearest_point(current_coordinate, d1_position_map[target_cell_no])
 */
int * get_nearest_point (int current_point[2], int target_cell[4][2]) {
    15ca:	af 92       	push	r10
    15cc:	bf 92       	push	r11
    15ce:	cf 92       	push	r12
    15d0:	df 92       	push	r13
    15d2:	ef 92       	push	r14
    15d4:	ff 92       	push	r15
    15d6:	0f 93       	push	r16
    15d8:	1f 93       	push	r17
    15da:	cf 93       	push	r28
    15dc:	df 93       	push	r29
    15de:	5c 01       	movw	r10, r24
    15e0:	06 2f       	mov	r16, r22
    15e2:	e7 2e       	mov	r14, r23
	int * nearest_point = malloc(2 * sizeof(int));
    15e4:	84 e0       	ldi	r24, 0x04	; 4
    15e6:	90 e0       	ldi	r25, 0x00	; 0
    15e8:	0e 94 4c 14 	call	0x2898	; 0x2898 <malloc>
    15ec:	c8 2e       	mov	r12, r24
    15ee:	d9 2e       	mov	r13, r25
    15f0:	c0 2f       	mov	r28, r16
    15f2:	de 2d       	mov	r29, r14
	
	int i, current_cost, lowest_cost = 100;
    15f4:	0f 2e       	mov	r0, r31
    15f6:	f4 e6       	ldi	r31, 0x64	; 100
    15f8:	ef 2e       	mov	r14, r31
    15fa:	ff 24       	eor	r15, r15
    15fc:	f0 2d       	mov	r31, r0
	
	for (i=0; i<4; i++) {
    15fe:	00 e0       	ldi	r16, 0x00	; 0
    1600:	10 e0       	ldi	r17, 0x00	; 0
		current_cost = get_point_cost(current_point, target_cell[i]);
    1602:	c5 01       	movw	r24, r10
    1604:	be 01       	movw	r22, r28
    1606:	0e 94 c9 0a 	call	0x1592	; 0x1592 <get_point_cost>
		if (current_cost < lowest_cost) {
    160a:	8e 15       	cp	r24, r14
    160c:	9f 05       	cpc	r25, r15
    160e:	54 f4       	brge	.+20     	; 0x1624 <get_nearest_point+0x5a>
			nearest_point[0] = target_cell[i][0];
    1610:	28 81       	ld	r18, Y
    1612:	39 81       	ldd	r19, Y+1	; 0x01
    1614:	f6 01       	movw	r30, r12
    1616:	31 83       	std	Z+1, r19	; 0x01
    1618:	20 83       	st	Z, r18
			nearest_point[1] = target_cell[i][1];
    161a:	2a 81       	ldd	r18, Y+2	; 0x02
    161c:	3b 81       	ldd	r19, Y+3	; 0x03
    161e:	33 83       	std	Z+3, r19	; 0x03
    1620:	22 83       	std	Z+2, r18	; 0x02
			lowest_cost = current_cost;
    1622:	7c 01       	movw	r14, r24
int * get_nearest_point (int current_point[2], int target_cell[4][2]) {
	int * nearest_point = malloc(2 * sizeof(int));
	
	int i, current_cost, lowest_cost = 100;
	
	for (i=0; i<4; i++) {
    1624:	0f 5f       	subi	r16, 0xFF	; 255
    1626:	1f 4f       	sbci	r17, 0xFF	; 255
    1628:	24 96       	adiw	r28, 0x04	; 4
    162a:	04 30       	cpi	r16, 0x04	; 4
    162c:	11 05       	cpc	r17, r1
    162e:	49 f7       	brne	.-46     	; 0x1602 <get_nearest_point+0x38>
			lowest_cost = current_cost;
		}
	}
	
	return nearest_point;
}
    1630:	8c 2d       	mov	r24, r12
    1632:	9d 2d       	mov	r25, r13
    1634:	df 91       	pop	r29
    1636:	cf 91       	pop	r28
    1638:	1f 91       	pop	r17
    163a:	0f 91       	pop	r16
    163c:	ff 90       	pop	r15
    163e:	ef 90       	pop	r14
    1640:	df 90       	pop	r13
    1642:	cf 90       	pop	r12
    1644:	bf 90       	pop	r11
    1646:	af 90       	pop	r10
    1648:	08 95       	ret

0000164a <read_wl_sensor_values>:
 * Output:			It updates global variables Left_white_line, Center_white_line, Right_white_line
 * Logic:			It reads all 3 white line sensor values by using function ADC_Conversion()
 * Example Call:	read_wl_sensor_values()
 */
void read_wl_sensor_values () {
	Left_white_line = ADC_Conversion(3);	//Getting data of Left WL Sensor
    164a:	83 e0       	ldi	r24, 0x03	; 3
    164c:	0e 94 2d 09 	call	0x125a	; 0x125a <ADC_Conversion>
    1650:	80 93 e3 13 	sts	0x13E3, r24
	Center_white_line = ADC_Conversion(2);	//Getting data of Center WL Sensor
    1654:	82 e0       	ldi	r24, 0x02	; 2
    1656:	0e 94 2d 09 	call	0x125a	; 0x125a <ADC_Conversion>
    165a:	80 93 e2 13 	sts	0x13E2, r24
	Right_white_line = ADC_Conversion(1);	//Getting data of Right WL Sensor
    165e:	81 e0       	ldi	r24, 0x01	; 1
    1660:	0e 94 2d 09 	call	0x125a	; 0x125a <ADC_Conversion>
    1664:	80 93 e1 13 	sts	0x13E1, r24
}
    1668:	08 95       	ret

0000166a <follow_black_line>:
 *					of the right wheel if left white line sensor is on the black surface and other twos are on the white surface.
 *					This way the robot follows a 1cm thick black line.
 *					
 * Example Call:	follow_black_line('F')
 */
void follow_black_line (char direction) {
    166a:	cf 93       	push	r28
    166c:	c8 2f       	mov	r28, r24
	flag = 0;
    166e:	10 92 e4 13 	sts	0x13E4, r1
		
	if (((Left_white_line <= BNW_Thresh) && (Center_white_line <= BNW_Thresh) && (Right_white_line <= BNW_Thresh)) || (Center_white_line > BNW_Thresh)) {
    1672:	80 91 02 02 	lds	r24, 0x0202
    1676:	90 91 03 02 	lds	r25, 0x0203
    167a:	20 91 e3 13 	lds	r18, 0x13E3
    167e:	30 e0       	ldi	r19, 0x00	; 0
    1680:	82 17       	cp	r24, r18
    1682:	93 07       	cpc	r25, r19
    1684:	6c f0       	brlt	.+26     	; 0x16a0 <follow_black_line+0x36>
    1686:	20 91 e2 13 	lds	r18, 0x13E2
    168a:	30 e0       	ldi	r19, 0x00	; 0
    168c:	82 17       	cp	r24, r18
    168e:	93 07       	cpc	r25, r19
    1690:	74 f0       	brlt	.+28     	; 0x16ae <follow_black_line+0x44>
    1692:	20 91 e1 13 	lds	r18, 0x13E1
    1696:	30 e0       	ldi	r19, 0x00	; 0
    1698:	82 17       	cp	r24, r18
    169a:	93 07       	cpc	r25, r19
    169c:	44 f4       	brge	.+16     	; 0x16ae <follow_black_line+0x44>
    169e:	88 c0       	rjmp	.+272    	; 0x17b0 <follow_black_line+0x146>
    16a0:	20 91 e2 13 	lds	r18, 0x13E2
    16a4:	30 e0       	ldi	r19, 0x00	; 0
    16a6:	82 17       	cp	r24, r18
    16a8:	93 07       	cpc	r25, r19
    16aa:	0c f0       	brlt	.+2      	; 0x16ae <follow_black_line+0x44>
    16ac:	7c c0       	rjmp	.+248    	; 0x17a6 <follow_black_line+0x13c>
		flag = 1;
    16ae:	81 e0       	ldi	r24, 0x01	; 1
    16b0:	80 93 e4 13 	sts	0x13E4, r24
		if (direction == 'F') forward();
    16b4:	c6 34       	cpi	r28, 0x46	; 70
    16b6:	19 f4       	brne	.+6      	; 0x16be <follow_black_line+0x54>
    16b8:	0e 94 67 09 	call	0x12ce	; 0x12ce <forward>
    16bc:	02 c0       	rjmp	.+4      	; 0x16c2 <follow_black_line+0x58>
		else back();
    16be:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <back>
		velocity(left_velocity, right_velocity);
    16c2:	80 91 f8 13 	lds	r24, 0x13F8
    16c6:	60 91 fe 13 	lds	r22, 0x13FE
    16ca:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <velocity>
	}

	if((Left_white_line <= BNW_Thresh) && (Center_white_line <= BNW_Thresh) && (Right_white_line > BNW_Thresh) && (flag == 0)) {
    16ce:	80 91 02 02 	lds	r24, 0x0202
    16d2:	90 91 03 02 	lds	r25, 0x0203
    16d6:	20 91 e3 13 	lds	r18, 0x13E3
    16da:	30 e0       	ldi	r19, 0x00	; 0
    16dc:	82 17       	cp	r24, r18
    16de:	93 07       	cpc	r25, r19
    16e0:	bc f1       	brlt	.+110    	; 0x1750 <follow_black_line+0xe6>
    16e2:	20 91 e2 13 	lds	r18, 0x13E2
    16e6:	30 e0       	ldi	r19, 0x00	; 0
    16e8:	82 17       	cp	r24, r18
    16ea:	93 07       	cpc	r25, r19
    16ec:	0c f4       	brge	.+2      	; 0x16f0 <follow_black_line+0x86>
    16ee:	65 c0       	rjmp	.+202    	; 0x17ba <follow_black_line+0x150>
    16f0:	20 91 e1 13 	lds	r18, 0x13E1
    16f4:	30 e0       	ldi	r19, 0x00	; 0
    16f6:	82 17       	cp	r24, r18
    16f8:	93 07       	cpc	r25, r19
    16fa:	0c f0       	brlt	.+2      	; 0x16fe <follow_black_line+0x94>
    16fc:	5e c0       	rjmp	.+188    	; 0x17ba <follow_black_line+0x150>
    16fe:	80 91 e4 13 	lds	r24, 0x13E4
    1702:	88 23       	and	r24, r24
    1704:	09 f0       	breq	.+2      	; 0x1708 <follow_black_line+0x9e>
    1706:	59 c0       	rjmp	.+178    	; 0x17ba <follow_black_line+0x150>
		flag = 1;
    1708:	81 e0       	ldi	r24, 0x01	; 1
    170a:	80 93 e4 13 	sts	0x13E4, r24
		if (direction == 'F') {
    170e:	c6 34       	cpi	r28, 0x46	; 70
    1710:	59 f4       	brne	.+22     	; 0x1728 <follow_black_line+0xbe>
			forward();
    1712:	0e 94 67 09 	call	0x12ce	; 0x12ce <forward>
			velocity(left_velocity+30, right_velocity-50);
    1716:	80 91 f8 13 	lds	r24, 0x13F8
    171a:	60 91 fe 13 	lds	r22, 0x13FE
    171e:	62 53       	subi	r22, 0x32	; 50
    1720:	82 5e       	subi	r24, 0xE2	; 226
    1722:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <velocity>
    1726:	0a c0       	rjmp	.+20     	; 0x173c <follow_black_line+0xd2>
		} else {
			back();
    1728:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <back>
			velocity(left_velocity-50, right_velocity+30);
    172c:	80 91 f8 13 	lds	r24, 0x13F8
    1730:	60 91 fe 13 	lds	r22, 0x13FE
    1734:	62 5e       	subi	r22, 0xE2	; 226
    1736:	82 53       	subi	r24, 0x32	; 50
    1738:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <velocity>
		}
	}

	if((Left_white_line > BNW_Thresh) && (Center_white_line <= BNW_Thresh) && (Right_white_line <= BNW_Thresh) && (flag == 0)) {
    173c:	80 91 02 02 	lds	r24, 0x0202
    1740:	90 91 03 02 	lds	r25, 0x0203
    1744:	20 91 e3 13 	lds	r18, 0x13E3
    1748:	30 e0       	ldi	r19, 0x00	; 0
    174a:	82 17       	cp	r24, r18
    174c:	93 07       	cpc	r25, r19
    174e:	ac f5       	brge	.+106    	; 0x17ba <follow_black_line+0x150>
    1750:	20 91 e2 13 	lds	r18, 0x13E2
    1754:	30 e0       	ldi	r19, 0x00	; 0
    1756:	82 17       	cp	r24, r18
    1758:	93 07       	cpc	r25, r19
    175a:	7c f1       	brlt	.+94     	; 0x17ba <follow_black_line+0x150>
    175c:	20 91 e1 13 	lds	r18, 0x13E1
    1760:	30 e0       	ldi	r19, 0x00	; 0
    1762:	82 17       	cp	r24, r18
    1764:	93 07       	cpc	r25, r19
    1766:	4c f1       	brlt	.+82     	; 0x17ba <follow_black_line+0x150>
    1768:	80 91 e4 13 	lds	r24, 0x13E4
    176c:	88 23       	and	r24, r24
    176e:	29 f5       	brne	.+74     	; 0x17ba <follow_black_line+0x150>
		flag = 1;
    1770:	81 e0       	ldi	r24, 0x01	; 1
    1772:	80 93 e4 13 	sts	0x13E4, r24
		if (direction == 'F') {
    1776:	c6 34       	cpi	r28, 0x46	; 70
    1778:	59 f4       	brne	.+22     	; 0x1790 <follow_black_line+0x126>
			forward();
    177a:	0e 94 67 09 	call	0x12ce	; 0x12ce <forward>
			velocity(left_velocity-50, right_velocity+30);
    177e:	80 91 f8 13 	lds	r24, 0x13F8
    1782:	60 91 fe 13 	lds	r22, 0x13FE
    1786:	62 5e       	subi	r22, 0xE2	; 226
    1788:	82 53       	subi	r24, 0x32	; 50
    178a:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <velocity>
    178e:	15 c0       	rjmp	.+42     	; 0x17ba <follow_black_line+0x150>
		} else {
			back();
    1790:	0e 94 6b 09 	call	0x12d6	; 0x12d6 <back>
			velocity(left_velocity+30, right_velocity-50);
    1794:	80 91 f8 13 	lds	r24, 0x13F8
    1798:	60 91 fe 13 	lds	r22, 0x13FE
    179c:	62 53       	subi	r22, 0x32	; 50
    179e:	82 5e       	subi	r24, 0xE2	; 226
    17a0:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <velocity>
    17a4:	0a c0       	rjmp	.+20     	; 0x17ba <follow_black_line+0x150>
		if (direction == 'F') forward();
		else back();
		velocity(left_velocity, right_velocity);
	}

	if((Left_white_line <= BNW_Thresh) && (Center_white_line <= BNW_Thresh) && (Right_white_line > BNW_Thresh) && (flag == 0)) {
    17a6:	80 91 02 02 	lds	r24, 0x0202
    17aa:	90 91 03 02 	lds	r25, 0x0203
    17ae:	d0 cf       	rjmp	.-96     	; 0x1750 <follow_black_line+0xe6>
    17b0:	80 91 02 02 	lds	r24, 0x0202
    17b4:	90 91 03 02 	lds	r25, 0x0203
    17b8:	94 cf       	rjmp	.-216    	; 0x16e2 <follow_black_line+0x78>
		} else {
			back();
			velocity(left_velocity+30, right_velocity-50);
		}
	}
}
    17ba:	cf 91       	pop	r28
    17bc:	08 95       	ret

000017be <follow_black_line_mm>:
 *					and follows the black line. ShaftCountRight and ShaftCountLeft are initially
 *					set to 0. While moving the robot, we increase them and When the ShaftCountRight
 *					or ShaftCountLeft reaches as required, we stop the robot
 * Example Call:	follow_black_line_mm(100, 'F')
 */
void follow_black_line_mm (unsigned int DistanceInMM, char direction) {
    17be:	cf 92       	push	r12
    17c0:	df 92       	push	r13
    17c2:	ef 92       	push	r14
    17c4:	ff 92       	push	r15
    17c6:	cf 93       	push	r28
    17c8:	c6 2f       	mov	r28, r22
	float ReqdShaftCount = 0;
	unsigned long int ReqdShaftCountInt = 0;

	ReqdShaftCount = DistanceInMM / 5.338; // division by resolution to get shaft count
    17ca:	bc 01       	movw	r22, r24
    17cc:	80 e0       	ldi	r24, 0x00	; 0
    17ce:	90 e0       	ldi	r25, 0x00	; 0
    17d0:	0e 94 25 13 	call	0x264a	; 0x264a <__floatunsisf>
    17d4:	25 ee       	ldi	r18, 0xE5	; 229
    17d6:	30 ed       	ldi	r19, 0xD0	; 208
    17d8:	4a ea       	ldi	r20, 0xAA	; 170
    17da:	50 e4       	ldi	r21, 0x40	; 64
    17dc:	0e 94 91 12 	call	0x2522	; 0x2522 <__divsf3>
	ReqdShaftCountInt = (unsigned long int) ReqdShaftCount;
    17e0:	0e 94 f9 12 	call	0x25f2	; 0x25f2 <__fixunssfsi>
    17e4:	c6 2e       	mov	r12, r22
    17e6:	d7 2e       	mov	r13, r23
    17e8:	e8 2e       	mov	r14, r24
    17ea:	f9 2e       	mov	r15, r25
	
	ShaftCountRight = 0;
    17ec:	10 92 d9 13 	sts	0x13D9, r1
    17f0:	10 92 da 13 	sts	0x13DA, r1
    17f4:	10 92 db 13 	sts	0x13DB, r1
    17f8:	10 92 dc 13 	sts	0x13DC, r1
	ShaftCountLeft = 0;
    17fc:	10 92 dd 13 	sts	0x13DD, r1
    1800:	10 92 de 13 	sts	0x13DE, r1
    1804:	10 92 df 13 	sts	0x13DF, r1
    1808:	10 92 e0 13 	sts	0x13E0, r1
	while(1) {
		read_wl_sensor_values();
    180c:	0e 94 25 0b 	call	0x164a	; 0x164a <read_wl_sensor_values>
		
		if(ShaftCountRight > ReqdShaftCountInt || ShaftCountLeft > ReqdShaftCountInt) {
    1810:	80 91 d9 13 	lds	r24, 0x13D9
    1814:	90 91 da 13 	lds	r25, 0x13DA
    1818:	a0 91 db 13 	lds	r26, 0x13DB
    181c:	b0 91 dc 13 	lds	r27, 0x13DC
    1820:	c8 16       	cp	r12, r24
    1822:	d9 06       	cpc	r13, r25
    1824:	ea 06       	cpc	r14, r26
    1826:	fb 06       	cpc	r15, r27
    1828:	88 f0       	brcs	.+34     	; 0x184c <follow_black_line_mm+0x8e>
    182a:	80 91 dd 13 	lds	r24, 0x13DD
    182e:	90 91 de 13 	lds	r25, 0x13DE
    1832:	a0 91 df 13 	lds	r26, 0x13DF
    1836:	b0 91 e0 13 	lds	r27, 0x13E0
    183a:	c8 16       	cp	r12, r24
    183c:	d9 06       	cpc	r13, r25
    183e:	ea 06       	cpc	r14, r26
    1840:	fb 06       	cpc	r15, r27
    1842:	20 f0       	brcs	.+8      	; 0x184c <follow_black_line_mm+0x8e>
			break;
		} else {
			follow_black_line(direction);
    1844:	8c 2f       	mov	r24, r28
    1846:	0e 94 35 0b 	call	0x166a	; 0x166a <follow_black_line>
		}
	}
    184a:	e0 cf       	rjmp	.-64     	; 0x180c <follow_black_line_mm+0x4e>
	
	stop(); //Stop robot	
    184c:	0e 94 87 09 	call	0x130e	; 0x130e <stop>
}
    1850:	cf 91       	pop	r28
    1852:	ff 90       	pop	r15
    1854:	ef 90       	pop	r14
    1856:	df 90       	pop	r13
    1858:	cf 90       	pop	r12
    185a:	08 95       	ret

0000185c <turn_robot>:
 *					then rotate the robot right by 75 degrees using right_degrees(75). After that, we rotate
 *					the robot by 5 degrees in mentioned direction until the center white line sensor detects
 *					a black line.		
 * Example Call:	turn_robot('L')
 */
void turn_robot (char direction) {
    185c:	cf 93       	push	r28
    185e:	c8 2f       	mov	r28, r24
	read_wl_sensor_values();
    1860:	0e 94 25 0b 	call	0x164a	; 0x164a <read_wl_sensor_values>
	velocity(current_velocity+10, current_velocity+10);
    1864:	60 91 0d 02 	lds	r22, 0x020D
    1868:	66 5f       	subi	r22, 0xF6	; 246
    186a:	86 2f       	mov	r24, r22
    186c:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <velocity>
	
	if (direction == 'L') {
    1870:	cc 34       	cpi	r28, 0x4C	; 76
    1872:	09 f5       	brne	.+66     	; 0x18b6 <turn_robot+0x5a>
		left_degrees(75);
    1874:	8b e4       	ldi	r24, 0x4B	; 75
    1876:	90 e0       	ldi	r25, 0x00	; 0
    1878:	0e 94 18 0a 	call	0x1430	; 0x1430 <left_degrees>
		read_wl_sensor_values();
    187c:	0e 94 25 0b 	call	0x164a	; 0x164a <read_wl_sensor_values>
		while (Center_white_line <= BNW_Thresh) {
    1880:	20 91 e2 13 	lds	r18, 0x13E2
    1884:	30 e0       	ldi	r19, 0x00	; 0
    1886:	80 91 02 02 	lds	r24, 0x0202
    188a:	90 91 03 02 	lds	r25, 0x0203
    188e:	82 17       	cp	r24, r18
    1890:	93 07       	cpc	r25, r19
    1892:	8c f1       	brlt	.+98     	; 0x18f6 <turn_robot+0x9a>
			read_wl_sensor_values();
    1894:	0e 94 25 0b 	call	0x164a	; 0x164a <read_wl_sensor_values>
			left_degrees(5);
    1898:	85 e0       	ldi	r24, 0x05	; 5
    189a:	90 e0       	ldi	r25, 0x00	; 0
    189c:	0e 94 18 0a 	call	0x1430	; 0x1430 <left_degrees>
	velocity(current_velocity+10, current_velocity+10);
	
	if (direction == 'L') {
		left_degrees(75);
		read_wl_sensor_values();
		while (Center_white_line <= BNW_Thresh) {
    18a0:	20 91 e2 13 	lds	r18, 0x13E2
    18a4:	30 e0       	ldi	r19, 0x00	; 0
    18a6:	80 91 02 02 	lds	r24, 0x0202
    18aa:	90 91 03 02 	lds	r25, 0x0203
    18ae:	82 17       	cp	r24, r18
    18b0:	93 07       	cpc	r25, r19
    18b2:	84 f7       	brge	.-32     	; 0x1894 <turn_robot+0x38>
    18b4:	20 c0       	rjmp	.+64     	; 0x18f6 <turn_robot+0x9a>
			read_wl_sensor_values();
			left_degrees(5);
		}
	} else {		
		right_degrees(75);
    18b6:	8b e4       	ldi	r24, 0x4B	; 75
    18b8:	90 e0       	ldi	r25, 0x00	; 0
    18ba:	0e 94 23 0a 	call	0x1446	; 0x1446 <right_degrees>
		read_wl_sensor_values();
    18be:	0e 94 25 0b 	call	0x164a	; 0x164a <read_wl_sensor_values>
		while (Center_white_line <= BNW_Thresh) {
    18c2:	20 91 e2 13 	lds	r18, 0x13E2
    18c6:	30 e0       	ldi	r19, 0x00	; 0
    18c8:	80 91 02 02 	lds	r24, 0x0202
    18cc:	90 91 03 02 	lds	r25, 0x0203
    18d0:	82 17       	cp	r24, r18
    18d2:	93 07       	cpc	r25, r19
    18d4:	84 f0       	brlt	.+32     	; 0x18f6 <turn_robot+0x9a>
			read_wl_sensor_values();
    18d6:	0e 94 25 0b 	call	0x164a	; 0x164a <read_wl_sensor_values>
			right_degrees(5);
    18da:	85 e0       	ldi	r24, 0x05	; 5
    18dc:	90 e0       	ldi	r25, 0x00	; 0
    18de:	0e 94 23 0a 	call	0x1446	; 0x1446 <right_degrees>
			left_degrees(5);
		}
	} else {		
		right_degrees(75);
		read_wl_sensor_values();
		while (Center_white_line <= BNW_Thresh) {
    18e2:	20 91 e2 13 	lds	r18, 0x13E2
    18e6:	30 e0       	ldi	r19, 0x00	; 0
    18e8:	80 91 02 02 	lds	r24, 0x0202
    18ec:	90 91 03 02 	lds	r25, 0x0203
    18f0:	82 17       	cp	r24, r18
    18f2:	93 07       	cpc	r25, r19
    18f4:	84 f7       	brge	.-32     	; 0x18d6 <turn_robot+0x7a>
			read_wl_sensor_values();
			right_degrees(5);
		}
	}
	velocity(current_velocity-10 ,current_velocity-10);
    18f6:	60 91 0d 02 	lds	r22, 0x020D
    18fa:	6a 50       	subi	r22, 0x0A	; 10
    18fc:	86 2f       	mov	r24, r22
    18fe:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <velocity>
    1902:	8f ef       	ldi	r24, 0xFF	; 255
    1904:	9f e7       	ldi	r25, 0x7F	; 127
    1906:	a6 e1       	ldi	r26, 0x16	; 22
    1908:	81 50       	subi	r24, 0x01	; 1
    190a:	90 40       	sbci	r25, 0x00	; 0
    190c:	a0 40       	sbci	r26, 0x00	; 0
    190e:	e1 f7       	brne	.-8      	; 0x1908 <turn_robot+0xac>
    1910:	00 c0       	rjmp	.+0      	; 0x1912 <turn_robot+0xb6>
    1912:	00 00       	nop
	_delay_ms(500);
}
    1914:	cf 91       	pop	r28
    1916:	08 95       	ret

00001918 <change_direction>:
 *					if current direction is west and desired direction is south then
 *						we turn the robot left by 90 degrees using turn_robot('L') and updates current direction to south
 * Example Call:	change_direction('N')
 */
void change_direction (unsigned char desired_direction) {
	if (current_direction == desired_direction) return;
    1918:	90 91 0c 02 	lds	r25, 0x020C
    191c:	98 17       	cp	r25, r24
    191e:	09 f4       	brne	.+2      	; 0x1922 <change_direction+0xa>
    1920:	b5 c0       	rjmp	.+362    	; 0x1a8c <change_direction+0x174>
	
	if (current_direction == 'N' && desired_direction == 'W') { // north
    1922:	9e 34       	cpi	r25, 0x4E	; 78
    1924:	61 f5       	brne	.+88     	; 0x197e <change_direction+0x66>
    1926:	87 35       	cpi	r24, 0x57	; 87
    1928:	39 f4       	brne	.+14     	; 0x1938 <change_direction+0x20>
		turn_robot('L');
    192a:	8c e4       	ldi	r24, 0x4C	; 76
    192c:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
		current_direction = 'W';
    1930:	87 e5       	ldi	r24, 0x57	; 87
    1932:	80 93 0c 02 	sts	0x020C, r24
    1936:	08 95       	ret
	} else if (current_direction == 'N' && desired_direction == 'E') { // north
    1938:	85 34       	cpi	r24, 0x45	; 69
    193a:	39 f4       	brne	.+14     	; 0x194a <change_direction+0x32>
		turn_robot('R');
    193c:	82 e5       	ldi	r24, 0x52	; 82
    193e:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
		current_direction = 'E';
    1942:	85 e4       	ldi	r24, 0x45	; 69
    1944:	80 93 0c 02 	sts	0x020C, r24
    1948:	08 95       	ret
	} else if (current_direction == 'N' && desired_direction == 'S') { // north
    194a:	83 35       	cpi	r24, 0x53	; 83
    194c:	09 f0       	breq	.+2      	; 0x1950 <change_direction+0x38>
    194e:	72 c0       	rjmp	.+228    	; 0x1a34 <change_direction+0x11c>
		if (current_coordinate[1] == 0) {
    1950:	80 91 06 02 	lds	r24, 0x0206
    1954:	90 91 07 02 	lds	r25, 0x0207
    1958:	00 97       	sbiw	r24, 0x00	; 0
    195a:	39 f4       	brne	.+14     	; 0x196a <change_direction+0x52>
			turn_robot('R');
    195c:	82 e5       	ldi	r24, 0x52	; 82
    195e:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
			turn_robot('R');
    1962:	82 e5       	ldi	r24, 0x52	; 82
    1964:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
    1968:	06 c0       	rjmp	.+12     	; 0x1976 <change_direction+0x5e>
		} else {
			turn_robot('L');
    196a:	8c e4       	ldi	r24, 0x4C	; 76
    196c:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
			turn_robot('L');
    1970:	8c e4       	ldi	r24, 0x4C	; 76
    1972:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
		}

		current_direction = 'S';
    1976:	83 e5       	ldi	r24, 0x53	; 83
    1978:	80 93 0c 02 	sts	0x020C, r24
    197c:	08 95       	ret
	} else if (current_direction == 'S' && desired_direction == 'N') { //south
    197e:	93 35       	cpi	r25, 0x53	; 83
    1980:	61 f5       	brne	.+88     	; 0x19da <change_direction+0xc2>
    1982:	8e 34       	cpi	r24, 0x4E	; 78
    1984:	b9 f4       	brne	.+46     	; 0x19b4 <change_direction+0x9c>
		if (current_coordinate[1] == 0) {
    1986:	80 91 06 02 	lds	r24, 0x0206
    198a:	90 91 07 02 	lds	r25, 0x0207
    198e:	00 97       	sbiw	r24, 0x00	; 0
    1990:	39 f4       	brne	.+14     	; 0x19a0 <change_direction+0x88>
			turn_robot('L');
    1992:	8c e4       	ldi	r24, 0x4C	; 76
    1994:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
			turn_robot('L');
    1998:	8c e4       	ldi	r24, 0x4C	; 76
    199a:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
    199e:	06 c0       	rjmp	.+12     	; 0x19ac <change_direction+0x94>
		} else {
			turn_robot('R');
    19a0:	82 e5       	ldi	r24, 0x52	; 82
    19a2:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
			turn_robot('R');
    19a6:	82 e5       	ldi	r24, 0x52	; 82
    19a8:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
		}
		
		current_direction = 'N';
    19ac:	8e e4       	ldi	r24, 0x4E	; 78
    19ae:	80 93 0c 02 	sts	0x020C, r24
    19b2:	08 95       	ret
	} else if (current_direction == 'S' && desired_direction == 'E') { //south
    19b4:	85 34       	cpi	r24, 0x45	; 69
    19b6:	39 f4       	brne	.+14     	; 0x19c6 <change_direction+0xae>
		turn_robot('L');
    19b8:	8c e4       	ldi	r24, 0x4C	; 76
    19ba:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
		current_direction = 'E';
    19be:	85 e4       	ldi	r24, 0x45	; 69
    19c0:	80 93 0c 02 	sts	0x020C, r24
    19c4:	08 95       	ret
	} else if (current_direction == 'S' && desired_direction == 'W') { //south
    19c6:	87 35       	cpi	r24, 0x57	; 87
    19c8:	09 f0       	breq	.+2      	; 0x19cc <change_direction+0xb4>
    19ca:	60 c0       	rjmp	.+192    	; 0x1a8c <change_direction+0x174>
		turn_robot('R');
    19cc:	82 e5       	ldi	r24, 0x52	; 82
    19ce:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
		current_direction = 'W';
    19d2:	87 e5       	ldi	r24, 0x57	; 87
    19d4:	80 93 0c 02 	sts	0x020C, r24
    19d8:	08 95       	ret
	} else if (current_direction == 'E' && desired_direction == 'N') { //east
    19da:	95 34       	cpi	r25, 0x45	; 69
    19dc:	59 f5       	brne	.+86     	; 0x1a34 <change_direction+0x11c>
    19de:	8e 34       	cpi	r24, 0x4E	; 78
    19e0:	39 f4       	brne	.+14     	; 0x19f0 <change_direction+0xd8>
		turn_robot('L');
    19e2:	8c e4       	ldi	r24, 0x4C	; 76
    19e4:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
		current_direction = 'N';
    19e8:	8e e4       	ldi	r24, 0x4E	; 78
    19ea:	80 93 0c 02 	sts	0x020C, r24
    19ee:	08 95       	ret
	} else if (current_direction == 'E' && desired_direction == 'W') { //east
    19f0:	87 35       	cpi	r24, 0x57	; 87
    19f2:	b9 f4       	brne	.+46     	; 0x1a22 <change_direction+0x10a>
		if (current_coordinate[0] == 0) {
    19f4:	80 91 04 02 	lds	r24, 0x0204
    19f8:	90 91 05 02 	lds	r25, 0x0205
    19fc:	00 97       	sbiw	r24, 0x00	; 0
    19fe:	39 f4       	brne	.+14     	; 0x1a0e <change_direction+0xf6>
			turn_robot('R');
    1a00:	82 e5       	ldi	r24, 0x52	; 82
    1a02:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
			turn_robot('R');	
    1a06:	82 e5       	ldi	r24, 0x52	; 82
    1a08:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
    1a0c:	06 c0       	rjmp	.+12     	; 0x1a1a <change_direction+0x102>
		} else {
			turn_robot('L');
    1a0e:	8c e4       	ldi	r24, 0x4C	; 76
    1a10:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
			turn_robot('L');
    1a14:	8c e4       	ldi	r24, 0x4C	; 76
    1a16:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
		}
		
		current_direction = 'W';
    1a1a:	87 e5       	ldi	r24, 0x57	; 87
    1a1c:	80 93 0c 02 	sts	0x020C, r24
    1a20:	08 95       	ret
	} else if (current_direction == 'E' && desired_direction == 'S') { //east
    1a22:	83 35       	cpi	r24, 0x53	; 83
    1a24:	99 f5       	brne	.+102    	; 0x1a8c <change_direction+0x174>
		turn_robot('R');	
    1a26:	82 e5       	ldi	r24, 0x52	; 82
    1a28:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
		current_direction = 'S';
    1a2c:	83 e5       	ldi	r24, 0x53	; 83
    1a2e:	80 93 0c 02 	sts	0x020C, r24
    1a32:	08 95       	ret
	} else if (current_direction == 'W' && desired_direction == 'N') { //west
    1a34:	97 35       	cpi	r25, 0x57	; 87
    1a36:	51 f5       	brne	.+84     	; 0x1a8c <change_direction+0x174>
    1a38:	8e 34       	cpi	r24, 0x4E	; 78
    1a3a:	39 f4       	brne	.+14     	; 0x1a4a <change_direction+0x132>
		turn_robot('R');	
    1a3c:	82 e5       	ldi	r24, 0x52	; 82
    1a3e:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
		current_direction = 'N';
    1a42:	8e e4       	ldi	r24, 0x4E	; 78
    1a44:	80 93 0c 02 	sts	0x020C, r24
    1a48:	08 95       	ret
	} else if (current_direction == 'W' && desired_direction == 'E') { //west
    1a4a:	85 34       	cpi	r24, 0x45	; 69
    1a4c:	b9 f4       	brne	.+46     	; 0x1a7c <change_direction+0x164>
		if (current_coordinate[0] == 0) {
    1a4e:	80 91 04 02 	lds	r24, 0x0204
    1a52:	90 91 05 02 	lds	r25, 0x0205
    1a56:	00 97       	sbiw	r24, 0x00	; 0
    1a58:	39 f4       	brne	.+14     	; 0x1a68 <change_direction+0x150>
			turn_robot('L');
    1a5a:	8c e4       	ldi	r24, 0x4C	; 76
    1a5c:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
			turn_robot('L');
    1a60:	8c e4       	ldi	r24, 0x4C	; 76
    1a62:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
    1a66:	06 c0       	rjmp	.+12     	; 0x1a74 <change_direction+0x15c>
		} else {
			turn_robot('R');	
    1a68:	82 e5       	ldi	r24, 0x52	; 82
    1a6a:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
			turn_robot('R');
    1a6e:	82 e5       	ldi	r24, 0x52	; 82
    1a70:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
		}
		
		current_direction = 'E';
    1a74:	85 e4       	ldi	r24, 0x45	; 69
    1a76:	80 93 0c 02 	sts	0x020C, r24
    1a7a:	08 95       	ret
	} else if (current_direction == 'W' && desired_direction == 'S') { //west
    1a7c:	83 35       	cpi	r24, 0x53	; 83
    1a7e:	31 f4       	brne	.+12     	; 0x1a8c <change_direction+0x174>
		turn_robot('L');
    1a80:	8c e4       	ldi	r24, 0x4C	; 76
    1a82:	0e 94 2e 0c 	call	0x185c	; 0x185c <turn_robot>
		current_direction = 'S';
    1a86:	83 e5       	ldi	r24, 0x53	; 83
    1a88:	80 93 0c 02 	sts	0x020C, r24
    1a8c:	08 95       	ret

00001a8e <move_one_cell>:
 *					Again, if all three white line sensors are on black surface, we also detect it as a 3x3cm black square.
 *					After all, forward the robot 5 cm to make the wheels on the 3x3cm black squares.					
 * Example Call:	move_one_cell()
 */
void move_one_cell () {
	read_wl_sensor_values();
    1a8e:	0e 94 25 0b 	call	0x164a	; 0x164a <read_wl_sensor_values>

	while (!(((Left_white_line > BNW_Thresh) && (Center_white_line > BNW_Thresh)) || ((Center_white_line > BNW_Thresh) && (Right_white_line > BNW_Thresh)) // 1-2 or 3-2 on white
    1a92:	05 c0       	rjmp	.+10     	; 0x1a9e <move_one_cell+0x10>
			|| ((Left_white_line > BNW_Thresh) && (Center_white_line > BNW_Thresh) && (Right_white_line > BNW_Thresh)))) { // center on black
		read_wl_sensor_values();
    1a94:	0e 94 25 0b 	call	0x164a	; 0x164a <read_wl_sensor_values>
		follow_black_line('F');
    1a98:	86 e4       	ldi	r24, 0x46	; 70
    1a9a:	0e 94 35 0b 	call	0x166a	; 0x166a <follow_black_line>
 * Example Call:	move_one_cell()
 */
void move_one_cell () {
	read_wl_sensor_values();

	while (!(((Left_white_line > BNW_Thresh) && (Center_white_line > BNW_Thresh)) || ((Center_white_line > BNW_Thresh) && (Right_white_line > BNW_Thresh)) // 1-2 or 3-2 on white
    1a9e:	80 91 02 02 	lds	r24, 0x0202
    1aa2:	90 91 03 02 	lds	r25, 0x0203
    1aa6:	20 91 e3 13 	lds	r18, 0x13E3
    1aaa:	30 e0       	ldi	r19, 0x00	; 0
    1aac:	82 17       	cp	r24, r18
    1aae:	93 07       	cpc	r25, r19
    1ab0:	3c f4       	brge	.+14     	; 0x1ac0 <move_one_cell+0x32>
    1ab2:	20 91 e2 13 	lds	r18, 0x13E2
    1ab6:	30 e0       	ldi	r19, 0x00	; 0
    1ab8:	82 17       	cp	r24, r18
    1aba:	93 07       	cpc	r25, r19
    1abc:	1c f5       	brge	.+70     	; 0x1b04 <move_one_cell+0x76>
    1abe:	13 c0       	rjmp	.+38     	; 0x1ae6 <move_one_cell+0x58>
    1ac0:	20 91 e2 13 	lds	r18, 0x13E2
    1ac4:	30 e0       	ldi	r19, 0x00	; 0
    1ac6:	82 17       	cp	r24, r18
    1ac8:	93 07       	cpc	r25, r19
    1aca:	24 f7       	brge	.-56     	; 0x1a94 <move_one_cell+0x6>
    1acc:	20 91 e1 13 	lds	r18, 0x13E1
    1ad0:	30 e0       	ldi	r19, 0x00	; 0
    1ad2:	82 17       	cp	r24, r18
    1ad4:	93 07       	cpc	r25, r19
    1ad6:	f4 f6       	brge	.-68     	; 0x1a94 <move_one_cell+0x6>
    1ad8:	06 c0       	rjmp	.+12     	; 0x1ae6 <move_one_cell+0x58>
			|| ((Left_white_line > BNW_Thresh) && (Center_white_line > BNW_Thresh) && (Right_white_line > BNW_Thresh)))) { // center on black
    1ada:	20 91 e1 13 	lds	r18, 0x13E1
    1ade:	30 e0       	ldi	r19, 0x00	; 0
    1ae0:	82 17       	cp	r24, r18
    1ae2:	93 07       	cpc	r25, r19
    1ae4:	bc f6       	brge	.-82     	; 0x1a94 <move_one_cell+0x6>
    1ae6:	8f ef       	ldi	r24, 0xFF	; 255
    1ae8:	9f ef       	ldi	r25, 0xFF	; 255
    1aea:	a8 e0       	ldi	r26, 0x08	; 8
    1aec:	81 50       	subi	r24, 0x01	; 1
    1aee:	90 40       	sbci	r25, 0x00	; 0
    1af0:	a0 40       	sbci	r26, 0x00	; 0
    1af2:	e1 f7       	brne	.-8      	; 0x1aec <move_one_cell+0x5e>
    1af4:	00 c0       	rjmp	.+0      	; 0x1af6 <move_one_cell+0x68>
    1af6:	00 00       	nop
		
	// this delay is important: if disabled, the bot may get our of line
	_delay_ms(200);	// delay
	
	// adjust 10/2 cm forward to make the wheels on the 3x3cm black squares.
	follow_black_line_mm(50, 'F');
    1af8:	82 e3       	ldi	r24, 0x32	; 50
    1afa:	90 e0       	ldi	r25, 0x00	; 0
    1afc:	66 e4       	ldi	r22, 0x46	; 70
    1afe:	0e 94 df 0b 	call	0x17be	; 0x17be <follow_black_line_mm>
}
    1b02:	08 95       	ret
 */
void move_one_cell () {
	read_wl_sensor_values();

	while (!(((Left_white_line > BNW_Thresh) && (Center_white_line > BNW_Thresh)) || ((Center_white_line > BNW_Thresh) && (Right_white_line > BNW_Thresh)) // 1-2 or 3-2 on white
			|| ((Left_white_line > BNW_Thresh) && (Center_white_line > BNW_Thresh) && (Right_white_line > BNW_Thresh)))) { // center on black
    1b04:	82 17       	cp	r24, r18
    1b06:	93 07       	cpc	r25, r19
    1b08:	2c f6       	brge	.-118    	; 0x1a94 <move_one_cell+0x6>
    1b0a:	e7 cf       	rjmp	.-50     	; 0x1ada <move_one_cell+0x4c>

00001b0c <match_column>:
 *					All after above, Until current co-ordinate's column < target co-ordinates's column, we repeat the process indented below
 *						change direction to east by using change_direction('E') and then move the robot by one cell
 *						forward by using move_one_cell(). After that we update current co-ordinate's column number by increase 1
 * Example Call:	match_column((int){1, 3})
 */
void match_column (int target_coordinate[]) {
    1b0c:	0f 93       	push	r16
    1b0e:	1f 93       	push	r17
    1b10:	cf 93       	push	r28
    1b12:	df 93       	push	r29
    1b14:	8c 01       	movw	r16, r24
	while (current_coordinate[1] > target_coordinate[1]) {
    1b16:	20 91 06 02 	lds	r18, 0x0206
    1b1a:	30 91 07 02 	lds	r19, 0x0207
    1b1e:	fc 01       	movw	r30, r24
    1b20:	82 81       	ldd	r24, Z+2	; 0x02
    1b22:	93 81       	ldd	r25, Z+3	; 0x03
    1b24:	82 17       	cp	r24, r18
    1b26:	93 07       	cpc	r25, r19
    1b28:	94 f4       	brge	.+36     	; 0x1b4e <match_column+0x42>
		change_direction('W');
		move_one_cell();
		current_coordinate[1]--;
    1b2a:	c6 e0       	ldi	r28, 0x06	; 6
    1b2c:	d2 e0       	ldi	r29, 0x02	; 2
 *						forward by using move_one_cell(). After that we update current co-ordinate's column number by increase 1
 * Example Call:	match_column((int){1, 3})
 */
void match_column (int target_coordinate[]) {
	while (current_coordinate[1] > target_coordinate[1]) {
		change_direction('W');
    1b2e:	87 e5       	ldi	r24, 0x57	; 87
    1b30:	0e 94 8c 0c 	call	0x1918	; 0x1918 <change_direction>
		move_one_cell();
    1b34:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <move_one_cell>
		current_coordinate[1]--;
    1b38:	88 81       	ld	r24, Y
    1b3a:	99 81       	ldd	r25, Y+1	; 0x01
    1b3c:	01 97       	sbiw	r24, 0x01	; 1
    1b3e:	99 83       	std	Y+1, r25	; 0x01
    1b40:	88 83       	st	Y, r24
 *						change direction to east by using change_direction('E') and then move the robot by one cell
 *						forward by using move_one_cell(). After that we update current co-ordinate's column number by increase 1
 * Example Call:	match_column((int){1, 3})
 */
void match_column (int target_coordinate[]) {
	while (current_coordinate[1] > target_coordinate[1]) {
    1b42:	f8 01       	movw	r30, r16
    1b44:	22 81       	ldd	r18, Z+2	; 0x02
    1b46:	33 81       	ldd	r19, Z+3	; 0x03
    1b48:	28 17       	cp	r18, r24
    1b4a:	39 07       	cpc	r19, r25
    1b4c:	84 f3       	brlt	.-32     	; 0x1b2e <match_column+0x22>
		change_direction('W');
		move_one_cell();
		current_coordinate[1]--;
	}
		
	while (current_coordinate[1] < target_coordinate[1]) {// go east/west until both position on same column
    1b4e:	20 91 06 02 	lds	r18, 0x0206
    1b52:	30 91 07 02 	lds	r19, 0x0207
    1b56:	f8 01       	movw	r30, r16
    1b58:	82 81       	ldd	r24, Z+2	; 0x02
    1b5a:	93 81       	ldd	r25, Z+3	; 0x03
    1b5c:	28 17       	cp	r18, r24
    1b5e:	39 07       	cpc	r19, r25
    1b60:	94 f4       	brge	.+36     	; 0x1b86 <match_column+0x7a>
		change_direction('E');
		move_one_cell();
		current_coordinate[1]++;
    1b62:	c6 e0       	ldi	r28, 0x06	; 6
    1b64:	d2 e0       	ldi	r29, 0x02	; 2
		move_one_cell();
		current_coordinate[1]--;
	}
		
	while (current_coordinate[1] < target_coordinate[1]) {// go east/west until both position on same column
		change_direction('E');
    1b66:	85 e4       	ldi	r24, 0x45	; 69
    1b68:	0e 94 8c 0c 	call	0x1918	; 0x1918 <change_direction>
		move_one_cell();
    1b6c:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <move_one_cell>
		current_coordinate[1]++;
    1b70:	88 81       	ld	r24, Y
    1b72:	99 81       	ldd	r25, Y+1	; 0x01
    1b74:	01 96       	adiw	r24, 0x01	; 1
    1b76:	99 83       	std	Y+1, r25	; 0x01
    1b78:	88 83       	st	Y, r24
		change_direction('W');
		move_one_cell();
		current_coordinate[1]--;
	}
		
	while (current_coordinate[1] < target_coordinate[1]) {// go east/west until both position on same column
    1b7a:	f8 01       	movw	r30, r16
    1b7c:	22 81       	ldd	r18, Z+2	; 0x02
    1b7e:	33 81       	ldd	r19, Z+3	; 0x03
    1b80:	82 17       	cp	r24, r18
    1b82:	93 07       	cpc	r25, r19
    1b84:	84 f3       	brlt	.-32     	; 0x1b66 <match_column+0x5a>
		change_direction('E');
		move_one_cell();
		current_coordinate[1]++;
	}
}
    1b86:	df 91       	pop	r29
    1b88:	cf 91       	pop	r28
    1b8a:	1f 91       	pop	r17
    1b8c:	0f 91       	pop	r16
    1b8e:	08 95       	ret

00001b90 <match_row>:
 *					All after above, Until current co-ordinate's row < target co-ordinates's row, we repeat the process indented below
 *						change direction to south by using change_direction('S') and then move the robot by one cell
 *						forward by using move_one_cell(). After that we update current co-ordinate's column number by increase 1
 * Example Call:	match_row((int){1, 3})
 */
void match_row (int target_coordinate[]) {
    1b90:	0f 93       	push	r16
    1b92:	1f 93       	push	r17
    1b94:	cf 93       	push	r28
    1b96:	df 93       	push	r29
    1b98:	8c 01       	movw	r16, r24
	while (current_coordinate[0] > target_coordinate[0]) {// go north/south until both position on same row
    1b9a:	20 91 04 02 	lds	r18, 0x0204
    1b9e:	30 91 05 02 	lds	r19, 0x0205
    1ba2:	fc 01       	movw	r30, r24
    1ba4:	80 81       	ld	r24, Z
    1ba6:	91 81       	ldd	r25, Z+1	; 0x01
    1ba8:	82 17       	cp	r24, r18
    1baa:	93 07       	cpc	r25, r19
    1bac:	94 f4       	brge	.+36     	; 0x1bd2 <match_row+0x42>
		change_direction('N');
		move_one_cell();
		current_coordinate[0]--;
    1bae:	c4 e0       	ldi	r28, 0x04	; 4
    1bb0:	d2 e0       	ldi	r29, 0x02	; 2
 *						forward by using move_one_cell(). After that we update current co-ordinate's column number by increase 1
 * Example Call:	match_row((int){1, 3})
 */
void match_row (int target_coordinate[]) {
	while (current_coordinate[0] > target_coordinate[0]) {// go north/south until both position on same row
		change_direction('N');
    1bb2:	8e e4       	ldi	r24, 0x4E	; 78
    1bb4:	0e 94 8c 0c 	call	0x1918	; 0x1918 <change_direction>
		move_one_cell();
    1bb8:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <move_one_cell>
		current_coordinate[0]--;
    1bbc:	88 81       	ld	r24, Y
    1bbe:	99 81       	ldd	r25, Y+1	; 0x01
    1bc0:	01 97       	sbiw	r24, 0x01	; 1
    1bc2:	99 83       	std	Y+1, r25	; 0x01
    1bc4:	88 83       	st	Y, r24
 *						change direction to south by using change_direction('S') and then move the robot by one cell
 *						forward by using move_one_cell(). After that we update current co-ordinate's column number by increase 1
 * Example Call:	match_row((int){1, 3})
 */
void match_row (int target_coordinate[]) {
	while (current_coordinate[0] > target_coordinate[0]) {// go north/south until both position on same row
    1bc6:	f8 01       	movw	r30, r16
    1bc8:	20 81       	ld	r18, Z
    1bca:	31 81       	ldd	r19, Z+1	; 0x01
    1bcc:	28 17       	cp	r18, r24
    1bce:	39 07       	cpc	r19, r25
    1bd0:	84 f3       	brlt	.-32     	; 0x1bb2 <match_row+0x22>
		change_direction('N');
		move_one_cell();
		current_coordinate[0]--;
	}
	
	while (current_coordinate[0] < target_coordinate[0]) {// go north/south until both position on same row
    1bd2:	20 91 04 02 	lds	r18, 0x0204
    1bd6:	30 91 05 02 	lds	r19, 0x0205
    1bda:	f8 01       	movw	r30, r16
    1bdc:	80 81       	ld	r24, Z
    1bde:	91 81       	ldd	r25, Z+1	; 0x01
    1be0:	28 17       	cp	r18, r24
    1be2:	39 07       	cpc	r19, r25
    1be4:	94 f4       	brge	.+36     	; 0x1c0a <match_row+0x7a>
		change_direction('S');
		move_one_cell();
		current_coordinate[0]++;
    1be6:	c4 e0       	ldi	r28, 0x04	; 4
    1be8:	d2 e0       	ldi	r29, 0x02	; 2
		move_one_cell();
		current_coordinate[0]--;
	}
	
	while (current_coordinate[0] < target_coordinate[0]) {// go north/south until both position on same row
		change_direction('S');
    1bea:	83 e5       	ldi	r24, 0x53	; 83
    1bec:	0e 94 8c 0c 	call	0x1918	; 0x1918 <change_direction>
		move_one_cell();
    1bf0:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <move_one_cell>
		current_coordinate[0]++;
    1bf4:	88 81       	ld	r24, Y
    1bf6:	99 81       	ldd	r25, Y+1	; 0x01
    1bf8:	01 96       	adiw	r24, 0x01	; 1
    1bfa:	99 83       	std	Y+1, r25	; 0x01
    1bfc:	88 83       	st	Y, r24
		change_direction('N');
		move_one_cell();
		current_coordinate[0]--;
	}
	
	while (current_coordinate[0] < target_coordinate[0]) {// go north/south until both position on same row
    1bfe:	f8 01       	movw	r30, r16
    1c00:	20 81       	ld	r18, Z
    1c02:	31 81       	ldd	r19, Z+1	; 0x01
    1c04:	82 17       	cp	r24, r18
    1c06:	93 07       	cpc	r25, r19
    1c08:	84 f3       	brlt	.-32     	; 0x1bea <match_row+0x5a>
		change_direction('S');
		move_one_cell();
		current_coordinate[0]++;
	}
}
    1c0a:	df 91       	pop	r29
    1c0c:	cf 91       	pop	r28
    1c0e:	1f 91       	pop	r17
    1c10:	0f 91       	pop	r16
    1c12:	08 95       	ret

00001c14 <go_to_coordinate>:
 *						else
 *							move the robot and match robot's and target co-ordinate's column
 *							move the robot and match robot's and target co-ordinate's row
 * Example Call:	go_to_coordinate((int){1, 3})
 */
void go_to_coordinate (int target_coordinate[]) {
    1c14:	cf 93       	push	r28
    1c16:	df 93       	push	r29
    1c18:	ec 01       	movw	r28, r24
	if (current_grid == 1) {
    1c1a:	80 91 0a 02 	lds	r24, 0x020A
    1c1e:	90 91 0b 02 	lds	r25, 0x020B
    1c22:	81 30       	cpi	r24, 0x01	; 1
    1c24:	91 05       	cpc	r25, r1
    1c26:	a1 f4       	brne	.+40     	; 0x1c50 <go_to_coordinate+0x3c>
		if (current_direction == 'E' || current_direction == 'W') { // match column then row
    1c28:	80 91 0c 02 	lds	r24, 0x020C
    1c2c:	85 34       	cpi	r24, 0x45	; 69
    1c2e:	11 f0       	breq	.+4      	; 0x1c34 <go_to_coordinate+0x20>
    1c30:	87 35       	cpi	r24, 0x57	; 87
    1c32:	39 f4       	brne	.+14     	; 0x1c42 <go_to_coordinate+0x2e>
			match_column(target_coordinate);
    1c34:	ce 01       	movw	r24, r28
    1c36:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <match_column>
			match_row(target_coordinate);		
    1c3a:	ce 01       	movw	r24, r28
    1c3c:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <match_row>
    1c40:	1d c0       	rjmp	.+58     	; 0x1c7c <go_to_coordinate+0x68>
		} else { // current_direction = N/S  // match row then column
			match_row(target_coordinate);
    1c42:	ce 01       	movw	r24, r28
    1c44:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <match_row>
			match_column(target_coordinate);		
    1c48:	ce 01       	movw	r24, r28
    1c4a:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <match_column>
    1c4e:	16 c0       	rjmp	.+44     	; 0x1c7c <go_to_coordinate+0x68>
		}		
	} else { // if robot is in d2, and target is bridge point, match row, then column
		if (target_coordinate[0] == 2 && target_coordinate[1] == 0) {
    1c50:	88 81       	ld	r24, Y
    1c52:	99 81       	ldd	r25, Y+1	; 0x01
    1c54:	82 30       	cpi	r24, 0x02	; 2
    1c56:	91 05       	cpc	r25, r1
    1c58:	59 f4       	brne	.+22     	; 0x1c70 <go_to_coordinate+0x5c>
    1c5a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c5c:	9b 81       	ldd	r25, Y+3	; 0x03
    1c5e:	00 97       	sbiw	r24, 0x00	; 0
    1c60:	39 f4       	brne	.+14     	; 0x1c70 <go_to_coordinate+0x5c>
			match_row(target_coordinate);
    1c62:	ce 01       	movw	r24, r28
    1c64:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <match_row>
			match_column(target_coordinate);			
    1c68:	ce 01       	movw	r24, r28
    1c6a:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <match_column>
    1c6e:	06 c0       	rjmp	.+12     	; 0x1c7c <go_to_coordinate+0x68>
		} else {
			match_column(target_coordinate);
    1c70:	ce 01       	movw	r24, r28
    1c72:	0e 94 86 0d 	call	0x1b0c	; 0x1b0c <match_column>
			match_row(target_coordinate);
    1c76:	ce 01       	movw	r24, r28
    1c78:	0e 94 c8 0d 	call	0x1b90	; 0x1b90 <match_row>
		}
	}
}
    1c7c:	df 91       	pop	r29
    1c7e:	cf 91       	pop	r28
    1c80:	08 95       	ret

00001c82 <go_to_cell_no>:
 *						to nearest_point. Note that we are using d1_position_map here
 *					else copy returned data from get_nearest_point(current_coordinate, d2_position_map[target_cell_no])
 *						to nearest_point. Note that we are using d2_position_map here this time			
 * Example Call:	go_to_cell_no(2, 5)
 */
void go_to_cell_no (int target_division, int target_cell_no) {
    1c82:	ef 92       	push	r14
    1c84:	ff 92       	push	r15
    1c86:	0f 93       	push	r16
    1c88:	1f 93       	push	r17
    1c8a:	cf 93       	push	r28
    1c8c:	df 93       	push	r29
    1c8e:	ec 01       	movw	r28, r24
    1c90:	7b 01       	movw	r14, r22
	int * nearest_point = (int *) malloc(2 * sizeof(int));
    1c92:	84 e0       	ldi	r24, 0x04	; 4
    1c94:	90 e0       	ldi	r25, 0x00	; 0
    1c96:	0e 94 4c 14 	call	0x2898	; 0x2898 <malloc>
    1c9a:	08 2f       	mov	r16, r24
    1c9c:	19 2f       	mov	r17, r25
	
	if (target_division == 1) { // go to cell no in D1
    1c9e:	c1 30       	cpi	r28, 0x01	; 1
    1ca0:	d1 05       	cpc	r29, r1
    1ca2:	c1 f4       	brne	.+48     	; 0x1cd4 <go_to_cell_no+0x52>
		memcpy(nearest_point, get_nearest_point(current_coordinate, d1_position_map[target_cell_no]), 2 * sizeof(int));
    1ca4:	b7 01       	movw	r22, r14
    1ca6:	62 95       	swap	r22
    1ca8:	72 95       	swap	r23
    1caa:	70 7f       	andi	r23, 0xF0	; 240
    1cac:	76 27       	eor	r23, r22
    1cae:	60 7f       	andi	r22, 0xF0	; 240
    1cb0:	76 27       	eor	r23, r22
    1cb2:	62 57       	subi	r22, 0x72	; 114
    1cb4:	7c 4f       	sbci	r23, 0xFC	; 252
    1cb6:	84 e0       	ldi	r24, 0x04	; 4
    1cb8:	92 e0       	ldi	r25, 0x02	; 2
    1cba:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <get_nearest_point>
    1cbe:	fc 01       	movw	r30, r24
    1cc0:	80 81       	ld	r24, Z
    1cc2:	91 81       	ldd	r25, Z+1	; 0x01
    1cc4:	a2 81       	ldd	r26, Z+2	; 0x02
    1cc6:	b3 81       	ldd	r27, Z+3	; 0x03
    1cc8:	f8 01       	movw	r30, r16
    1cca:	80 83       	st	Z, r24
    1ccc:	91 83       	std	Z+1, r25	; 0x01
    1cce:	a2 83       	std	Z+2, r26	; 0x02
    1cd0:	b3 83       	std	Z+3, r27	; 0x03
    1cd2:	17 c0       	rjmp	.+46     	; 0x1d02 <go_to_cell_no+0x80>
	} else { // go to cell no in D2	
		memcpy(nearest_point, get_nearest_point(current_coordinate, d2_position_map[target_cell_no]), 2 * sizeof(int));
    1cd4:	b7 01       	movw	r22, r14
    1cd6:	62 95       	swap	r22
    1cd8:	72 95       	swap	r23
    1cda:	70 7f       	andi	r23, 0xF0	; 240
    1cdc:	76 27       	eor	r23, r22
    1cde:	60 7f       	andi	r22, 0xF0	; 240
    1ce0:	76 27       	eor	r23, r22
    1ce2:	62 5f       	subi	r22, 0xF2	; 242
    1ce4:	7d 4f       	sbci	r23, 0xFD	; 253
    1ce6:	84 e0       	ldi	r24, 0x04	; 4
    1ce8:	92 e0       	ldi	r25, 0x02	; 2
    1cea:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <get_nearest_point>
    1cee:	fc 01       	movw	r30, r24
    1cf0:	80 81       	ld	r24, Z
    1cf2:	91 81       	ldd	r25, Z+1	; 0x01
    1cf4:	a2 81       	ldd	r26, Z+2	; 0x02
    1cf6:	b3 81       	ldd	r27, Z+3	; 0x03
    1cf8:	f8 01       	movw	r30, r16
    1cfa:	80 83       	st	Z, r24
    1cfc:	91 83       	std	Z+1, r25	; 0x01
    1cfe:	a2 83       	std	Z+2, r26	; 0x02
    1d00:	b3 83       	std	Z+3, r27	; 0x03
	}
	
	go_to_coordinate(nearest_point);
    1d02:	c8 01       	movw	r24, r16
    1d04:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <go_to_coordinate>
	
	// after reaching, update current_cell_no
	current_cell_no = target_cell_no;
    1d08:	f0 92 09 02 	sts	0x0209, r15
    1d0c:	e0 92 08 02 	sts	0x0208, r14
}
    1d10:	df 91       	pop	r29
    1d12:	cf 91       	pop	r28
    1d14:	1f 91       	pop	r17
    1d16:	0f 91       	pop	r16
    1d18:	ff 90       	pop	r15
    1d1a:	ef 90       	pop	r14
    1d1c:	08 95       	ret

00001d1e <get_pickup_direction>:
 *							i = i + 1
 *					if left > right then set pickup direction to 'L' as left
 *					else set pickup direction to 'R' as right
 * Example Call:	get_pickup_direction()
 */
void get_pickup_direction () {
    1d1e:	cf 93       	push	r28
    1d20:	df 93       	push	r29
	int i, left = 0, right = 0;	
	
	if (current_direction == 'N') { // if north, just compare columns
    1d22:	80 91 0c 02 	lds	r24, 0x020C
    1d26:	8e 34       	cpi	r24, 0x4E	; 78
    1d28:	41 f5       	brne	.+80     	; 0x1d7a <get_pickup_direction+0x5c>
		for (i=0; i<4; i++) {
			if (current_coordinate[1] > d1_position_map[current_cell_no][i][1]) left++;
    1d2a:	40 91 06 02 	lds	r20, 0x0206
    1d2e:	50 91 07 02 	lds	r21, 0x0207
 *							i = i + 1
 *					if left > right then set pickup direction to 'L' as left
 *					else set pickup direction to 'R' as right
 * Example Call:	get_pickup_direction()
 */
void get_pickup_direction () {
    1d32:	e0 91 08 02 	lds	r30, 0x0208
    1d36:	f0 91 09 02 	lds	r31, 0x0209
    1d3a:	e2 95       	swap	r30
    1d3c:	f2 95       	swap	r31
    1d3e:	f0 7f       	andi	r31, 0xF0	; 240
    1d40:	fe 27       	eor	r31, r30
    1d42:	e0 7f       	andi	r30, 0xF0	; 240
    1d44:	fe 27       	eor	r31, r30
    1d46:	e0 57       	subi	r30, 0x70	; 112
    1d48:	fc 4f       	sbci	r31, 0xFC	; 252
    1d4a:	a0 e0       	ldi	r26, 0x00	; 0
    1d4c:	b0 e0       	ldi	r27, 0x00	; 0
    1d4e:	c0 e0       	ldi	r28, 0x00	; 0
    1d50:	d0 e0       	ldi	r29, 0x00	; 0
    1d52:	20 e0       	ldi	r18, 0x00	; 0
    1d54:	30 e0       	ldi	r19, 0x00	; 0
	int i, left = 0, right = 0;	
	
	if (current_direction == 'N') { // if north, just compare columns
		for (i=0; i<4; i++) {
			if (current_coordinate[1] > d1_position_map[current_cell_no][i][1]) left++;
    1d56:	80 81       	ld	r24, Z
    1d58:	91 81       	ldd	r25, Z+1	; 0x01
    1d5a:	84 17       	cp	r24, r20
    1d5c:	95 07       	cpc	r25, r21
    1d5e:	14 f4       	brge	.+4      	; 0x1d64 <get_pickup_direction+0x46>
    1d60:	21 96       	adiw	r28, 0x01	; 1
    1d62:	04 c0       	rjmp	.+8      	; 0x1d6c <get_pickup_direction+0x4e>
			else if (current_coordinate[1] < d1_position_map[current_cell_no][i][1]) right++;
    1d64:	48 17       	cp	r20, r24
    1d66:	59 07       	cpc	r21, r25
    1d68:	0c f4       	brge	.+2      	; 0x1d6c <get_pickup_direction+0x4e>
    1d6a:	11 96       	adiw	r26, 0x01	; 1
 */
void get_pickup_direction () {
	int i, left = 0, right = 0;	
	
	if (current_direction == 'N') { // if north, just compare columns
		for (i=0; i<4; i++) {
    1d6c:	2f 5f       	subi	r18, 0xFF	; 255
    1d6e:	3f 4f       	sbci	r19, 0xFF	; 255
    1d70:	34 96       	adiw	r30, 0x04	; 4
    1d72:	24 30       	cpi	r18, 0x04	; 4
    1d74:	31 05       	cpc	r19, r1
    1d76:	79 f7       	brne	.-34     	; 0x1d56 <get_pickup_direction+0x38>
    1d78:	81 c0       	rjmp	.+258    	; 0x1e7c <get_pickup_direction+0x15e>
			if (current_coordinate[1] > d1_position_map[current_cell_no][i][1]) left++;
			else if (current_coordinate[1] < d1_position_map[current_cell_no][i][1]) right++;
		}
	} else if (current_direction == 'S') { // if south, just compare columns
    1d7a:	83 35       	cpi	r24, 0x53	; 83
    1d7c:	41 f5       	brne	.+80     	; 0x1dce <get_pickup_direction+0xb0>
		for (i=0; i<4; i++) {
			if (current_coordinate[1] > d1_position_map[current_cell_no][i][1]) right++;
    1d7e:	40 91 06 02 	lds	r20, 0x0206
    1d82:	50 91 07 02 	lds	r21, 0x0207
 *							i = i + 1
 *					if left > right then set pickup direction to 'L' as left
 *					else set pickup direction to 'R' as right
 * Example Call:	get_pickup_direction()
 */
void get_pickup_direction () {
    1d86:	e0 91 08 02 	lds	r30, 0x0208
    1d8a:	f0 91 09 02 	lds	r31, 0x0209
    1d8e:	e2 95       	swap	r30
    1d90:	f2 95       	swap	r31
    1d92:	f0 7f       	andi	r31, 0xF0	; 240
    1d94:	fe 27       	eor	r31, r30
    1d96:	e0 7f       	andi	r30, 0xF0	; 240
    1d98:	fe 27       	eor	r31, r30
    1d9a:	e0 57       	subi	r30, 0x70	; 112
    1d9c:	fc 4f       	sbci	r31, 0xFC	; 252
    1d9e:	a0 e0       	ldi	r26, 0x00	; 0
    1da0:	b0 e0       	ldi	r27, 0x00	; 0
    1da2:	c0 e0       	ldi	r28, 0x00	; 0
    1da4:	d0 e0       	ldi	r29, 0x00	; 0
    1da6:	20 e0       	ldi	r18, 0x00	; 0
    1da8:	30 e0       	ldi	r19, 0x00	; 0
			if (current_coordinate[1] > d1_position_map[current_cell_no][i][1]) left++;
			else if (current_coordinate[1] < d1_position_map[current_cell_no][i][1]) right++;
		}
	} else if (current_direction == 'S') { // if south, just compare columns
		for (i=0; i<4; i++) {
			if (current_coordinate[1] > d1_position_map[current_cell_no][i][1]) right++;
    1daa:	80 81       	ld	r24, Z
    1dac:	91 81       	ldd	r25, Z+1	; 0x01
    1dae:	84 17       	cp	r24, r20
    1db0:	95 07       	cpc	r25, r21
    1db2:	14 f4       	brge	.+4      	; 0x1db8 <get_pickup_direction+0x9a>
    1db4:	11 96       	adiw	r26, 0x01	; 1
    1db6:	04 c0       	rjmp	.+8      	; 0x1dc0 <get_pickup_direction+0xa2>
			else if (current_coordinate[1] < d1_position_map[current_cell_no][i][1]) left++;
    1db8:	48 17       	cp	r20, r24
    1dba:	59 07       	cpc	r21, r25
    1dbc:	0c f4       	brge	.+2      	; 0x1dc0 <get_pickup_direction+0xa2>
    1dbe:	21 96       	adiw	r28, 0x01	; 1
		for (i=0; i<4; i++) {
			if (current_coordinate[1] > d1_position_map[current_cell_no][i][1]) left++;
			else if (current_coordinate[1] < d1_position_map[current_cell_no][i][1]) right++;
		}
	} else if (current_direction == 'S') { // if south, just compare columns
		for (i=0; i<4; i++) {
    1dc0:	2f 5f       	subi	r18, 0xFF	; 255
    1dc2:	3f 4f       	sbci	r19, 0xFF	; 255
    1dc4:	34 96       	adiw	r30, 0x04	; 4
    1dc6:	24 30       	cpi	r18, 0x04	; 4
    1dc8:	31 05       	cpc	r19, r1
    1dca:	79 f7       	brne	.-34     	; 0x1daa <get_pickup_direction+0x8c>
    1dcc:	57 c0       	rjmp	.+174    	; 0x1e7c <get_pickup_direction+0x15e>
			if (current_coordinate[1] > d1_position_map[current_cell_no][i][1]) right++;
			else if (current_coordinate[1] < d1_position_map[current_cell_no][i][1]) left++;
		}		
	} else if (current_direction == 'E') { // if east, just compare rows
    1dce:	85 34       	cpi	r24, 0x45	; 69
    1dd0:	59 f5       	brne	.+86     	; 0x1e28 <get_pickup_direction+0x10a>
		for (i=0; i<4; i++) {
			if (current_coordinate[0] > d1_position_map[current_cell_no][i][0]) left++;
    1dd2:	40 91 04 02 	lds	r20, 0x0204
    1dd6:	50 91 05 02 	lds	r21, 0x0205
    1dda:	80 91 08 02 	lds	r24, 0x0208
    1dde:	90 91 09 02 	lds	r25, 0x0209
    1de2:	20 e0       	ldi	r18, 0x00	; 0
    1de4:	30 e0       	ldi	r19, 0x00	; 0
    1de6:	a0 e0       	ldi	r26, 0x00	; 0
    1de8:	b0 e0       	ldi	r27, 0x00	; 0
    1dea:	c0 e0       	ldi	r28, 0x00	; 0
    1dec:	d0 e0       	ldi	r29, 0x00	; 0
 *							i = i + 1
 *					if left > right then set pickup direction to 'L' as left
 *					else set pickup direction to 'R' as right
 * Example Call:	get_pickup_direction()
 */
void get_pickup_direction () {
    1dee:	82 95       	swap	r24
    1df0:	92 95       	swap	r25
    1df2:	90 7f       	andi	r25, 0xF0	; 240
    1df4:	98 27       	eor	r25, r24
    1df6:	80 7f       	andi	r24, 0xF0	; 240
    1df8:	98 27       	eor	r25, r24
    1dfa:	bc 01       	movw	r22, r24
    1dfc:	62 57       	subi	r22, 0x72	; 114
    1dfe:	7c 4f       	sbci	r23, 0xFC	; 252
    1e00:	fb 01       	movw	r30, r22
    1e02:	e2 0f       	add	r30, r18
    1e04:	f3 1f       	adc	r31, r19
			if (current_coordinate[1] > d1_position_map[current_cell_no][i][1]) right++;
			else if (current_coordinate[1] < d1_position_map[current_cell_no][i][1]) left++;
		}		
	} else if (current_direction == 'E') { // if east, just compare rows
		for (i=0; i<4; i++) {
			if (current_coordinate[0] > d1_position_map[current_cell_no][i][0]) left++;
    1e06:	80 81       	ld	r24, Z
    1e08:	91 81       	ldd	r25, Z+1	; 0x01
    1e0a:	84 17       	cp	r24, r20
    1e0c:	95 07       	cpc	r25, r21
    1e0e:	14 f4       	brge	.+4      	; 0x1e14 <get_pickup_direction+0xf6>
    1e10:	21 96       	adiw	r28, 0x01	; 1
    1e12:	04 c0       	rjmp	.+8      	; 0x1e1c <get_pickup_direction+0xfe>
			else if (current_coordinate[0] < d1_position_map[current_cell_no][i][0]) right++;
    1e14:	48 17       	cp	r20, r24
    1e16:	59 07       	cpc	r21, r25
    1e18:	0c f4       	brge	.+2      	; 0x1e1c <get_pickup_direction+0xfe>
    1e1a:	11 96       	adiw	r26, 0x01	; 1
    1e1c:	2c 5f       	subi	r18, 0xFC	; 252
    1e1e:	3f 4f       	sbci	r19, 0xFF	; 255
		for (i=0; i<4; i++) {
			if (current_coordinate[1] > d1_position_map[current_cell_no][i][1]) right++;
			else if (current_coordinate[1] < d1_position_map[current_cell_no][i][1]) left++;
		}		
	} else if (current_direction == 'E') { // if east, just compare rows
		for (i=0; i<4; i++) {
    1e20:	20 31       	cpi	r18, 0x10	; 16
    1e22:	31 05       	cpc	r19, r1
    1e24:	69 f7       	brne	.-38     	; 0x1e00 <get_pickup_direction+0xe2>
    1e26:	2a c0       	rjmp	.+84     	; 0x1e7c <get_pickup_direction+0x15e>
			if (current_coordinate[0] > d1_position_map[current_cell_no][i][0]) left++;
			else if (current_coordinate[0] < d1_position_map[current_cell_no][i][0]) right++;
		}		
	} else { // if west, just compare rows
		for (i=0; i<4; i++) {
			if (current_coordinate[0] > d1_position_map[current_cell_no][i][0]) right++;
    1e28:	40 91 04 02 	lds	r20, 0x0204
    1e2c:	50 91 05 02 	lds	r21, 0x0205
    1e30:	80 91 08 02 	lds	r24, 0x0208
    1e34:	90 91 09 02 	lds	r25, 0x0209
    1e38:	20 e0       	ldi	r18, 0x00	; 0
    1e3a:	30 e0       	ldi	r19, 0x00	; 0
    1e3c:	a0 e0       	ldi	r26, 0x00	; 0
    1e3e:	b0 e0       	ldi	r27, 0x00	; 0
    1e40:	c0 e0       	ldi	r28, 0x00	; 0
    1e42:	d0 e0       	ldi	r29, 0x00	; 0
 *							i = i + 1
 *					if left > right then set pickup direction to 'L' as left
 *					else set pickup direction to 'R' as right
 * Example Call:	get_pickup_direction()
 */
void get_pickup_direction () {
    1e44:	82 95       	swap	r24
    1e46:	92 95       	swap	r25
    1e48:	90 7f       	andi	r25, 0xF0	; 240
    1e4a:	98 27       	eor	r25, r24
    1e4c:	80 7f       	andi	r24, 0xF0	; 240
    1e4e:	98 27       	eor	r25, r24
    1e50:	bc 01       	movw	r22, r24
    1e52:	62 57       	subi	r22, 0x72	; 114
    1e54:	7c 4f       	sbci	r23, 0xFC	; 252
    1e56:	fb 01       	movw	r30, r22
    1e58:	e2 0f       	add	r30, r18
    1e5a:	f3 1f       	adc	r31, r19
			if (current_coordinate[0] > d1_position_map[current_cell_no][i][0]) left++;
			else if (current_coordinate[0] < d1_position_map[current_cell_no][i][0]) right++;
		}		
	} else { // if west, just compare rows
		for (i=0; i<4; i++) {
			if (current_coordinate[0] > d1_position_map[current_cell_no][i][0]) right++;
    1e5c:	80 81       	ld	r24, Z
    1e5e:	91 81       	ldd	r25, Z+1	; 0x01
    1e60:	84 17       	cp	r24, r20
    1e62:	95 07       	cpc	r25, r21
    1e64:	14 f4       	brge	.+4      	; 0x1e6a <get_pickup_direction+0x14c>
    1e66:	11 96       	adiw	r26, 0x01	; 1
    1e68:	04 c0       	rjmp	.+8      	; 0x1e72 <get_pickup_direction+0x154>
			else if (current_coordinate[0] < d1_position_map[current_cell_no][i][0]) left++;
    1e6a:	48 17       	cp	r20, r24
    1e6c:	59 07       	cpc	r21, r25
    1e6e:	0c f4       	brge	.+2      	; 0x1e72 <get_pickup_direction+0x154>
    1e70:	21 96       	adiw	r28, 0x01	; 1
    1e72:	2c 5f       	subi	r18, 0xFC	; 252
    1e74:	3f 4f       	sbci	r19, 0xFF	; 255
		for (i=0; i<4; i++) {
			if (current_coordinate[0] > d1_position_map[current_cell_no][i][0]) left++;
			else if (current_coordinate[0] < d1_position_map[current_cell_no][i][0]) right++;
		}		
	} else { // if west, just compare rows
		for (i=0; i<4; i++) {
    1e76:	20 31       	cpi	r18, 0x10	; 16
    1e78:	31 05       	cpc	r19, r1
    1e7a:	69 f7       	brne	.-38     	; 0x1e56 <get_pickup_direction+0x138>
			if (current_coordinate[0] > d1_position_map[current_cell_no][i][0]) right++;
			else if (current_coordinate[0] < d1_position_map[current_cell_no][i][0]) left++;
		}		
	}
	
	if (left > right) pickup_direction = 'L';
    1e7c:	ac 17       	cp	r26, r28
    1e7e:	bd 07       	cpc	r27, r29
    1e80:	24 f4       	brge	.+8      	; 0x1e8a <get_pickup_direction+0x16c>
    1e82:	8c e4       	ldi	r24, 0x4C	; 76
    1e84:	80 93 74 13 	sts	0x1374, r24
    1e88:	03 c0       	rjmp	.+6      	; 0x1e90 <get_pickup_direction+0x172>
	else pickup_direction = 'R';
    1e8a:	82 e5       	ldi	r24, 0x52	; 82
    1e8c:	80 93 74 13 	sts	0x1374, r24
}
    1e90:	df 91       	pop	r29
    1e92:	cf 91       	pop	r28
    1e94:	08 95       	ret

00001e96 <pickup>:
 *					After that clear GLCD screen and display the number we have picked up and delay for 500 ms
 *					Then, if skip_over is equals to 1 then call move_one_cell()
 *					else follow black line forward for 25 mm by follow_black_line_mm(25, 'B')
 * Example Call:	pickup(9, 1)
 */
void pickup (int num, int skip_over) {
    1e96:	0f 93       	push	r16
    1e98:	1f 93       	push	r17
    1e9a:	cf 93       	push	r28
    1e9c:	df 93       	push	r29
    1e9e:	8c 01       	movw	r16, r24
    1ea0:	eb 01       	movw	r28, r22
	follow_black_line_mm(50, 'F');
    1ea2:	82 e3       	ldi	r24, 0x32	; 50
    1ea4:	90 e0       	ldi	r25, 0x00	; 0
    1ea6:	66 e4       	ldi	r22, 0x46	; 70
    1ea8:	0e 94 df 0b 	call	0x17be	; 0x17be <follow_black_line_mm>
	
	get_pickup_direction();
    1eac:	0e 94 8f 0e 	call	0x1d1e	; 0x1d1e <get_pickup_direction>
	
	// turn on the left/right led
	if (pickup_direction == 'L') left_led_on();
    1eb0:	80 91 74 13 	lds	r24, 0x1374
    1eb4:	8c 34       	cpi	r24, 0x4C	; 76
    1eb6:	19 f4       	brne	.+6      	; 0x1ebe <pickup+0x28>
    1eb8:	0e 94 b9 0a 	call	0x1572	; 0x1572 <left_led_on>
    1ebc:	02 c0       	rjmp	.+4      	; 0x1ec2 <pickup+0x2c>
	else right_led_on();
    1ebe:	0e 94 c1 0a 	call	0x1582	; 0x1582 <right_led_on>
	
	GLCD_Clear();
    1ec2:	0e 94 5d 04 	call	0x8ba	; 0x8ba <GLCD_Clear>
	GLCD_DisplayBitmap(num); // show the num in big ubuntu font
    1ec6:	c8 01       	movw	r24, r16
    1ec8:	0e 94 b4 07 	call	0xf68	; 0xf68 <GLCD_DisplayBitmap>
    1ecc:	8f ef       	ldi	r24, 0xFF	; 255
    1ece:	9f e7       	ldi	r25, 0x7F	; 127
    1ed0:	a6 e1       	ldi	r26, 0x16	; 22
    1ed2:	81 50       	subi	r24, 0x01	; 1
    1ed4:	90 40       	sbci	r25, 0x00	; 0
    1ed6:	a0 40       	sbci	r26, 0x00	; 0
    1ed8:	e1 f7       	brne	.-8      	; 0x1ed2 <pickup+0x3c>
    1eda:	00 c0       	rjmp	.+0      	; 0x1edc <pickup+0x46>
    1edc:	00 00       	nop
	
	_delay_ms(500);
	
	if (skip_over == 1) {
    1ede:	c1 30       	cpi	r28, 0x01	; 1
    1ee0:	d1 05       	cpc	r29, r1
    1ee2:	19 f4       	brne	.+6      	; 0x1eea <pickup+0x54>
		move_one_cell();
    1ee4:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <move_one_cell>
    1ee8:	05 c0       	rjmp	.+10     	; 0x1ef4 <pickup+0x5e>
	} else {
		follow_black_line_mm(25, 'B');
    1eea:	89 e1       	ldi	r24, 0x19	; 25
    1eec:	90 e0       	ldi	r25, 0x00	; 0
    1eee:	62 e4       	ldi	r22, 0x42	; 66
    1ef0:	0e 94 df 0b 	call	0x17be	; 0x17be <follow_black_line_mm>
	}
}
    1ef4:	df 91       	pop	r29
    1ef6:	cf 91       	pop	r28
    1ef8:	1f 91       	pop	r17
    1efa:	0f 91       	pop	r16
    1efc:	08 95       	ret

00001efe <deposit>:
 *					else delay for 1000 ms
 *					After all these steps, clear the GLCD
 *					If isEnd is equal to 0 then follow black line in backward direction for 25 mm
 * Example Call:	deposit(1, 0)
 */
void deposit (int completed, int isEnd) {	
    1efe:	0f 93       	push	r16
    1f00:	1f 93       	push	r17
    1f02:	cf 93       	push	r28
    1f04:	df 93       	push	r29
    1f06:	8c 01       	movw	r16, r24
    1f08:	eb 01       	movw	r28, r22
	if ((current_coordinate[0] == d2_position_map[current_cell_no][0][0]) && // current_coordinate is on top left of the cell
    1f0a:	40 91 04 02 	lds	r20, 0x0204
    1f0e:	50 91 05 02 	lds	r21, 0x0205
    1f12:	20 91 08 02 	lds	r18, 0x0208
    1f16:	30 91 09 02 	lds	r19, 0x0209
    1f1a:	f9 01       	movw	r30, r18
    1f1c:	e2 95       	swap	r30
    1f1e:	f2 95       	swap	r31
    1f20:	f0 7f       	andi	r31, 0xF0	; 240
    1f22:	fe 27       	eor	r31, r30
    1f24:	e0 7f       	andi	r30, 0xF0	; 240
    1f26:	fe 27       	eor	r31, r30
    1f28:	e2 5f       	subi	r30, 0xF2	; 242
    1f2a:	fd 4f       	sbci	r31, 0xFD	; 253
    1f2c:	80 81       	ld	r24, Z
    1f2e:	91 81       	ldd	r25, Z+1	; 0x01
    1f30:	48 17       	cp	r20, r24
    1f32:	59 07       	cpc	r21, r25
    1f34:	f1 f4       	brne	.+60     	; 0x1f72 <deposit+0x74>
	(current_coordinate[1] == d2_position_map[current_cell_no][0][1])) {
    1f36:	f9 01       	movw	r30, r18
    1f38:	e2 95       	swap	r30
    1f3a:	f2 95       	swap	r31
    1f3c:	f0 7f       	andi	r31, 0xF0	; 240
    1f3e:	fe 27       	eor	r31, r30
    1f40:	e0 7f       	andi	r30, 0xF0	; 240
    1f42:	fe 27       	eor	r31, r30
    1f44:	e2 5f       	subi	r30, 0xF2	; 242
    1f46:	fd 4f       	sbci	r31, 0xFD	; 253
 *					After all these steps, clear the GLCD
 *					If isEnd is equal to 0 then follow black line in backward direction for 25 mm
 * Example Call:	deposit(1, 0)
 */
void deposit (int completed, int isEnd) {	
	if ((current_coordinate[0] == d2_position_map[current_cell_no][0][0]) && // current_coordinate is on top left of the cell
    1f48:	60 91 06 02 	lds	r22, 0x0206
    1f4c:	70 91 07 02 	lds	r23, 0x0207
    1f50:	82 81       	ldd	r24, Z+2	; 0x02
    1f52:	93 81       	ldd	r25, Z+3	; 0x03
    1f54:	68 17       	cp	r22, r24
    1f56:	79 07       	cpc	r23, r25
    1f58:	61 f4       	brne	.+24     	; 0x1f72 <deposit+0x74>
	(current_coordinate[1] == d2_position_map[current_cell_no][0][1])) {
		if (pickup_direction == 'L') change_direction('S');
    1f5a:	80 91 74 13 	lds	r24, 0x1374
    1f5e:	8c 34       	cpi	r24, 0x4C	; 76
    1f60:	21 f4       	brne	.+8      	; 0x1f6a <deposit+0x6c>
    1f62:	83 e5       	ldi	r24, 0x53	; 83
    1f64:	0e 94 8c 0c 	call	0x1918	; 0x1918 <change_direction>
    1f68:	87 c0       	rjmp	.+270    	; 0x2078 <deposit+0x17a>
		else change_direction('E');
    1f6a:	85 e4       	ldi	r24, 0x45	; 69
    1f6c:	0e 94 8c 0c 	call	0x1918	; 0x1918 <change_direction>
    1f70:	83 c0       	rjmp	.+262    	; 0x2078 <deposit+0x17a>
	} else if ((current_coordinate[0] == d2_position_map[current_cell_no][1][0]) && // current_coordinate is on top right of the cell
    1f72:	f9 01       	movw	r30, r18
    1f74:	e2 95       	swap	r30
    1f76:	f2 95       	swap	r31
    1f78:	f0 7f       	andi	r31, 0xF0	; 240
    1f7a:	fe 27       	eor	r31, r30
    1f7c:	e0 7f       	andi	r30, 0xF0	; 240
    1f7e:	fe 27       	eor	r31, r30
    1f80:	e2 5f       	subi	r30, 0xF2	; 242
    1f82:	fd 4f       	sbci	r31, 0xFD	; 253
    1f84:	84 81       	ldd	r24, Z+4	; 0x04
    1f86:	95 81       	ldd	r25, Z+5	; 0x05
    1f88:	48 17       	cp	r20, r24
    1f8a:	59 07       	cpc	r21, r25
    1f8c:	f1 f4       	brne	.+60     	; 0x1fca <deposit+0xcc>
	(current_coordinate[1] == d2_position_map[current_cell_no][1][1])) {
    1f8e:	f9 01       	movw	r30, r18
    1f90:	e2 95       	swap	r30
    1f92:	f2 95       	swap	r31
    1f94:	f0 7f       	andi	r31, 0xF0	; 240
    1f96:	fe 27       	eor	r31, r30
    1f98:	e0 7f       	andi	r30, 0xF0	; 240
    1f9a:	fe 27       	eor	r31, r30
    1f9c:	e2 5f       	subi	r30, 0xF2	; 242
    1f9e:	fd 4f       	sbci	r31, 0xFD	; 253
void deposit (int completed, int isEnd) {	
	if ((current_coordinate[0] == d2_position_map[current_cell_no][0][0]) && // current_coordinate is on top left of the cell
	(current_coordinate[1] == d2_position_map[current_cell_no][0][1])) {
		if (pickup_direction == 'L') change_direction('S');
		else change_direction('E');
	} else if ((current_coordinate[0] == d2_position_map[current_cell_no][1][0]) && // current_coordinate is on top right of the cell
    1fa0:	60 91 06 02 	lds	r22, 0x0206
    1fa4:	70 91 07 02 	lds	r23, 0x0207
    1fa8:	86 81       	ldd	r24, Z+6	; 0x06
    1faa:	97 81       	ldd	r25, Z+7	; 0x07
    1fac:	68 17       	cp	r22, r24
    1fae:	79 07       	cpc	r23, r25
    1fb0:	61 f4       	brne	.+24     	; 0x1fca <deposit+0xcc>
	(current_coordinate[1] == d2_position_map[current_cell_no][1][1])) {
		if (pickup_direction == 'L') change_direction('W');
    1fb2:	80 91 74 13 	lds	r24, 0x1374
    1fb6:	8c 34       	cpi	r24, 0x4C	; 76
    1fb8:	21 f4       	brne	.+8      	; 0x1fc2 <deposit+0xc4>
    1fba:	87 e5       	ldi	r24, 0x57	; 87
    1fbc:	0e 94 8c 0c 	call	0x1918	; 0x1918 <change_direction>
    1fc0:	5b c0       	rjmp	.+182    	; 0x2078 <deposit+0x17a>
		else change_direction('S');
    1fc2:	83 e5       	ldi	r24, 0x53	; 83
    1fc4:	0e 94 8c 0c 	call	0x1918	; 0x1918 <change_direction>
    1fc8:	57 c0       	rjmp	.+174    	; 0x2078 <deposit+0x17a>
	} else if ((current_coordinate[0] == d2_position_map[current_cell_no][2][0]) && // current_coordinate is on bottom right of the cell
    1fca:	f9 01       	movw	r30, r18
    1fcc:	e2 95       	swap	r30
    1fce:	f2 95       	swap	r31
    1fd0:	f0 7f       	andi	r31, 0xF0	; 240
    1fd2:	fe 27       	eor	r31, r30
    1fd4:	e0 7f       	andi	r30, 0xF0	; 240
    1fd6:	fe 27       	eor	r31, r30
    1fd8:	e2 5f       	subi	r30, 0xF2	; 242
    1fda:	fd 4f       	sbci	r31, 0xFD	; 253
    1fdc:	80 85       	ldd	r24, Z+8	; 0x08
    1fde:	91 85       	ldd	r25, Z+9	; 0x09
    1fe0:	48 17       	cp	r20, r24
    1fe2:	59 07       	cpc	r21, r25
    1fe4:	f1 f4       	brne	.+60     	; 0x2022 <deposit+0x124>
	(current_coordinate[1] == d2_position_map[current_cell_no][2][1])) {
    1fe6:	f9 01       	movw	r30, r18
    1fe8:	e2 95       	swap	r30
    1fea:	f2 95       	swap	r31
    1fec:	f0 7f       	andi	r31, 0xF0	; 240
    1fee:	fe 27       	eor	r31, r30
    1ff0:	e0 7f       	andi	r30, 0xF0	; 240
    1ff2:	fe 27       	eor	r31, r30
    1ff4:	e2 5f       	subi	r30, 0xF2	; 242
    1ff6:	fd 4f       	sbci	r31, 0xFD	; 253
		else change_direction('E');
	} else if ((current_coordinate[0] == d2_position_map[current_cell_no][1][0]) && // current_coordinate is on top right of the cell
	(current_coordinate[1] == d2_position_map[current_cell_no][1][1])) {
		if (pickup_direction == 'L') change_direction('W');
		else change_direction('S');
	} else if ((current_coordinate[0] == d2_position_map[current_cell_no][2][0]) && // current_coordinate is on bottom right of the cell
    1ff8:	60 91 06 02 	lds	r22, 0x0206
    1ffc:	70 91 07 02 	lds	r23, 0x0207
    2000:	82 85       	ldd	r24, Z+10	; 0x0a
    2002:	93 85       	ldd	r25, Z+11	; 0x0b
    2004:	68 17       	cp	r22, r24
    2006:	79 07       	cpc	r23, r25
    2008:	61 f4       	brne	.+24     	; 0x2022 <deposit+0x124>
	(current_coordinate[1] == d2_position_map[current_cell_no][2][1])) {
		if (pickup_direction == 'L') change_direction('N');
    200a:	80 91 74 13 	lds	r24, 0x1374
    200e:	8c 34       	cpi	r24, 0x4C	; 76
    2010:	21 f4       	brne	.+8      	; 0x201a <deposit+0x11c>
    2012:	8e e4       	ldi	r24, 0x4E	; 78
    2014:	0e 94 8c 0c 	call	0x1918	; 0x1918 <change_direction>
    2018:	2f c0       	rjmp	.+94     	; 0x2078 <deposit+0x17a>
		else change_direction('W');
    201a:	87 e5       	ldi	r24, 0x57	; 87
    201c:	0e 94 8c 0c 	call	0x1918	; 0x1918 <change_direction>
    2020:	2b c0       	rjmp	.+86     	; 0x2078 <deposit+0x17a>
	} else if ((current_coordinate[0] == d2_position_map[current_cell_no][3][0]) && // current_coordinate is on bottom left of the cell
    2022:	f9 01       	movw	r30, r18
    2024:	e2 95       	swap	r30
    2026:	f2 95       	swap	r31
    2028:	f0 7f       	andi	r31, 0xF0	; 240
    202a:	fe 27       	eor	r31, r30
    202c:	e0 7f       	andi	r30, 0xF0	; 240
    202e:	fe 27       	eor	r31, r30
    2030:	e2 5f       	subi	r30, 0xF2	; 242
    2032:	fd 4f       	sbci	r31, 0xFD	; 253
    2034:	84 85       	ldd	r24, Z+12	; 0x0c
    2036:	95 85       	ldd	r25, Z+13	; 0x0d
    2038:	48 17       	cp	r20, r24
    203a:	59 07       	cpc	r21, r25
    203c:	e9 f4       	brne	.+58     	; 0x2078 <deposit+0x17a>
	(current_coordinate[1] == d2_position_map[current_cell_no][3][1])) {
    203e:	22 95       	swap	r18
    2040:	32 95       	swap	r19
    2042:	30 7f       	andi	r19, 0xF0	; 240
    2044:	32 27       	eor	r19, r18
    2046:	20 7f       	andi	r18, 0xF0	; 240
    2048:	32 27       	eor	r19, r18
    204a:	f9 01       	movw	r30, r18
    204c:	e2 5f       	subi	r30, 0xF2	; 242
    204e:	fd 4f       	sbci	r31, 0xFD	; 253
		else change_direction('S');
	} else if ((current_coordinate[0] == d2_position_map[current_cell_no][2][0]) && // current_coordinate is on bottom right of the cell
	(current_coordinate[1] == d2_position_map[current_cell_no][2][1])) {
		if (pickup_direction == 'L') change_direction('N');
		else change_direction('W');
	} else if ((current_coordinate[0] == d2_position_map[current_cell_no][3][0]) && // current_coordinate is on bottom left of the cell
    2050:	20 91 06 02 	lds	r18, 0x0206
    2054:	30 91 07 02 	lds	r19, 0x0207
    2058:	86 85       	ldd	r24, Z+14	; 0x0e
    205a:	97 85       	ldd	r25, Z+15	; 0x0f
    205c:	28 17       	cp	r18, r24
    205e:	39 07       	cpc	r19, r25
    2060:	59 f4       	brne	.+22     	; 0x2078 <deposit+0x17a>
	(current_coordinate[1] == d2_position_map[current_cell_no][3][1])) {
		if (pickup_direction == 'L') change_direction('E');
    2062:	80 91 74 13 	lds	r24, 0x1374
    2066:	8c 34       	cpi	r24, 0x4C	; 76
    2068:	21 f4       	brne	.+8      	; 0x2072 <deposit+0x174>
    206a:	85 e4       	ldi	r24, 0x45	; 69
    206c:	0e 94 8c 0c 	call	0x1918	; 0x1918 <change_direction>
    2070:	03 c0       	rjmp	.+6      	; 0x2078 <deposit+0x17a>
		else change_direction('N');
    2072:	8e e4       	ldi	r24, 0x4E	; 78
    2074:	0e 94 8c 0c 	call	0x1918	; 0x1918 <change_direction>
	}
	
	follow_black_line_mm(50, 'F');	
    2078:	82 e3       	ldi	r24, 0x32	; 50
    207a:	90 e0       	ldi	r25, 0x00	; 0
    207c:	66 e4       	ldi	r22, 0x46	; 70
    207e:	0e 94 df 0b 	call	0x17be	; 0x17be <follow_black_line_mm>
	
	//turn off led
	if (pickup_direction == 'L') left_led_off();
    2082:	80 91 74 13 	lds	r24, 0x1374
    2086:	8c 34       	cpi	r24, 0x4C	; 76
    2088:	19 f4       	brne	.+6      	; 0x2090 <deposit+0x192>
    208a:	0e 94 bd 0a 	call	0x157a	; 0x157a <left_led_off>
    208e:	02 c0       	rjmp	.+4      	; 0x2094 <deposit+0x196>
	else right_led_off();
    2090:	0e 94 c5 0a 	call	0x158a	; 0x158a <right_led_off>
	
	GLCD_Clear();
    2094:	0e 94 5d 04 	call	0x8ba	; 0x8ba <GLCD_Clear>
	GLCD_DisplayBitmap(-1); // show DEPOSIT message in big font
    2098:	8f ef       	ldi	r24, 0xFF	; 255
    209a:	9f ef       	ldi	r25, 0xFF	; 255
    209c:	0e 94 b4 07 	call	0xf68	; 0xf68 <GLCD_DisplayBitmap>
	
	if (completed == 1 && isEnd == 0) { // 1000ms buzzer if number in D2 completed but task is not
    20a0:	01 30       	cpi	r16, 0x01	; 1
    20a2:	11 05       	cpc	r17, r1
    20a4:	c1 f4       	brne	.+48     	; 0x20d6 <deposit+0x1d8>
    20a6:	20 97       	sbiw	r28, 0x00	; 0
    20a8:	81 f4       	brne	.+32     	; 0x20ca <deposit+0x1cc>
		buzzer_on();
    20aa:	0e 94 b3 08 	call	0x1166	; 0x1166 <buzzer_on>
    20ae:	8f ef       	ldi	r24, 0xFF	; 255
    20b0:	9f ef       	ldi	r25, 0xFF	; 255
    20b2:	ac e2       	ldi	r26, 0x2C	; 44
    20b4:	81 50       	subi	r24, 0x01	; 1
    20b6:	90 40       	sbci	r25, 0x00	; 0
    20b8:	a0 40       	sbci	r26, 0x00	; 0
    20ba:	e1 f7       	brne	.-8      	; 0x20b4 <deposit+0x1b6>
    20bc:	00 c0       	rjmp	.+0      	; 0x20be <deposit+0x1c0>
    20be:	00 00       	nop
		_delay_ms(1000);
		buzzer_off();
    20c0:	0e 94 b7 08 	call	0x116e	; 0x116e <buzzer_off>
		buzzer_on();
		while(1);
	} else {
		_delay_ms(1000);
	}
	GLCD_Clear();
    20c4:	0e 94 5d 04 	call	0x8ba	; 0x8ba <GLCD_Clear>
    20c8:	13 c0       	rjmp	.+38     	; 0x20f0 <deposit+0x1f2>
	
	if (completed == 1 && isEnd == 0) { // 1000ms buzzer if number in D2 completed but task is not
		buzzer_on();
		_delay_ms(1000);
		buzzer_off();
	} else if (completed == 1 && isEnd == 1) { // the robot has finished the task
    20ca:	c1 30       	cpi	r28, 0x01	; 1
    20cc:	d1 05       	cpc	r29, r1
    20ce:	b1 f4       	brne	.+44     	; 0x20fc <deposit+0x1fe>
		// continuous buzzer
		buzzer_on();
    20d0:	0e 94 b3 08 	call	0x1166	; 0x1166 <buzzer_on>
    20d4:	ff cf       	rjmp	.-2      	; 0x20d4 <deposit+0x1d6>
    20d6:	8f ef       	ldi	r24, 0xFF	; 255
    20d8:	9f ef       	ldi	r25, 0xFF	; 255
    20da:	ac e2       	ldi	r26, 0x2C	; 44
    20dc:	81 50       	subi	r24, 0x01	; 1
    20de:	90 40       	sbci	r25, 0x00	; 0
    20e0:	a0 40       	sbci	r26, 0x00	; 0
    20e2:	e1 f7       	brne	.-8      	; 0x20dc <deposit+0x1de>
    20e4:	00 c0       	rjmp	.+0      	; 0x20e6 <deposit+0x1e8>
    20e6:	00 00       	nop
		while(1);
	} else {
		_delay_ms(1000);
	}
	GLCD_Clear();
    20e8:	0e 94 5d 04 	call	0x8ba	; 0x8ba <GLCD_Clear>
	
	if (isEnd == 0) { // the robot has not finished the task yet
    20ec:	20 97       	sbiw	r28, 0x00	; 0
    20ee:	89 f4       	brne	.+34     	; 0x2112 <deposit+0x214>
		follow_black_line_mm(25, 'B');
    20f0:	89 e1       	ldi	r24, 0x19	; 25
    20f2:	90 e0       	ldi	r25, 0x00	; 0
    20f4:	62 e4       	ldi	r22, 0x42	; 66
    20f6:	0e 94 df 0b 	call	0x17be	; 0x17be <follow_black_line_mm>
    20fa:	0b c0       	rjmp	.+22     	; 0x2112 <deposit+0x214>
    20fc:	8f ef       	ldi	r24, 0xFF	; 255
    20fe:	9f ef       	ldi	r25, 0xFF	; 255
    2100:	ac e2       	ldi	r26, 0x2C	; 44
    2102:	81 50       	subi	r24, 0x01	; 1
    2104:	90 40       	sbci	r25, 0x00	; 0
    2106:	a0 40       	sbci	r26, 0x00	; 0
    2108:	e1 f7       	brne	.-8      	; 0x2102 <deposit+0x204>
    210a:	00 c0       	rjmp	.+0      	; 0x210c <deposit+0x20e>
    210c:	00 00       	nop
		buzzer_on();
		while(1);
	} else {
		_delay_ms(1000);
	}
	GLCD_Clear();
    210e:	0e 94 5d 04 	call	0x8ba	; 0x8ba <GLCD_Clear>
	
	if (isEnd == 0) { // the robot has not finished the task yet
		follow_black_line_mm(25, 'B');
	}
}
    2112:	df 91       	pop	r29
    2114:	cf 91       	pop	r28
    2116:	1f 91       	pop	r17
    2118:	0f 91       	pop	r16
    211a:	08 95       	ret

0000211c <main>:
 *									sum = 0
 *								Else, deposit as number in D2 is not completed and whole task is not completed as well.
 *								If i+2 th element in path_points is -1, then continuous buzzer as robot has finished the task.
 * Example Call:	Called automatically by the Operating System
 */
int main() {
    211c:	2f 92       	push	r2
    211e:	3f 92       	push	r3
    2120:	4f 92       	push	r4
    2122:	5f 92       	push	r5
    2124:	6f 92       	push	r6
    2126:	7f 92       	push	r7
    2128:	8f 92       	push	r8
    212a:	9f 92       	push	r9
    212c:	af 92       	push	r10
    212e:	bf 92       	push	r11
    2130:	cf 92       	push	r12
    2132:	df 92       	push	r13
    2134:	ef 92       	push	r14
    2136:	ff 92       	push	r15
    2138:	0f 93       	push	r16
    213a:	1f 93       	push	r17
    213c:	cf 93       	push	r28
    213e:	df 93       	push	r29
    2140:	cd b7       	in	r28, 0x3d	; 61
    2142:	de b7       	in	r29, 0x3e	; 62
    2144:	c2 5d       	subi	r28, 0xD2	; 210
    2146:	d0 40       	sbci	r29, 0x00	; 0
    2148:	0f b6       	in	r0, 0x3f	; 63
    214a:	f8 94       	cli
    214c:	de bf       	out	0x3e, r29	; 62
    214e:	0f be       	out	0x3f, r0	; 63
    2150:	cd bf       	out	0x3d, r28	; 61
	init_devices();
    2152:	0e 94 a4 0a 	call	0x1548	; 0x1548 <init_devices>
	
	// make the robot busy until detecting boot switch i.e. interrupt is pressed
	while (1) {
		if((PINE | 0x7F) == 0x7F) { // interrupt switch is pressed
    2156:	8c b1       	in	r24, 0x0c	; 12
    2158:	8f 67       	ori	r24, 0x7F	; 127
    215a:	8f 37       	cpi	r24, 0x7F	; 127
    215c:	e1 f7       	brne	.-8      	; 0x2156 <main+0x3a>
    215e:	0f 2e       	mov	r0, r31
    2160:	f9 e0       	ldi	r31, 0x09	; 9
    2162:	cf 2e       	mov	r12, r31
    2164:	dd 24       	eor	r13, r13
    2166:	f0 2d       	mov	r31, r0
    2168:	cc 0e       	add	r12, r28
    216a:	dd 1e       	adc	r13, r29
 *									sum = 0
 *								Else, deposit as number in D2 is not completed and whole task is not completed as well.
 *								If i+2 th element in path_points is -1, then continuous buzzer as robot has finished the task.
 * Example Call:	Called automatically by the Operating System
 */
int main() {
    216c:	0f 2e       	mov	r0, r31
    216e:	f1 ed       	ldi	r31, 0xD1	; 209
    2170:	af 2e       	mov	r10, r31
    2172:	bb 24       	eor	r11, r11
    2174:	f0 2d       	mov	r31, r0
    2176:	ac 0e       	add	r10, r28
    2178:	bd 1e       	adc	r11, r29
    217a:	f6 01       	movw	r30, r12
	
	/*************************** converting input string to int array start ****************************/
	//	it must be done after pressing the interrupt key else data will be lost
	int i, j;
	int path_points[100]; // -1 refers to invalid/null point; odd index = the point is in D1, even index = the point is in D2
	for (i=0; i<100; i++) path_points[i] = -1;
    217c:	8f ef       	ldi	r24, 0xFF	; 255
    217e:	9f ef       	ldi	r25, 0xFF	; 255
    2180:	81 93       	st	Z+, r24
    2182:	91 93       	st	Z+, r25
    2184:	ea 15       	cp	r30, r10
    2186:	fb 05       	cpc	r31, r11
    2188:	d9 f7       	brne	.-10     	; 0x2180 <main+0x64>
	
    char * token;
	token = strtok(input_str, ",");
    218a:	85 e7       	ldi	r24, 0x75	; 117
    218c:	93 e1       	ldi	r25, 0x13	; 19
    218e:	60 e0       	ldi	r22, 0x00	; 0
    2190:	72 e0       	ldi	r23, 0x02	; 2
    2192:	0e 94 99 15 	call	0x2b32	; 0x2b32 <strtok>
	i = 0;
	while (token != '\0') {
    2196:	00 97       	sbiw	r24, 0x00	; 0
    2198:	a1 f0       	breq	.+40     	; 0x21c2 <main+0xa6>
    219a:	86 01       	movw	r16, r12
		path_points[i++] = atoi((char *)token);
		token = strtok('\0', ",");
    219c:	0f 2e       	mov	r0, r31
    219e:	f0 e0       	ldi	r31, 0x00	; 0
    21a0:	ef 2e       	mov	r14, r31
    21a2:	f2 e0       	ldi	r31, 0x02	; 2
    21a4:	ff 2e       	mov	r15, r31
    21a6:	f0 2d       	mov	r31, r0
	
    char * token;
	token = strtok(input_str, ",");
	i = 0;
	while (token != '\0') {
		path_points[i++] = atoi((char *)token);
    21a8:	0e 94 7b 15 	call	0x2af6	; 0x2af6 <atoi>
    21ac:	d8 01       	movw	r26, r16
    21ae:	8d 93       	st	X+, r24
    21b0:	9d 93       	st	X+, r25
    21b2:	8d 01       	movw	r16, r26
		token = strtok('\0', ",");
    21b4:	80 e0       	ldi	r24, 0x00	; 0
    21b6:	90 e0       	ldi	r25, 0x00	; 0
    21b8:	b7 01       	movw	r22, r14
    21ba:	0e 94 99 15 	call	0x2b32	; 0x2b32 <strtok>
	for (i=0; i<100; i++) path_points[i] = -1;
	
    char * token;
	token = strtok(input_str, ",");
	i = 0;
	while (token != '\0') {
    21be:	00 97       	sbiw	r24, 0x00	; 0
    21c0:	99 f7       	brne	.-26     	; 0x21a8 <main+0x8c>
		token = strtok('\0', ",");
	}
	/*************************** converting input string to int array end ******************************/
	
	// set velocity
	current_velocity = 135; // 127 on full charge
    21c2:	27 e8       	ldi	r18, 0x87	; 135
    21c4:	20 93 0d 02 	sts	0x020D, r18
	
	// synchronize wheels
	// suppose left wheel is physically 7.18% slower than the right wheel, so increase velocity of left wheel
	left_velocity_float = current_velocity + current_velocity * 0/100.0; // replace 0 with patch
    21c8:	80 e0       	ldi	r24, 0x00	; 0
    21ca:	90 e0       	ldi	r25, 0x00	; 0
    21cc:	a7 e0       	ldi	r26, 0x07	; 7
    21ce:	b3 e4       	ldi	r27, 0x43	; 67
    21d0:	80 93 eb 13 	sts	0x13EB, r24
    21d4:	90 93 ec 13 	sts	0x13EC, r25
    21d8:	a0 93 ed 13 	sts	0x13ED, r26
    21dc:	b0 93 ee 13 	sts	0x13EE, r27
	right_velocity_float = current_velocity + current_velocity * 0/100.0; // replace 0 with patch
    21e0:	80 93 f9 13 	sts	0x13F9, r24
    21e4:	90 93 fa 13 	sts	0x13FA, r25
    21e8:	a0 93 fb 13 	sts	0x13FB, r26
    21ec:	b0 93 fc 13 	sts	0x13FC, r27
	left_velocity = (unsigned char) left_velocity_float;
    21f0:	20 93 f8 13 	sts	0x13F8, r18
	right_velocity = (unsigned char) right_velocity_float;
    21f4:	20 93 fe 13 	sts	0x13FE, r18
	
	// go to 9th cell from start
	velocity(left_velocity, right_velocity);
    21f8:	87 e8       	ldi	r24, 0x87	; 135
    21fa:	67 e8       	ldi	r22, 0x87	; 135
    21fc:	0e 94 5c 09 	call	0x12b8	; 0x12b8 <velocity>
	
	follow_black_line_mm(50, 'F');
    2200:	82 e3       	ldi	r24, 0x32	; 50
    2202:	90 e0       	ldi	r25, 0x00	; 0
    2204:	66 e4       	ldi	r22, 0x46	; 70
    2206:	0e 94 df 0b 	call	0x17be	; 0x17be <follow_black_line_mm>
	move_one_cell();
    220a:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <move_one_cell>
    220e:	8f ef       	ldi	r24, 0xFF	; 255
    2210:	9f e7       	ldi	r25, 0x7F	; 127
    2212:	a6 e1       	ldi	r26, 0x16	; 22
    2214:	81 50       	subi	r24, 0x01	; 1
    2216:	90 40       	sbci	r25, 0x00	; 0
    2218:	a0 40       	sbci	r26, 0x00	; 0
    221a:	e1 f7       	brne	.-8      	; 0x2214 <__stack+0x15>
    221c:	00 c0       	rjmp	.+0      	; 0x221e <__stack+0x1f>
    221e:	00 00       	nop
	_delay_ms(500);
	current_grid = 1;
    2220:	81 e0       	ldi	r24, 0x01	; 1
    2222:	90 e0       	ldi	r25, 0x00	; 0
    2224:	90 93 0b 02 	sts	0x020B, r25
    2228:	80 93 0a 02 	sts	0x020A, r24
	current_direction = 'N';
    222c:	8e e4       	ldi	r24, 0x4E	; 78
    222e:	80 93 0c 02 	sts	0x020C, r24
	current_coordinate[0] = 3;
    2232:	83 e0       	ldi	r24, 0x03	; 3
    2234:	90 e0       	ldi	r25, 0x00	; 0
    2236:	90 93 05 02 	sts	0x0205, r25
    223a:	80 93 04 02 	sts	0x0204, r24
	current_coordinate[1] = 2;
    223e:	82 e0       	ldi	r24, 0x02	; 2
    2240:	90 e0       	ldi	r25, 0x00	; 0
    2242:	90 93 07 02 	sts	0x0207, r25
    2246:	80 93 06 02 	sts	0x0206, r24
	// start traversal	
	//	iterate through all positions
	//	to get value, add 1 to i, e.g.: path_points[i+1]
	//	use j to count iteration number, even value of j = position is in D1, odd value of j = position is in D2
	j = 0; // iteration counter
	int sum = 0; // used to track when a number in D2 get completed
    224a:	66 24       	eor	r6, r6
    224c:	77 24       	eor	r7, r7
	
	// start traversal	
	//	iterate through all positions
	//	to get value, add 1 to i, e.g.: path_points[i+1]
	//	use j to count iteration number, even value of j = position is in D1, odd value of j = position is in D2
	j = 0; // iteration counter
    224e:	88 24       	eor	r8, r8
    2250:	99 24       	eor	r9, r9
				}
			} else { // j is odd i.e. position is in D2
				// target cell is in D2 i.e. deposit operation
				
				// 1. move to bridge point (2, 4) in D1
				go_to_coordinate((int[]){2, 4});
    2252:	44 24       	eor	r4, r4
    2254:	55 24       	eor	r5, r5
    2256:	68 94       	set
    2258:	41 f8       	bld	r4, 1
				move_one_cell();
				
				// 3. update current_grid=2 and current_coordinate=(2, 0) (D2 bridge point)
				current_grid = 2;
				// update current_coordinate to (2, 0)
				current_coordinate[0] = 2;
    225a:	0f 2e       	mov	r0, r31
    225c:	f4 e0       	ldi	r31, 0x04	; 4
    225e:	2f 2e       	mov	r2, r31
    2260:	f2 e0       	ldi	r31, 0x02	; 2
    2262:	3f 2e       	mov	r3, r31
    2264:	f0 2d       	mov	r31, r0
				current_coordinate[1] = 0;
    2266:	d1 01       	movw	r26, r2
    2268:	12 96       	adiw	r26, 0x02	; 2
    226a:	cf 52       	subi	r28, 0x2F	; 47
    226c:	df 4f       	sbci	r29, 0xFF	; 255
    226e:	b9 83       	std	Y+1, r27	; 0x01
    2270:	a8 83       	st	Y, r26
    2272:	c1 5d       	subi	r28, 0xD1	; 209
    2274:	d0 40       	sbci	r29, 0x00	; 0
 *									sum = 0
 *								Else, deposit as number in D2 is not completed and whole task is not completed as well.
 *								If i+2 th element in path_points is -1, then continuous buzzer as robot has finished the task.
 * Example Call:	Called automatically by the Operating System
 */
int main() {
    2276:	76 01       	movw	r14, r12
	//	use j to count iteration number, even value of j = position is in D1, odd value of j = position is in D2
	j = 0; // iteration counter
	int sum = 0; // used to track when a number in D2 get completed
	
	for (i=0; i<100; i+=2) {
		if (path_points[i] != -1) {			
    2278:	f6 01       	movw	r30, r12
    227a:	00 81       	ld	r16, Z
    227c:	11 81       	ldd	r17, Z+1	; 0x01
    227e:	ff ef       	ldi	r31, 0xFF	; 255
    2280:	0f 3f       	cpi	r16, 0xFF	; 255
    2282:	1f 07       	cpc	r17, r31
    2284:	09 f4       	brne	.+2      	; 0x2288 <__stack+0x89>
    2286:	c4 c0       	rjmp	.+392    	; 0x2410 <__stack+0x211>
			if (j%2 == 0) { // j is even i.e. position is in D1
    2288:	80 fc       	sbrc	r8, 0
    228a:	6d c0       	rjmp	.+218    	; 0x2366 <__stack+0x167>
				// target cell is in D1 i.e. pickup operation
				sum += path_points[i+1]; // add D1 number's value to sum
    228c:	d6 01       	movw	r26, r12
    228e:	12 96       	adiw	r26, 0x02	; 2
    2290:	ed 90       	ld	r14, X+
    2292:	fc 90       	ld	r15, X
    2294:	13 97       	sbiw	r26, 0x03	; 3
    2296:	6e 0c       	add	r6, r14
    2298:	7f 1c       	adc	r7, r15
				
				if (current_grid == 1) { // if robot is already in D1
    229a:	80 91 0a 02 	lds	r24, 0x020A
    229e:	90 91 0b 02 	lds	r25, 0x020B
    22a2:	81 30       	cpi	r24, 0x01	; 1
    22a4:	91 05       	cpc	r25, r1
    22a6:	a1 f5       	brne	.+104    	; 0x2310 <__stack+0x111>
					go_to_cell_no(1, path_points[i]);
    22a8:	81 e0       	ldi	r24, 0x01	; 1
    22aa:	90 e0       	ldi	r25, 0x00	; 0
    22ac:	b8 01       	movw	r22, r16
    22ae:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <go_to_cell_no>
					
					// decides just pickup ad back or pickup and forward
					if (current_direction == 'E' || (current_direction == 'N' && current_coordinate[0] == 3)) {
    22b2:	80 91 0c 02 	lds	r24, 0x020C
    22b6:	85 34       	cpi	r24, 0x45	; 69
    22b8:	41 f0       	breq	.+16     	; 0x22ca <__stack+0xcb>
    22ba:	8e 34       	cpi	r24, 0x4E	; 78
    22bc:	19 f5       	brne	.+70     	; 0x2304 <__stack+0x105>
    22be:	f1 01       	movw	r30, r2
    22c0:	80 81       	ld	r24, Z
    22c2:	91 81       	ldd	r25, Z+1	; 0x01
    22c4:	83 30       	cpi	r24, 0x03	; 3
    22c6:	91 05       	cpc	r25, r1
    22c8:	e9 f4       	brne	.+58     	; 0x2304 <__stack+0x105>
						pickup(path_points[i+1], 1);
    22ca:	c7 01       	movw	r24, r14
    22cc:	61 e0       	ldi	r22, 0x01	; 1
    22ce:	70 e0       	ldi	r23, 0x00	; 0
    22d0:	0e 94 4b 0f 	call	0x1e96	; 0x1e96 <pickup>
						
						if (current_direction == 'N') current_coordinate[0]--; // current row = current row - 1
    22d4:	80 91 0c 02 	lds	r24, 0x020C
    22d8:	8e 34       	cpi	r24, 0x4E	; 78
    22da:	49 f4       	brne	.+18     	; 0x22ee <__stack+0xef>
    22dc:	d1 01       	movw	r26, r2
    22de:	8d 91       	ld	r24, X+
    22e0:	9c 91       	ld	r25, X
    22e2:	11 97       	sbiw	r26, 0x01	; 1
    22e4:	01 97       	sbiw	r24, 0x01	; 1
    22e6:	11 96       	adiw	r26, 0x01	; 1
    22e8:	9c 93       	st	X, r25
    22ea:	8e 93       	st	-X, r24
    22ec:	8e c0       	rjmp	.+284    	; 0x240a <__stack+0x20b>
						if (current_direction == 'E') current_coordinate[1]++; // current column = current column + 1
    22ee:	85 34       	cpi	r24, 0x45	; 69
    22f0:	09 f0       	breq	.+2      	; 0x22f4 <__stack+0xf5>
    22f2:	8b c0       	rjmp	.+278    	; 0x240a <__stack+0x20b>
    22f4:	e6 e0       	ldi	r30, 0x06	; 6
    22f6:	f2 e0       	ldi	r31, 0x02	; 2
    22f8:	80 81       	ld	r24, Z
    22fa:	91 81       	ldd	r25, Z+1	; 0x01
    22fc:	01 96       	adiw	r24, 0x01	; 1
    22fe:	91 83       	std	Z+1, r25	; 0x01
    2300:	80 83       	st	Z, r24
    2302:	83 c0       	rjmp	.+262    	; 0x240a <__stack+0x20b>
					} else {
						pickup(path_points[i+1], 0);
    2304:	c7 01       	movw	r24, r14
    2306:	60 e0       	ldi	r22, 0x00	; 0
    2308:	70 e0       	ldi	r23, 0x00	; 0
    230a:	0e 94 4b 0f 	call	0x1e96	; 0x1e96 <pickup>
    230e:	7d c0       	rjmp	.+250    	; 0x240a <__stack+0x20b>
					}		
				} else { // robot is in D2, need to cross the bridge to go to D1
					// 1. move to bridge point (2, 0) in D2
					go_to_coordinate((int[]){2, 0});
    2310:	5e 82       	std	Y+6, r5	; 0x06
    2312:	4d 82       	std	Y+5, r4	; 0x05
    2314:	18 86       	std	Y+8, r1	; 0x08
    2316:	1f 82       	std	Y+7, r1	; 0x07
    2318:	ce 01       	movw	r24, r28
    231a:	05 96       	adiw	r24, 0x05	; 5
    231c:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <go_to_coordinate>
					
					// 2. go to west one cell
					change_direction('W');
    2320:	87 e5       	ldi	r24, 0x57	; 87
    2322:	0e 94 8c 0c 	call	0x1918	; 0x1918 <change_direction>
					move_one_cell();
    2326:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <move_one_cell>
					
					// 3. update current_grid=1 and current_coordinate=(2, 4) (D1 bridge point)
					current_grid = 1;
    232a:	81 e0       	ldi	r24, 0x01	; 1
    232c:	90 e0       	ldi	r25, 0x00	; 0
    232e:	90 93 0b 02 	sts	0x020B, r25
    2332:	80 93 0a 02 	sts	0x020A, r24
					// update current_coordinate to (2, 4)
					current_coordinate[0] = 2; 
    2336:	d1 01       	movw	r26, r2
    2338:	4d 92       	st	X+, r4
    233a:	5c 92       	st	X, r5
					current_coordinate[1] = 4;
    233c:	84 e0       	ldi	r24, 0x04	; 4
    233e:	90 e0       	ldi	r25, 0x00	; 0
    2340:	cf 52       	subi	r28, 0x2F	; 47
    2342:	df 4f       	sbci	r29, 0xFF	; 255
    2344:	e8 81       	ld	r30, Y
    2346:	f9 81       	ldd	r31, Y+1	; 0x01
    2348:	c1 5d       	subi	r28, 0xD1	; 209
    234a:	d0 40       	sbci	r29, 0x00	; 0
    234c:	91 83       	std	Z+1, r25	; 0x01
    234e:	80 83       	st	Z, r24
					
					// 4. go_to_cell_no()
					go_to_cell_no(1, path_points[i]);
    2350:	81 e0       	ldi	r24, 0x01	; 1
    2352:	90 e0       	ldi	r25, 0x00	; 0
    2354:	b8 01       	movw	r22, r16
    2356:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <go_to_cell_no>
					
					// 5. pickup
					pickup(path_points[i+1], 0);
    235a:	c7 01       	movw	r24, r14
    235c:	60 e0       	ldi	r22, 0x00	; 0
    235e:	70 e0       	ldi	r23, 0x00	; 0
    2360:	0e 94 4b 0f 	call	0x1e96	; 0x1e96 <pickup>
    2364:	52 c0       	rjmp	.+164    	; 0x240a <__stack+0x20b>
				}
			} else { // j is odd i.e. position is in D2
				// target cell is in D2 i.e. deposit operation
				
				// 1. move to bridge point (2, 4) in D1
				go_to_coordinate((int[]){2, 4});
    2366:	5a 82       	std	Y+2, r5	; 0x02
    2368:	49 82       	std	Y+1, r4	; 0x01
    236a:	a4 e0       	ldi	r26, 0x04	; 4
    236c:	b0 e0       	ldi	r27, 0x00	; 0
    236e:	bc 83       	std	Y+4, r27	; 0x04
    2370:	ab 83       	std	Y+3, r26	; 0x03
    2372:	ce 01       	movw	r24, r28
    2374:	01 96       	adiw	r24, 0x01	; 1
    2376:	0e 94 0a 0e 	call	0x1c14	; 0x1c14 <go_to_coordinate>
				
				// 2. go east one cell
				change_direction('E');
    237a:	85 e4       	ldi	r24, 0x45	; 69
    237c:	0e 94 8c 0c 	call	0x1918	; 0x1918 <change_direction>
				move_one_cell();
    2380:	0e 94 47 0d 	call	0x1a8e	; 0x1a8e <move_one_cell>
				
				// 3. update current_grid=2 and current_coordinate=(2, 0) (D2 bridge point)
				current_grid = 2;
    2384:	50 92 0b 02 	sts	0x020B, r5
    2388:	40 92 0a 02 	sts	0x020A, r4
				// update current_coordinate to (2, 0)
				current_coordinate[0] = 2;
    238c:	f1 01       	movw	r30, r2
    238e:	51 82       	std	Z+1, r5	; 0x01
    2390:	40 82       	st	Z, r4
				current_coordinate[1] = 0;
    2392:	cf 52       	subi	r28, 0x2F	; 47
    2394:	df 4f       	sbci	r29, 0xFF	; 255
    2396:	a8 81       	ld	r26, Y
    2398:	b9 81       	ldd	r27, Y+1	; 0x01
    239a:	c1 5d       	subi	r28, 0xD1	; 209
    239c:	d0 40       	sbci	r29, 0x00	; 0
    239e:	1d 92       	st	X+, r1
    23a0:	1c 92       	st	X, r1
				
				// 4. go_to_cell_no()
				go_to_cell_no(2, path_points[i]);
    23a2:	c2 01       	movw	r24, r4
    23a4:	b8 01       	movw	r22, r16
    23a6:	0e 94 41 0e 	call	0x1c82	; 0x1c82 <go_to_cell_no>
				
				// 5. deposit
				if (sum == path_points[i+1]) {
    23aa:	f6 01       	movw	r30, r12
    23ac:	82 81       	ldd	r24, Z+2	; 0x02
    23ae:	93 81       	ldd	r25, Z+3	; 0x03
    23b0:	86 15       	cp	r24, r6
    23b2:	97 05       	cpc	r25, r7
    23b4:	c1 f4       	brne	.+48     	; 0x23e6 <__stack+0x1e7>
					if (path_points[i+2] == -1) {
    23b6:	84 81       	ldd	r24, Z+4	; 0x04
    23b8:	95 81       	ldd	r25, Z+5	; 0x05
    23ba:	ff ef       	ldi	r31, 0xFF	; 255
    23bc:	8f 3f       	cpi	r24, 0xFF	; 255
    23be:	9f 07       	cpc	r25, r31
    23c0:	49 f4       	brne	.+18     	; 0x23d4 <__stack+0x1d5>
						deposit(1, 1); // 1 = number in D2 is completed, 1 = task completed respectively
    23c2:	81 e0       	ldi	r24, 0x01	; 1
    23c4:	90 e0       	ldi	r25, 0x00	; 0
    23c6:	61 e0       	ldi	r22, 0x01	; 1
    23c8:	70 e0       	ldi	r23, 0x00	; 0
    23ca:	0e 94 7f 0f 	call	0x1efe	; 0x1efe <deposit>
					} else {
						deposit(1, 0); // 1 = number in D2 is completed, 0 = task not completed respectively
					}
					sum = 0;
    23ce:	66 24       	eor	r6, r6
    23d0:	77 24       	eor	r7, r7
    23d2:	0f c0       	rjmp	.+30     	; 0x23f2 <__stack+0x1f3>
				// 5. deposit
				if (sum == path_points[i+1]) {
					if (path_points[i+2] == -1) {
						deposit(1, 1); // 1 = number in D2 is completed, 1 = task completed respectively
					} else {
						deposit(1, 0); // 1 = number in D2 is completed, 0 = task not completed respectively
    23d4:	81 e0       	ldi	r24, 0x01	; 1
    23d6:	90 e0       	ldi	r25, 0x00	; 0
    23d8:	60 e0       	ldi	r22, 0x00	; 0
    23da:	70 e0       	ldi	r23, 0x00	; 0
    23dc:	0e 94 7f 0f 	call	0x1efe	; 0x1efe <deposit>
					}
					sum = 0;
    23e0:	66 24       	eor	r6, r6
    23e2:	77 24       	eor	r7, r7
    23e4:	06 c0       	rjmp	.+12     	; 0x23f2 <__stack+0x1f3>
				} else {
					deposit(0, 0); // 0 = number in D2 is not completed, 0 = task not completed respectively
    23e6:	80 e0       	ldi	r24, 0x00	; 0
    23e8:	90 e0       	ldi	r25, 0x00	; 0
    23ea:	60 e0       	ldi	r22, 0x00	; 0
    23ec:	70 e0       	ldi	r23, 0x00	; 0
    23ee:	0e 94 7f 0f 	call	0x1efe	; 0x1efe <deposit>
				}
				
				// it should be deleted before video submission/final
				if (path_points[i+2] == -1) {
    23f2:	d7 01       	movw	r26, r14
    23f4:	14 96       	adiw	r26, 0x04	; 4
    23f6:	8d 91       	ld	r24, X+
    23f8:	9c 91       	ld	r25, X
    23fa:	15 97       	sbiw	r26, 0x05	; 5
    23fc:	bf ef       	ldi	r27, 0xFF	; 255
    23fe:	8f 3f       	cpi	r24, 0xFF	; 255
    2400:	9b 07       	cpc	r25, r27
    2402:	19 f4       	brne	.+6      	; 0x240a <__stack+0x20b>
					// continuous buzzer on finished the task
					buzzer_on();
    2404:	0e 94 b3 08 	call	0x1166	; 0x1166 <buzzer_on>
    2408:	ff cf       	rjmp	.-2      	; 0x2408 <__stack+0x209>
					while(1);
				}
			}
			
			j++;
    240a:	08 94       	sec
    240c:	81 1c       	adc	r8, r1
    240e:	91 1c       	adc	r9, r1
    2410:	e4 e0       	ldi	r30, 0x04	; 4
    2412:	f0 e0       	ldi	r31, 0x00	; 0
    2414:	ce 0e       	add	r12, r30
    2416:	df 1e       	adc	r13, r31
	//	to get value, add 1 to i, e.g.: path_points[i+1]
	//	use j to count iteration number, even value of j = position is in D1, odd value of j = position is in D2
	j = 0; // iteration counter
	int sum = 0; // used to track when a number in D2 get completed
	
	for (i=0; i<100; i+=2) {
    2418:	ac 14       	cp	r10, r12
    241a:	bd 04       	cpc	r11, r13
    241c:	09 f0       	breq	.+2      	; 0x2420 <__stack+0x221>
    241e:	2b cf       	rjmp	.-426    	; 0x2276 <__stack+0x77>
			}
			
			j++;
		}
	}
}
    2420:	80 e0       	ldi	r24, 0x00	; 0
    2422:	90 e0       	ldi	r25, 0x00	; 0
    2424:	ce 52       	subi	r28, 0x2E	; 46
    2426:	df 4f       	sbci	r29, 0xFF	; 255
    2428:	0f b6       	in	r0, 0x3f	; 63
    242a:	f8 94       	cli
    242c:	de bf       	out	0x3e, r29	; 62
    242e:	0f be       	out	0x3f, r0	; 63
    2430:	cd bf       	out	0x3d, r28	; 61
    2432:	df 91       	pop	r29
    2434:	cf 91       	pop	r28
    2436:	1f 91       	pop	r17
    2438:	0f 91       	pop	r16
    243a:	ff 90       	pop	r15
    243c:	ef 90       	pop	r14
    243e:	df 90       	pop	r13
    2440:	cf 90       	pop	r12
    2442:	bf 90       	pop	r11
    2444:	af 90       	pop	r10
    2446:	9f 90       	pop	r9
    2448:	8f 90       	pop	r8
    244a:	7f 90       	pop	r7
    244c:	6f 90       	pop	r6
    244e:	5f 90       	pop	r5
    2450:	4f 90       	pop	r4
    2452:	3f 90       	pop	r3
    2454:	2f 90       	pop	r2
    2456:	08 95       	ret

00002458 <__subsf3>:
    2458:	50 58       	subi	r21, 0x80	; 128

0000245a <__addsf3>:
    245a:	bb 27       	eor	r27, r27
    245c:	aa 27       	eor	r26, r26
    245e:	0e d0       	rcall	.+28     	; 0x247c <__addsf3x>
    2460:	48 c1       	rjmp	.+656    	; 0x26f2 <__fp_round>
    2462:	39 d1       	rcall	.+626    	; 0x26d6 <__fp_pscA>
    2464:	30 f0       	brcs	.+12     	; 0x2472 <__addsf3+0x18>
    2466:	3e d1       	rcall	.+636    	; 0x26e4 <__fp_pscB>
    2468:	20 f0       	brcs	.+8      	; 0x2472 <__addsf3+0x18>
    246a:	31 f4       	brne	.+12     	; 0x2478 <__addsf3+0x1e>
    246c:	9f 3f       	cpi	r25, 0xFF	; 255
    246e:	11 f4       	brne	.+4      	; 0x2474 <__addsf3+0x1a>
    2470:	1e f4       	brtc	.+6      	; 0x2478 <__addsf3+0x1e>
    2472:	2e c1       	rjmp	.+604    	; 0x26d0 <__fp_nan>
    2474:	0e f4       	brtc	.+2      	; 0x2478 <__addsf3+0x1e>
    2476:	e0 95       	com	r30
    2478:	e7 fb       	bst	r30, 7
    247a:	24 c1       	rjmp	.+584    	; 0x26c4 <__fp_inf>

0000247c <__addsf3x>:
    247c:	e9 2f       	mov	r30, r25
    247e:	4a d1       	rcall	.+660    	; 0x2714 <__fp_split3>
    2480:	80 f3       	brcs	.-32     	; 0x2462 <__addsf3+0x8>
    2482:	ba 17       	cp	r27, r26
    2484:	62 07       	cpc	r22, r18
    2486:	73 07       	cpc	r23, r19
    2488:	84 07       	cpc	r24, r20
    248a:	95 07       	cpc	r25, r21
    248c:	18 f0       	brcs	.+6      	; 0x2494 <__addsf3x+0x18>
    248e:	71 f4       	brne	.+28     	; 0x24ac <__addsf3x+0x30>
    2490:	9e f5       	brtc	.+102    	; 0x24f8 <__addsf3x+0x7c>
    2492:	62 c1       	rjmp	.+708    	; 0x2758 <__fp_zero>
    2494:	0e f4       	brtc	.+2      	; 0x2498 <__addsf3x+0x1c>
    2496:	e0 95       	com	r30
    2498:	0b 2e       	mov	r0, r27
    249a:	ba 2f       	mov	r27, r26
    249c:	a0 2d       	mov	r26, r0
    249e:	0b 01       	movw	r0, r22
    24a0:	b9 01       	movw	r22, r18
    24a2:	90 01       	movw	r18, r0
    24a4:	0c 01       	movw	r0, r24
    24a6:	ca 01       	movw	r24, r20
    24a8:	a0 01       	movw	r20, r0
    24aa:	11 24       	eor	r1, r1
    24ac:	ff 27       	eor	r31, r31
    24ae:	59 1b       	sub	r21, r25
    24b0:	99 f0       	breq	.+38     	; 0x24d8 <__addsf3x+0x5c>
    24b2:	59 3f       	cpi	r21, 0xF9	; 249
    24b4:	50 f4       	brcc	.+20     	; 0x24ca <__addsf3x+0x4e>
    24b6:	50 3e       	cpi	r21, 0xE0	; 224
    24b8:	68 f1       	brcs	.+90     	; 0x2514 <__addsf3x+0x98>
    24ba:	1a 16       	cp	r1, r26
    24bc:	f0 40       	sbci	r31, 0x00	; 0
    24be:	a2 2f       	mov	r26, r18
    24c0:	23 2f       	mov	r18, r19
    24c2:	34 2f       	mov	r19, r20
    24c4:	44 27       	eor	r20, r20
    24c6:	58 5f       	subi	r21, 0xF8	; 248
    24c8:	f3 cf       	rjmp	.-26     	; 0x24b0 <__addsf3x+0x34>
    24ca:	46 95       	lsr	r20
    24cc:	37 95       	ror	r19
    24ce:	27 95       	ror	r18
    24d0:	a7 95       	ror	r26
    24d2:	f0 40       	sbci	r31, 0x00	; 0
    24d4:	53 95       	inc	r21
    24d6:	c9 f7       	brne	.-14     	; 0x24ca <__addsf3x+0x4e>
    24d8:	7e f4       	brtc	.+30     	; 0x24f8 <__addsf3x+0x7c>
    24da:	1f 16       	cp	r1, r31
    24dc:	ba 0b       	sbc	r27, r26
    24de:	62 0b       	sbc	r22, r18
    24e0:	73 0b       	sbc	r23, r19
    24e2:	84 0b       	sbc	r24, r20
    24e4:	ba f0       	brmi	.+46     	; 0x2514 <__addsf3x+0x98>
    24e6:	91 50       	subi	r25, 0x01	; 1
    24e8:	a1 f0       	breq	.+40     	; 0x2512 <__addsf3x+0x96>
    24ea:	ff 0f       	add	r31, r31
    24ec:	bb 1f       	adc	r27, r27
    24ee:	66 1f       	adc	r22, r22
    24f0:	77 1f       	adc	r23, r23
    24f2:	88 1f       	adc	r24, r24
    24f4:	c2 f7       	brpl	.-16     	; 0x24e6 <__addsf3x+0x6a>
    24f6:	0e c0       	rjmp	.+28     	; 0x2514 <__addsf3x+0x98>
    24f8:	ba 0f       	add	r27, r26
    24fa:	62 1f       	adc	r22, r18
    24fc:	73 1f       	adc	r23, r19
    24fe:	84 1f       	adc	r24, r20
    2500:	48 f4       	brcc	.+18     	; 0x2514 <__addsf3x+0x98>
    2502:	87 95       	ror	r24
    2504:	77 95       	ror	r23
    2506:	67 95       	ror	r22
    2508:	b7 95       	ror	r27
    250a:	f7 95       	ror	r31
    250c:	9e 3f       	cpi	r25, 0xFE	; 254
    250e:	08 f0       	brcs	.+2      	; 0x2512 <__addsf3x+0x96>
    2510:	b3 cf       	rjmp	.-154    	; 0x2478 <__addsf3+0x1e>
    2512:	93 95       	inc	r25
    2514:	88 0f       	add	r24, r24
    2516:	08 f0       	brcs	.+2      	; 0x251a <__addsf3x+0x9e>
    2518:	99 27       	eor	r25, r25
    251a:	ee 0f       	add	r30, r30
    251c:	97 95       	ror	r25
    251e:	87 95       	ror	r24
    2520:	08 95       	ret

00002522 <__divsf3>:
    2522:	0c d0       	rcall	.+24     	; 0x253c <__divsf3x>
    2524:	e6 c0       	rjmp	.+460    	; 0x26f2 <__fp_round>
    2526:	de d0       	rcall	.+444    	; 0x26e4 <__fp_pscB>
    2528:	40 f0       	brcs	.+16     	; 0x253a <__divsf3+0x18>
    252a:	d5 d0       	rcall	.+426    	; 0x26d6 <__fp_pscA>
    252c:	30 f0       	brcs	.+12     	; 0x253a <__divsf3+0x18>
    252e:	21 f4       	brne	.+8      	; 0x2538 <__divsf3+0x16>
    2530:	5f 3f       	cpi	r21, 0xFF	; 255
    2532:	19 f0       	breq	.+6      	; 0x253a <__divsf3+0x18>
    2534:	c7 c0       	rjmp	.+398    	; 0x26c4 <__fp_inf>
    2536:	51 11       	cpse	r21, r1
    2538:	10 c1       	rjmp	.+544    	; 0x275a <__fp_szero>
    253a:	ca c0       	rjmp	.+404    	; 0x26d0 <__fp_nan>

0000253c <__divsf3x>:
    253c:	eb d0       	rcall	.+470    	; 0x2714 <__fp_split3>
    253e:	98 f3       	brcs	.-26     	; 0x2526 <__divsf3+0x4>

00002540 <__divsf3_pse>:
    2540:	99 23       	and	r25, r25
    2542:	c9 f3       	breq	.-14     	; 0x2536 <__divsf3+0x14>
    2544:	55 23       	and	r21, r21
    2546:	b1 f3       	breq	.-20     	; 0x2534 <__divsf3+0x12>
    2548:	95 1b       	sub	r25, r21
    254a:	55 0b       	sbc	r21, r21
    254c:	bb 27       	eor	r27, r27
    254e:	aa 27       	eor	r26, r26
    2550:	62 17       	cp	r22, r18
    2552:	73 07       	cpc	r23, r19
    2554:	84 07       	cpc	r24, r20
    2556:	38 f0       	brcs	.+14     	; 0x2566 <__divsf3_pse+0x26>
    2558:	9f 5f       	subi	r25, 0xFF	; 255
    255a:	5f 4f       	sbci	r21, 0xFF	; 255
    255c:	22 0f       	add	r18, r18
    255e:	33 1f       	adc	r19, r19
    2560:	44 1f       	adc	r20, r20
    2562:	aa 1f       	adc	r26, r26
    2564:	a9 f3       	breq	.-22     	; 0x2550 <__divsf3_pse+0x10>
    2566:	33 d0       	rcall	.+102    	; 0x25ce <__divsf3_pse+0x8e>
    2568:	0e 2e       	mov	r0, r30
    256a:	3a f0       	brmi	.+14     	; 0x257a <__divsf3_pse+0x3a>
    256c:	e0 e8       	ldi	r30, 0x80	; 128
    256e:	30 d0       	rcall	.+96     	; 0x25d0 <__divsf3_pse+0x90>
    2570:	91 50       	subi	r25, 0x01	; 1
    2572:	50 40       	sbci	r21, 0x00	; 0
    2574:	e6 95       	lsr	r30
    2576:	00 1c       	adc	r0, r0
    2578:	ca f7       	brpl	.-14     	; 0x256c <__divsf3_pse+0x2c>
    257a:	29 d0       	rcall	.+82     	; 0x25ce <__divsf3_pse+0x8e>
    257c:	fe 2f       	mov	r31, r30
    257e:	27 d0       	rcall	.+78     	; 0x25ce <__divsf3_pse+0x8e>
    2580:	66 0f       	add	r22, r22
    2582:	77 1f       	adc	r23, r23
    2584:	88 1f       	adc	r24, r24
    2586:	bb 1f       	adc	r27, r27
    2588:	26 17       	cp	r18, r22
    258a:	37 07       	cpc	r19, r23
    258c:	48 07       	cpc	r20, r24
    258e:	ab 07       	cpc	r26, r27
    2590:	b0 e8       	ldi	r27, 0x80	; 128
    2592:	09 f0       	breq	.+2      	; 0x2596 <__divsf3_pse+0x56>
    2594:	bb 0b       	sbc	r27, r27
    2596:	80 2d       	mov	r24, r0
    2598:	bf 01       	movw	r22, r30
    259a:	ff 27       	eor	r31, r31
    259c:	93 58       	subi	r25, 0x83	; 131
    259e:	5f 4f       	sbci	r21, 0xFF	; 255
    25a0:	2a f0       	brmi	.+10     	; 0x25ac <__divsf3_pse+0x6c>
    25a2:	9e 3f       	cpi	r25, 0xFE	; 254
    25a4:	51 05       	cpc	r21, r1
    25a6:	68 f0       	brcs	.+26     	; 0x25c2 <__divsf3_pse+0x82>
    25a8:	8d c0       	rjmp	.+282    	; 0x26c4 <__fp_inf>
    25aa:	d7 c0       	rjmp	.+430    	; 0x275a <__fp_szero>
    25ac:	5f 3f       	cpi	r21, 0xFF	; 255
    25ae:	ec f3       	brlt	.-6      	; 0x25aa <__divsf3_pse+0x6a>
    25b0:	98 3e       	cpi	r25, 0xE8	; 232
    25b2:	dc f3       	brlt	.-10     	; 0x25aa <__divsf3_pse+0x6a>
    25b4:	86 95       	lsr	r24
    25b6:	77 95       	ror	r23
    25b8:	67 95       	ror	r22
    25ba:	b7 95       	ror	r27
    25bc:	f7 95       	ror	r31
    25be:	9f 5f       	subi	r25, 0xFF	; 255
    25c0:	c9 f7       	brne	.-14     	; 0x25b4 <__divsf3_pse+0x74>
    25c2:	88 0f       	add	r24, r24
    25c4:	91 1d       	adc	r25, r1
    25c6:	96 95       	lsr	r25
    25c8:	87 95       	ror	r24
    25ca:	97 f9       	bld	r25, 7
    25cc:	08 95       	ret
    25ce:	e1 e0       	ldi	r30, 0x01	; 1
    25d0:	66 0f       	add	r22, r22
    25d2:	77 1f       	adc	r23, r23
    25d4:	88 1f       	adc	r24, r24
    25d6:	bb 1f       	adc	r27, r27
    25d8:	62 17       	cp	r22, r18
    25da:	73 07       	cpc	r23, r19
    25dc:	84 07       	cpc	r24, r20
    25de:	ba 07       	cpc	r27, r26
    25e0:	20 f0       	brcs	.+8      	; 0x25ea <__divsf3_pse+0xaa>
    25e2:	62 1b       	sub	r22, r18
    25e4:	73 0b       	sbc	r23, r19
    25e6:	84 0b       	sbc	r24, r20
    25e8:	ba 0b       	sbc	r27, r26
    25ea:	ee 1f       	adc	r30, r30
    25ec:	88 f7       	brcc	.-30     	; 0x25d0 <__divsf3_pse+0x90>
    25ee:	e0 95       	com	r30
    25f0:	08 95       	ret

000025f2 <__fixunssfsi>:
    25f2:	98 d0       	rcall	.+304    	; 0x2724 <__fp_splitA>
    25f4:	88 f0       	brcs	.+34     	; 0x2618 <__fixunssfsi+0x26>
    25f6:	9f 57       	subi	r25, 0x7F	; 127
    25f8:	90 f0       	brcs	.+36     	; 0x261e <__fixunssfsi+0x2c>
    25fa:	b9 2f       	mov	r27, r25
    25fc:	99 27       	eor	r25, r25
    25fe:	b7 51       	subi	r27, 0x17	; 23
    2600:	a0 f0       	brcs	.+40     	; 0x262a <__fixunssfsi+0x38>
    2602:	d1 f0       	breq	.+52     	; 0x2638 <__fixunssfsi+0x46>
    2604:	66 0f       	add	r22, r22
    2606:	77 1f       	adc	r23, r23
    2608:	88 1f       	adc	r24, r24
    260a:	99 1f       	adc	r25, r25
    260c:	1a f0       	brmi	.+6      	; 0x2614 <__fixunssfsi+0x22>
    260e:	ba 95       	dec	r27
    2610:	c9 f7       	brne	.-14     	; 0x2604 <__fixunssfsi+0x12>
    2612:	12 c0       	rjmp	.+36     	; 0x2638 <__fixunssfsi+0x46>
    2614:	b1 30       	cpi	r27, 0x01	; 1
    2616:	81 f0       	breq	.+32     	; 0x2638 <__fixunssfsi+0x46>
    2618:	9f d0       	rcall	.+318    	; 0x2758 <__fp_zero>
    261a:	b1 e0       	ldi	r27, 0x01	; 1
    261c:	08 95       	ret
    261e:	9c c0       	rjmp	.+312    	; 0x2758 <__fp_zero>
    2620:	67 2f       	mov	r22, r23
    2622:	78 2f       	mov	r23, r24
    2624:	88 27       	eor	r24, r24
    2626:	b8 5f       	subi	r27, 0xF8	; 248
    2628:	39 f0       	breq	.+14     	; 0x2638 <__fixunssfsi+0x46>
    262a:	b9 3f       	cpi	r27, 0xF9	; 249
    262c:	cc f3       	brlt	.-14     	; 0x2620 <__fixunssfsi+0x2e>
    262e:	86 95       	lsr	r24
    2630:	77 95       	ror	r23
    2632:	67 95       	ror	r22
    2634:	b3 95       	inc	r27
    2636:	d9 f7       	brne	.-10     	; 0x262e <__fixunssfsi+0x3c>
    2638:	3e f4       	brtc	.+14     	; 0x2648 <__fixunssfsi+0x56>
    263a:	90 95       	com	r25
    263c:	80 95       	com	r24
    263e:	70 95       	com	r23
    2640:	61 95       	neg	r22
    2642:	7f 4f       	sbci	r23, 0xFF	; 255
    2644:	8f 4f       	sbci	r24, 0xFF	; 255
    2646:	9f 4f       	sbci	r25, 0xFF	; 255
    2648:	08 95       	ret

0000264a <__floatunsisf>:
    264a:	e8 94       	clt
    264c:	09 c0       	rjmp	.+18     	; 0x2660 <__floatsisf+0x12>

0000264e <__floatsisf>:
    264e:	97 fb       	bst	r25, 7
    2650:	3e f4       	brtc	.+14     	; 0x2660 <__floatsisf+0x12>
    2652:	90 95       	com	r25
    2654:	80 95       	com	r24
    2656:	70 95       	com	r23
    2658:	61 95       	neg	r22
    265a:	7f 4f       	sbci	r23, 0xFF	; 255
    265c:	8f 4f       	sbci	r24, 0xFF	; 255
    265e:	9f 4f       	sbci	r25, 0xFF	; 255
    2660:	99 23       	and	r25, r25
    2662:	a9 f0       	breq	.+42     	; 0x268e <__floatsisf+0x40>
    2664:	f9 2f       	mov	r31, r25
    2666:	96 e9       	ldi	r25, 0x96	; 150
    2668:	bb 27       	eor	r27, r27
    266a:	93 95       	inc	r25
    266c:	f6 95       	lsr	r31
    266e:	87 95       	ror	r24
    2670:	77 95       	ror	r23
    2672:	67 95       	ror	r22
    2674:	b7 95       	ror	r27
    2676:	f1 11       	cpse	r31, r1
    2678:	f8 cf       	rjmp	.-16     	; 0x266a <__floatsisf+0x1c>
    267a:	fa f4       	brpl	.+62     	; 0x26ba <__floatsisf+0x6c>
    267c:	bb 0f       	add	r27, r27
    267e:	11 f4       	brne	.+4      	; 0x2684 <__floatsisf+0x36>
    2680:	60 ff       	sbrs	r22, 0
    2682:	1b c0       	rjmp	.+54     	; 0x26ba <__floatsisf+0x6c>
    2684:	6f 5f       	subi	r22, 0xFF	; 255
    2686:	7f 4f       	sbci	r23, 0xFF	; 255
    2688:	8f 4f       	sbci	r24, 0xFF	; 255
    268a:	9f 4f       	sbci	r25, 0xFF	; 255
    268c:	16 c0       	rjmp	.+44     	; 0x26ba <__floatsisf+0x6c>
    268e:	88 23       	and	r24, r24
    2690:	11 f0       	breq	.+4      	; 0x2696 <__floatsisf+0x48>
    2692:	96 e9       	ldi	r25, 0x96	; 150
    2694:	11 c0       	rjmp	.+34     	; 0x26b8 <__floatsisf+0x6a>
    2696:	77 23       	and	r23, r23
    2698:	21 f0       	breq	.+8      	; 0x26a2 <__floatsisf+0x54>
    269a:	9e e8       	ldi	r25, 0x8E	; 142
    269c:	87 2f       	mov	r24, r23
    269e:	76 2f       	mov	r23, r22
    26a0:	05 c0       	rjmp	.+10     	; 0x26ac <__floatsisf+0x5e>
    26a2:	66 23       	and	r22, r22
    26a4:	71 f0       	breq	.+28     	; 0x26c2 <__floatsisf+0x74>
    26a6:	96 e8       	ldi	r25, 0x86	; 134
    26a8:	86 2f       	mov	r24, r22
    26aa:	70 e0       	ldi	r23, 0x00	; 0
    26ac:	60 e0       	ldi	r22, 0x00	; 0
    26ae:	2a f0       	brmi	.+10     	; 0x26ba <__floatsisf+0x6c>
    26b0:	9a 95       	dec	r25
    26b2:	66 0f       	add	r22, r22
    26b4:	77 1f       	adc	r23, r23
    26b6:	88 1f       	adc	r24, r24
    26b8:	da f7       	brpl	.-10     	; 0x26b0 <__floatsisf+0x62>
    26ba:	88 0f       	add	r24, r24
    26bc:	96 95       	lsr	r25
    26be:	87 95       	ror	r24
    26c0:	97 f9       	bld	r25, 7
    26c2:	08 95       	ret

000026c4 <__fp_inf>:
    26c4:	97 f9       	bld	r25, 7
    26c6:	9f 67       	ori	r25, 0x7F	; 127
    26c8:	80 e8       	ldi	r24, 0x80	; 128
    26ca:	70 e0       	ldi	r23, 0x00	; 0
    26cc:	60 e0       	ldi	r22, 0x00	; 0
    26ce:	08 95       	ret

000026d0 <__fp_nan>:
    26d0:	9f ef       	ldi	r25, 0xFF	; 255
    26d2:	80 ec       	ldi	r24, 0xC0	; 192
    26d4:	08 95       	ret

000026d6 <__fp_pscA>:
    26d6:	00 24       	eor	r0, r0
    26d8:	0a 94       	dec	r0
    26da:	16 16       	cp	r1, r22
    26dc:	17 06       	cpc	r1, r23
    26de:	18 06       	cpc	r1, r24
    26e0:	09 06       	cpc	r0, r25
    26e2:	08 95       	ret

000026e4 <__fp_pscB>:
    26e4:	00 24       	eor	r0, r0
    26e6:	0a 94       	dec	r0
    26e8:	12 16       	cp	r1, r18
    26ea:	13 06       	cpc	r1, r19
    26ec:	14 06       	cpc	r1, r20
    26ee:	05 06       	cpc	r0, r21
    26f0:	08 95       	ret

000026f2 <__fp_round>:
    26f2:	09 2e       	mov	r0, r25
    26f4:	03 94       	inc	r0
    26f6:	00 0c       	add	r0, r0
    26f8:	11 f4       	brne	.+4      	; 0x26fe <__fp_round+0xc>
    26fa:	88 23       	and	r24, r24
    26fc:	52 f0       	brmi	.+20     	; 0x2712 <__fp_round+0x20>
    26fe:	bb 0f       	add	r27, r27
    2700:	40 f4       	brcc	.+16     	; 0x2712 <__fp_round+0x20>
    2702:	bf 2b       	or	r27, r31
    2704:	11 f4       	brne	.+4      	; 0x270a <__fp_round+0x18>
    2706:	60 ff       	sbrs	r22, 0
    2708:	04 c0       	rjmp	.+8      	; 0x2712 <__fp_round+0x20>
    270a:	6f 5f       	subi	r22, 0xFF	; 255
    270c:	7f 4f       	sbci	r23, 0xFF	; 255
    270e:	8f 4f       	sbci	r24, 0xFF	; 255
    2710:	9f 4f       	sbci	r25, 0xFF	; 255
    2712:	08 95       	ret

00002714 <__fp_split3>:
    2714:	57 fd       	sbrc	r21, 7
    2716:	90 58       	subi	r25, 0x80	; 128
    2718:	44 0f       	add	r20, r20
    271a:	55 1f       	adc	r21, r21
    271c:	59 f0       	breq	.+22     	; 0x2734 <__fp_splitA+0x10>
    271e:	5f 3f       	cpi	r21, 0xFF	; 255
    2720:	71 f0       	breq	.+28     	; 0x273e <__fp_splitA+0x1a>
    2722:	47 95       	ror	r20

00002724 <__fp_splitA>:
    2724:	88 0f       	add	r24, r24
    2726:	97 fb       	bst	r25, 7
    2728:	99 1f       	adc	r25, r25
    272a:	61 f0       	breq	.+24     	; 0x2744 <__fp_splitA+0x20>
    272c:	9f 3f       	cpi	r25, 0xFF	; 255
    272e:	79 f0       	breq	.+30     	; 0x274e <__fp_splitA+0x2a>
    2730:	87 95       	ror	r24
    2732:	08 95       	ret
    2734:	12 16       	cp	r1, r18
    2736:	13 06       	cpc	r1, r19
    2738:	14 06       	cpc	r1, r20
    273a:	55 1f       	adc	r21, r21
    273c:	f2 cf       	rjmp	.-28     	; 0x2722 <__fp_split3+0xe>
    273e:	46 95       	lsr	r20
    2740:	f1 df       	rcall	.-30     	; 0x2724 <__fp_splitA>
    2742:	08 c0       	rjmp	.+16     	; 0x2754 <__fp_splitA+0x30>
    2744:	16 16       	cp	r1, r22
    2746:	17 06       	cpc	r1, r23
    2748:	18 06       	cpc	r1, r24
    274a:	99 1f       	adc	r25, r25
    274c:	f1 cf       	rjmp	.-30     	; 0x2730 <__fp_splitA+0xc>
    274e:	86 95       	lsr	r24
    2750:	71 05       	cpc	r23, r1
    2752:	61 05       	cpc	r22, r1
    2754:	08 94       	sec
    2756:	08 95       	ret

00002758 <__fp_zero>:
    2758:	e8 94       	clt

0000275a <__fp_szero>:
    275a:	bb 27       	eor	r27, r27
    275c:	66 27       	eor	r22, r22
    275e:	77 27       	eor	r23, r23
    2760:	cb 01       	movw	r24, r22
    2762:	97 f9       	bld	r25, 7
    2764:	08 95       	ret

00002766 <__mulsf3>:
    2766:	0b d0       	rcall	.+22     	; 0x277e <__mulsf3x>
    2768:	c4 cf       	rjmp	.-120    	; 0x26f2 <__fp_round>
    276a:	b5 df       	rcall	.-150    	; 0x26d6 <__fp_pscA>
    276c:	28 f0       	brcs	.+10     	; 0x2778 <__mulsf3+0x12>
    276e:	ba df       	rcall	.-140    	; 0x26e4 <__fp_pscB>
    2770:	18 f0       	brcs	.+6      	; 0x2778 <__mulsf3+0x12>
    2772:	95 23       	and	r25, r21
    2774:	09 f0       	breq	.+2      	; 0x2778 <__mulsf3+0x12>
    2776:	a6 cf       	rjmp	.-180    	; 0x26c4 <__fp_inf>
    2778:	ab cf       	rjmp	.-170    	; 0x26d0 <__fp_nan>
    277a:	11 24       	eor	r1, r1
    277c:	ee cf       	rjmp	.-36     	; 0x275a <__fp_szero>

0000277e <__mulsf3x>:
    277e:	ca df       	rcall	.-108    	; 0x2714 <__fp_split3>
    2780:	a0 f3       	brcs	.-24     	; 0x276a <__mulsf3+0x4>

00002782 <__mulsf3_pse>:
    2782:	95 9f       	mul	r25, r21
    2784:	d1 f3       	breq	.-12     	; 0x277a <__mulsf3+0x14>
    2786:	95 0f       	add	r25, r21
    2788:	50 e0       	ldi	r21, 0x00	; 0
    278a:	55 1f       	adc	r21, r21
    278c:	62 9f       	mul	r22, r18
    278e:	f0 01       	movw	r30, r0
    2790:	72 9f       	mul	r23, r18
    2792:	bb 27       	eor	r27, r27
    2794:	f0 0d       	add	r31, r0
    2796:	b1 1d       	adc	r27, r1
    2798:	63 9f       	mul	r22, r19
    279a:	aa 27       	eor	r26, r26
    279c:	f0 0d       	add	r31, r0
    279e:	b1 1d       	adc	r27, r1
    27a0:	aa 1f       	adc	r26, r26
    27a2:	64 9f       	mul	r22, r20
    27a4:	66 27       	eor	r22, r22
    27a6:	b0 0d       	add	r27, r0
    27a8:	a1 1d       	adc	r26, r1
    27aa:	66 1f       	adc	r22, r22
    27ac:	82 9f       	mul	r24, r18
    27ae:	22 27       	eor	r18, r18
    27b0:	b0 0d       	add	r27, r0
    27b2:	a1 1d       	adc	r26, r1
    27b4:	62 1f       	adc	r22, r18
    27b6:	73 9f       	mul	r23, r19
    27b8:	b0 0d       	add	r27, r0
    27ba:	a1 1d       	adc	r26, r1
    27bc:	62 1f       	adc	r22, r18
    27be:	83 9f       	mul	r24, r19
    27c0:	a0 0d       	add	r26, r0
    27c2:	61 1d       	adc	r22, r1
    27c4:	22 1f       	adc	r18, r18
    27c6:	74 9f       	mul	r23, r20
    27c8:	33 27       	eor	r19, r19
    27ca:	a0 0d       	add	r26, r0
    27cc:	61 1d       	adc	r22, r1
    27ce:	23 1f       	adc	r18, r19
    27d0:	84 9f       	mul	r24, r20
    27d2:	60 0d       	add	r22, r0
    27d4:	21 1d       	adc	r18, r1
    27d6:	82 2f       	mov	r24, r18
    27d8:	76 2f       	mov	r23, r22
    27da:	6a 2f       	mov	r22, r26
    27dc:	11 24       	eor	r1, r1
    27de:	9f 57       	subi	r25, 0x7F	; 127
    27e0:	50 40       	sbci	r21, 0x00	; 0
    27e2:	8a f0       	brmi	.+34     	; 0x2806 <__mulsf3_pse+0x84>
    27e4:	e1 f0       	breq	.+56     	; 0x281e <__mulsf3_pse+0x9c>
    27e6:	88 23       	and	r24, r24
    27e8:	4a f0       	brmi	.+18     	; 0x27fc <__mulsf3_pse+0x7a>
    27ea:	ee 0f       	add	r30, r30
    27ec:	ff 1f       	adc	r31, r31
    27ee:	bb 1f       	adc	r27, r27
    27f0:	66 1f       	adc	r22, r22
    27f2:	77 1f       	adc	r23, r23
    27f4:	88 1f       	adc	r24, r24
    27f6:	91 50       	subi	r25, 0x01	; 1
    27f8:	50 40       	sbci	r21, 0x00	; 0
    27fa:	a9 f7       	brne	.-22     	; 0x27e6 <__mulsf3_pse+0x64>
    27fc:	9e 3f       	cpi	r25, 0xFE	; 254
    27fe:	51 05       	cpc	r21, r1
    2800:	70 f0       	brcs	.+28     	; 0x281e <__mulsf3_pse+0x9c>
    2802:	60 cf       	rjmp	.-320    	; 0x26c4 <__fp_inf>
    2804:	aa cf       	rjmp	.-172    	; 0x275a <__fp_szero>
    2806:	5f 3f       	cpi	r21, 0xFF	; 255
    2808:	ec f3       	brlt	.-6      	; 0x2804 <__mulsf3_pse+0x82>
    280a:	98 3e       	cpi	r25, 0xE8	; 232
    280c:	dc f3       	brlt	.-10     	; 0x2804 <__mulsf3_pse+0x82>
    280e:	86 95       	lsr	r24
    2810:	77 95       	ror	r23
    2812:	67 95       	ror	r22
    2814:	b7 95       	ror	r27
    2816:	f7 95       	ror	r31
    2818:	e7 95       	ror	r30
    281a:	9f 5f       	subi	r25, 0xFF	; 255
    281c:	c1 f7       	brne	.-16     	; 0x280e <__mulsf3_pse+0x8c>
    281e:	fe 2b       	or	r31, r30
    2820:	88 0f       	add	r24, r24
    2822:	91 1d       	adc	r25, r1
    2824:	96 95       	lsr	r25
    2826:	87 95       	ror	r24
    2828:	97 f9       	bld	r25, 7
    282a:	08 95       	ret

0000282c <__udivmodhi4>:
    282c:	aa 1b       	sub	r26, r26
    282e:	bb 1b       	sub	r27, r27
    2830:	51 e1       	ldi	r21, 0x11	; 17
    2832:	07 c0       	rjmp	.+14     	; 0x2842 <__udivmodhi4_ep>

00002834 <__udivmodhi4_loop>:
    2834:	aa 1f       	adc	r26, r26
    2836:	bb 1f       	adc	r27, r27
    2838:	a6 17       	cp	r26, r22
    283a:	b7 07       	cpc	r27, r23
    283c:	10 f0       	brcs	.+4      	; 0x2842 <__udivmodhi4_ep>
    283e:	a6 1b       	sub	r26, r22
    2840:	b7 0b       	sbc	r27, r23

00002842 <__udivmodhi4_ep>:
    2842:	88 1f       	adc	r24, r24
    2844:	99 1f       	adc	r25, r25
    2846:	5a 95       	dec	r21
    2848:	a9 f7       	brne	.-22     	; 0x2834 <__udivmodhi4_loop>
    284a:	80 95       	com	r24
    284c:	90 95       	com	r25
    284e:	bc 01       	movw	r22, r24
    2850:	cd 01       	movw	r24, r26
    2852:	08 95       	ret

00002854 <__udivmodsi4>:
    2854:	a1 e2       	ldi	r26, 0x21	; 33
    2856:	1a 2e       	mov	r1, r26
    2858:	aa 1b       	sub	r26, r26
    285a:	bb 1b       	sub	r27, r27
    285c:	fd 01       	movw	r30, r26
    285e:	0d c0       	rjmp	.+26     	; 0x287a <__udivmodsi4_ep>

00002860 <__udivmodsi4_loop>:
    2860:	aa 1f       	adc	r26, r26
    2862:	bb 1f       	adc	r27, r27
    2864:	ee 1f       	adc	r30, r30
    2866:	ff 1f       	adc	r31, r31
    2868:	a2 17       	cp	r26, r18
    286a:	b3 07       	cpc	r27, r19
    286c:	e4 07       	cpc	r30, r20
    286e:	f5 07       	cpc	r31, r21
    2870:	20 f0       	brcs	.+8      	; 0x287a <__udivmodsi4_ep>
    2872:	a2 1b       	sub	r26, r18
    2874:	b3 0b       	sbc	r27, r19
    2876:	e4 0b       	sbc	r30, r20
    2878:	f5 0b       	sbc	r31, r21

0000287a <__udivmodsi4_ep>:
    287a:	66 1f       	adc	r22, r22
    287c:	77 1f       	adc	r23, r23
    287e:	88 1f       	adc	r24, r24
    2880:	99 1f       	adc	r25, r25
    2882:	1a 94       	dec	r1
    2884:	69 f7       	brne	.-38     	; 0x2860 <__udivmodsi4_loop>
    2886:	60 95       	com	r22
    2888:	70 95       	com	r23
    288a:	80 95       	com	r24
    288c:	90 95       	com	r25
    288e:	9b 01       	movw	r18, r22
    2890:	ac 01       	movw	r20, r24
    2892:	bd 01       	movw	r22, r26
    2894:	cf 01       	movw	r24, r30
    2896:	08 95       	ret

00002898 <malloc>:
    2898:	cf 93       	push	r28
    289a:	df 93       	push	r29
    289c:	ac 01       	movw	r20, r24
    289e:	82 30       	cpi	r24, 0x02	; 2
    28a0:	91 05       	cpc	r25, r1
    28a2:	10 f4       	brcc	.+4      	; 0x28a8 <malloc+0x10>
    28a4:	42 e0       	ldi	r20, 0x02	; 2
    28a6:	50 e0       	ldi	r21, 0x00	; 0
    28a8:	e0 91 07 14 	lds	r30, 0x1407
    28ac:	f0 91 08 14 	lds	r31, 0x1408
    28b0:	20 e0       	ldi	r18, 0x00	; 0
    28b2:	30 e0       	ldi	r19, 0x00	; 0
    28b4:	a0 e0       	ldi	r26, 0x00	; 0
    28b6:	b0 e0       	ldi	r27, 0x00	; 0
    28b8:	24 c0       	rjmp	.+72     	; 0x2902 <malloc+0x6a>
    28ba:	80 81       	ld	r24, Z
    28bc:	91 81       	ldd	r25, Z+1	; 0x01
    28be:	84 17       	cp	r24, r20
    28c0:	95 07       	cpc	r25, r21
    28c2:	d0 f0       	brcs	.+52     	; 0x28f8 <malloc+0x60>
    28c4:	84 17       	cp	r24, r20
    28c6:	95 07       	cpc	r25, r21
    28c8:	71 f4       	brne	.+28     	; 0x28e6 <malloc+0x4e>
    28ca:	82 81       	ldd	r24, Z+2	; 0x02
    28cc:	93 81       	ldd	r25, Z+3	; 0x03
    28ce:	10 97       	sbiw	r26, 0x00	; 0
    28d0:	29 f0       	breq	.+10     	; 0x28dc <malloc+0x44>
    28d2:	13 96       	adiw	r26, 0x03	; 3
    28d4:	9c 93       	st	X, r25
    28d6:	8e 93       	st	-X, r24
    28d8:	12 97       	sbiw	r26, 0x02	; 2
    28da:	2c c0       	rjmp	.+88     	; 0x2934 <malloc+0x9c>
    28dc:	90 93 08 14 	sts	0x1408, r25
    28e0:	80 93 07 14 	sts	0x1407, r24
    28e4:	27 c0       	rjmp	.+78     	; 0x2934 <malloc+0x9c>
    28e6:	21 15       	cp	r18, r1
    28e8:	31 05       	cpc	r19, r1
    28ea:	19 f0       	breq	.+6      	; 0x28f2 <malloc+0x5a>
    28ec:	82 17       	cp	r24, r18
    28ee:	93 07       	cpc	r25, r19
    28f0:	18 f4       	brcc	.+6      	; 0x28f8 <malloc+0x60>
    28f2:	9c 01       	movw	r18, r24
    28f4:	bd 01       	movw	r22, r26
    28f6:	ef 01       	movw	r28, r30
    28f8:	92 81       	ldd	r25, Z+2	; 0x02
    28fa:	83 81       	ldd	r24, Z+3	; 0x03
    28fc:	df 01       	movw	r26, r30
    28fe:	e9 2f       	mov	r30, r25
    2900:	f8 2f       	mov	r31, r24
    2902:	30 97       	sbiw	r30, 0x00	; 0
    2904:	d1 f6       	brne	.-76     	; 0x28ba <malloc+0x22>
    2906:	21 15       	cp	r18, r1
    2908:	31 05       	cpc	r19, r1
    290a:	f9 f0       	breq	.+62     	; 0x294a <malloc+0xb2>
    290c:	c9 01       	movw	r24, r18
    290e:	84 1b       	sub	r24, r20
    2910:	95 0b       	sbc	r25, r21
    2912:	84 30       	cpi	r24, 0x04	; 4
    2914:	91 05       	cpc	r25, r1
    2916:	80 f4       	brcc	.+32     	; 0x2938 <malloc+0xa0>
    2918:	8a 81       	ldd	r24, Y+2	; 0x02
    291a:	9b 81       	ldd	r25, Y+3	; 0x03
    291c:	61 15       	cp	r22, r1
    291e:	71 05       	cpc	r23, r1
    2920:	21 f0       	breq	.+8      	; 0x292a <malloc+0x92>
    2922:	fb 01       	movw	r30, r22
    2924:	93 83       	std	Z+3, r25	; 0x03
    2926:	82 83       	std	Z+2, r24	; 0x02
    2928:	04 c0       	rjmp	.+8      	; 0x2932 <malloc+0x9a>
    292a:	90 93 08 14 	sts	0x1408, r25
    292e:	80 93 07 14 	sts	0x1407, r24
    2932:	fe 01       	movw	r30, r28
    2934:	32 96       	adiw	r30, 0x02	; 2
    2936:	42 c0       	rjmp	.+132    	; 0x29bc <malloc+0x124>
    2938:	fe 01       	movw	r30, r28
    293a:	e8 0f       	add	r30, r24
    293c:	f9 1f       	adc	r31, r25
    293e:	41 93       	st	Z+, r20
    2940:	51 93       	st	Z+, r21
    2942:	02 97       	sbiw	r24, 0x02	; 2
    2944:	99 83       	std	Y+1, r25	; 0x01
    2946:	88 83       	st	Y, r24
    2948:	39 c0       	rjmp	.+114    	; 0x29bc <malloc+0x124>
    294a:	80 91 05 14 	lds	r24, 0x1405
    294e:	90 91 06 14 	lds	r25, 0x1406
    2952:	00 97       	sbiw	r24, 0x00	; 0
    2954:	41 f4       	brne	.+16     	; 0x2966 <malloc+0xce>
    2956:	80 91 70 13 	lds	r24, 0x1370
    295a:	90 91 71 13 	lds	r25, 0x1371
    295e:	90 93 06 14 	sts	0x1406, r25
    2962:	80 93 05 14 	sts	0x1405, r24
    2966:	20 91 6e 13 	lds	r18, 0x136E
    296a:	30 91 6f 13 	lds	r19, 0x136F
    296e:	21 15       	cp	r18, r1
    2970:	31 05       	cpc	r19, r1
    2972:	41 f4       	brne	.+16     	; 0x2984 <malloc+0xec>
    2974:	2d b7       	in	r18, 0x3d	; 61
    2976:	3e b7       	in	r19, 0x3e	; 62
    2978:	80 91 72 13 	lds	r24, 0x1372
    297c:	90 91 73 13 	lds	r25, 0x1373
    2980:	28 1b       	sub	r18, r24
    2982:	39 0b       	sbc	r19, r25
    2984:	e0 91 05 14 	lds	r30, 0x1405
    2988:	f0 91 06 14 	lds	r31, 0x1406
    298c:	e2 17       	cp	r30, r18
    298e:	f3 07       	cpc	r31, r19
    2990:	98 f4       	brcc	.+38     	; 0x29b8 <malloc+0x120>
    2992:	2e 1b       	sub	r18, r30
    2994:	3f 0b       	sbc	r19, r31
    2996:	24 17       	cp	r18, r20
    2998:	35 07       	cpc	r19, r21
    299a:	70 f0       	brcs	.+28     	; 0x29b8 <malloc+0x120>
    299c:	ca 01       	movw	r24, r20
    299e:	02 96       	adiw	r24, 0x02	; 2
    29a0:	28 17       	cp	r18, r24
    29a2:	39 07       	cpc	r19, r25
    29a4:	48 f0       	brcs	.+18     	; 0x29b8 <malloc+0x120>
    29a6:	8e 0f       	add	r24, r30
    29a8:	9f 1f       	adc	r25, r31
    29aa:	90 93 06 14 	sts	0x1406, r25
    29ae:	80 93 05 14 	sts	0x1405, r24
    29b2:	41 93       	st	Z+, r20
    29b4:	51 93       	st	Z+, r21
    29b6:	02 c0       	rjmp	.+4      	; 0x29bc <malloc+0x124>
    29b8:	e0 e0       	ldi	r30, 0x00	; 0
    29ba:	f0 e0       	ldi	r31, 0x00	; 0
    29bc:	cf 01       	movw	r24, r30
    29be:	df 91       	pop	r29
    29c0:	cf 91       	pop	r28
    29c2:	08 95       	ret

000029c4 <free>:
    29c4:	0f 93       	push	r16
    29c6:	1f 93       	push	r17
    29c8:	cf 93       	push	r28
    29ca:	df 93       	push	r29
    29cc:	9c 01       	movw	r18, r24
    29ce:	00 97       	sbiw	r24, 0x00	; 0
    29d0:	09 f4       	brne	.+2      	; 0x29d4 <free+0x10>
    29d2:	8c c0       	rjmp	.+280    	; 0x2aec <free+0x128>
    29d4:	dc 01       	movw	r26, r24
    29d6:	12 97       	sbiw	r26, 0x02	; 2
    29d8:	13 96       	adiw	r26, 0x03	; 3
    29da:	1c 92       	st	X, r1
    29dc:	1e 92       	st	-X, r1
    29de:	12 97       	sbiw	r26, 0x02	; 2
    29e0:	60 91 07 14 	lds	r22, 0x1407
    29e4:	70 91 08 14 	lds	r23, 0x1408
    29e8:	61 15       	cp	r22, r1
    29ea:	71 05       	cpc	r23, r1
    29ec:	89 f4       	brne	.+34     	; 0x2a10 <free+0x4c>
    29ee:	8d 91       	ld	r24, X+
    29f0:	9c 91       	ld	r25, X
    29f2:	11 97       	sbiw	r26, 0x01	; 1
    29f4:	82 0f       	add	r24, r18
    29f6:	93 1f       	adc	r25, r19
    29f8:	20 91 05 14 	lds	r18, 0x1405
    29fc:	30 91 06 14 	lds	r19, 0x1406
    2a00:	28 17       	cp	r18, r24
    2a02:	39 07       	cpc	r19, r25
    2a04:	69 f5       	brne	.+90     	; 0x2a60 <free+0x9c>
    2a06:	b0 93 06 14 	sts	0x1406, r27
    2a0a:	a0 93 05 14 	sts	0x1405, r26
    2a0e:	6e c0       	rjmp	.+220    	; 0x2aec <free+0x128>
    2a10:	fb 01       	movw	r30, r22
    2a12:	40 e0       	ldi	r20, 0x00	; 0
    2a14:	50 e0       	ldi	r21, 0x00	; 0
    2a16:	01 c0       	rjmp	.+2      	; 0x2a1a <free+0x56>
    2a18:	fc 01       	movw	r30, r24
    2a1a:	ea 17       	cp	r30, r26
    2a1c:	fb 07       	cpc	r31, r27
    2a1e:	30 f4       	brcc	.+12     	; 0x2a2c <free+0x68>
    2a20:	82 81       	ldd	r24, Z+2	; 0x02
    2a22:	93 81       	ldd	r25, Z+3	; 0x03
    2a24:	af 01       	movw	r20, r30
    2a26:	00 97       	sbiw	r24, 0x00	; 0
    2a28:	b9 f7       	brne	.-18     	; 0x2a18 <free+0x54>
    2a2a:	1f c0       	rjmp	.+62     	; 0x2a6a <free+0xa6>
    2a2c:	e9 01       	movw	r28, r18
    2a2e:	22 97       	sbiw	r28, 0x02	; 2
    2a30:	fb 83       	std	Y+3, r31	; 0x03
    2a32:	ea 83       	std	Y+2, r30	; 0x02
    2a34:	08 81       	ld	r16, Y
    2a36:	19 81       	ldd	r17, Y+1	; 0x01
    2a38:	c9 01       	movw	r24, r18
    2a3a:	80 0f       	add	r24, r16
    2a3c:	91 1f       	adc	r25, r17
    2a3e:	8e 17       	cp	r24, r30
    2a40:	9f 07       	cpc	r25, r31
    2a42:	59 f4       	brne	.+22     	; 0x2a5a <free+0x96>
    2a44:	80 81       	ld	r24, Z
    2a46:	91 81       	ldd	r25, Z+1	; 0x01
    2a48:	80 0f       	add	r24, r16
    2a4a:	91 1f       	adc	r25, r17
    2a4c:	02 96       	adiw	r24, 0x02	; 2
    2a4e:	99 83       	std	Y+1, r25	; 0x01
    2a50:	88 83       	st	Y, r24
    2a52:	82 81       	ldd	r24, Z+2	; 0x02
    2a54:	93 81       	ldd	r25, Z+3	; 0x03
    2a56:	9b 83       	std	Y+3, r25	; 0x03
    2a58:	8a 83       	std	Y+2, r24	; 0x02
    2a5a:	41 15       	cp	r20, r1
    2a5c:	51 05       	cpc	r21, r1
    2a5e:	29 f4       	brne	.+10     	; 0x2a6a <free+0xa6>
    2a60:	b0 93 08 14 	sts	0x1408, r27
    2a64:	a0 93 07 14 	sts	0x1407, r26
    2a68:	41 c0       	rjmp	.+130    	; 0x2aec <free+0x128>
    2a6a:	fa 01       	movw	r30, r20
    2a6c:	b3 83       	std	Z+3, r27	; 0x03
    2a6e:	a2 83       	std	Z+2, r26	; 0x02
    2a70:	c1 91       	ld	r28, Z+
    2a72:	d1 91       	ld	r29, Z+
    2a74:	ec 0f       	add	r30, r28
    2a76:	fd 1f       	adc	r31, r29
    2a78:	ae 17       	cp	r26, r30
    2a7a:	bf 07       	cpc	r27, r31
    2a7c:	81 f4       	brne	.+32     	; 0x2a9e <free+0xda>
    2a7e:	f9 01       	movw	r30, r18
    2a80:	92 91       	ld	r25, -Z
    2a82:	82 91       	ld	r24, -Z
    2a84:	8c 0f       	add	r24, r28
    2a86:	9d 1f       	adc	r25, r29
    2a88:	02 96       	adiw	r24, 0x02	; 2
    2a8a:	da 01       	movw	r26, r20
    2a8c:	11 96       	adiw	r26, 0x01	; 1
    2a8e:	9c 93       	st	X, r25
    2a90:	8e 93       	st	-X, r24
    2a92:	82 81       	ldd	r24, Z+2	; 0x02
    2a94:	93 81       	ldd	r25, Z+3	; 0x03
    2a96:	13 96       	adiw	r26, 0x03	; 3
    2a98:	9c 93       	st	X, r25
    2a9a:	8e 93       	st	-X, r24
    2a9c:	12 97       	sbiw	r26, 0x02	; 2
    2a9e:	e0 e0       	ldi	r30, 0x00	; 0
    2aa0:	f0 e0       	ldi	r31, 0x00	; 0
    2aa2:	02 c0       	rjmp	.+4      	; 0x2aa8 <free+0xe4>
    2aa4:	fb 01       	movw	r30, r22
    2aa6:	bc 01       	movw	r22, r24
    2aa8:	db 01       	movw	r26, r22
    2aaa:	12 96       	adiw	r26, 0x02	; 2
    2aac:	8d 91       	ld	r24, X+
    2aae:	9c 91       	ld	r25, X
    2ab0:	13 97       	sbiw	r26, 0x03	; 3
    2ab2:	00 97       	sbiw	r24, 0x00	; 0
    2ab4:	b9 f7       	brne	.-18     	; 0x2aa4 <free+0xe0>
    2ab6:	cb 01       	movw	r24, r22
    2ab8:	02 96       	adiw	r24, 0x02	; 2
    2aba:	2d 91       	ld	r18, X+
    2abc:	3c 91       	ld	r19, X
    2abe:	11 97       	sbiw	r26, 0x01	; 1
    2ac0:	82 0f       	add	r24, r18
    2ac2:	93 1f       	adc	r25, r19
    2ac4:	20 91 05 14 	lds	r18, 0x1405
    2ac8:	30 91 06 14 	lds	r19, 0x1406
    2acc:	28 17       	cp	r18, r24
    2ace:	39 07       	cpc	r19, r25
    2ad0:	69 f4       	brne	.+26     	; 0x2aec <free+0x128>
    2ad2:	30 97       	sbiw	r30, 0x00	; 0
    2ad4:	29 f4       	brne	.+10     	; 0x2ae0 <free+0x11c>
    2ad6:	10 92 08 14 	sts	0x1408, r1
    2ada:	10 92 07 14 	sts	0x1407, r1
    2ade:	02 c0       	rjmp	.+4      	; 0x2ae4 <free+0x120>
    2ae0:	13 82       	std	Z+3, r1	; 0x03
    2ae2:	12 82       	std	Z+2, r1	; 0x02
    2ae4:	70 93 06 14 	sts	0x1406, r23
    2ae8:	60 93 05 14 	sts	0x1405, r22
    2aec:	df 91       	pop	r29
    2aee:	cf 91       	pop	r28
    2af0:	1f 91       	pop	r17
    2af2:	0f 91       	pop	r16
    2af4:	08 95       	ret

00002af6 <atoi>:
    2af6:	fc 01       	movw	r30, r24
    2af8:	88 27       	eor	r24, r24
    2afa:	99 27       	eor	r25, r25
    2afc:	e8 94       	clt
    2afe:	21 91       	ld	r18, Z+
    2b00:	20 32       	cpi	r18, 0x20	; 32
    2b02:	e9 f3       	breq	.-6      	; 0x2afe <atoi+0x8>
    2b04:	29 30       	cpi	r18, 0x09	; 9
    2b06:	10 f0       	brcs	.+4      	; 0x2b0c <atoi+0x16>
    2b08:	2e 30       	cpi	r18, 0x0E	; 14
    2b0a:	c8 f3       	brcs	.-14     	; 0x2afe <atoi+0x8>
    2b0c:	2b 32       	cpi	r18, 0x2B	; 43
    2b0e:	41 f0       	breq	.+16     	; 0x2b20 <atoi+0x2a>
    2b10:	2d 32       	cpi	r18, 0x2D	; 45
    2b12:	39 f4       	brne	.+14     	; 0x2b22 <atoi+0x2c>
    2b14:	68 94       	set
    2b16:	04 c0       	rjmp	.+8      	; 0x2b20 <atoi+0x2a>
    2b18:	0e 94 d0 15 	call	0x2ba0	; 0x2ba0 <__mulhi_const_10>
    2b1c:	82 0f       	add	r24, r18
    2b1e:	91 1d       	adc	r25, r1
    2b20:	21 91       	ld	r18, Z+
    2b22:	20 53       	subi	r18, 0x30	; 48
    2b24:	2a 30       	cpi	r18, 0x0A	; 10
    2b26:	c0 f3       	brcs	.-16     	; 0x2b18 <atoi+0x22>
    2b28:	1e f4       	brtc	.+6      	; 0x2b30 <atoi+0x3a>
    2b2a:	90 95       	com	r25
    2b2c:	81 95       	neg	r24
    2b2e:	9f 4f       	sbci	r25, 0xFF	; 255
    2b30:	08 95       	ret

00002b32 <strtok>:
    2b32:	45 ee       	ldi	r20, 0xE5	; 229
    2b34:	53 e1       	ldi	r21, 0x13	; 19
    2b36:	0e 94 a9 15 	call	0x2b52	; 0x2b52 <strtok_r>
    2b3a:	08 95       	ret

00002b3c <strcat>:
    2b3c:	fb 01       	movw	r30, r22
    2b3e:	dc 01       	movw	r26, r24
    2b40:	0d 90       	ld	r0, X+
    2b42:	00 20       	and	r0, r0
    2b44:	e9 f7       	brne	.-6      	; 0x2b40 <strcat+0x4>
    2b46:	11 97       	sbiw	r26, 0x01	; 1
    2b48:	01 90       	ld	r0, Z+
    2b4a:	0d 92       	st	X+, r0
    2b4c:	00 20       	and	r0, r0
    2b4e:	e1 f7       	brne	.-8      	; 0x2b48 <strcat+0xc>
    2b50:	08 95       	ret

00002b52 <strtok_r>:
    2b52:	fa 01       	movw	r30, r20
    2b54:	a1 91       	ld	r26, Z+
    2b56:	b0 81       	ld	r27, Z
    2b58:	00 97       	sbiw	r24, 0x00	; 0
    2b5a:	19 f4       	brne	.+6      	; 0x2b62 <strtok_r+0x10>
    2b5c:	10 97       	sbiw	r26, 0x00	; 0
    2b5e:	e1 f0       	breq	.+56     	; 0x2b98 <strtok_r+0x46>
    2b60:	cd 01       	movw	r24, r26
    2b62:	dc 01       	movw	r26, r24
    2b64:	cd 01       	movw	r24, r26
    2b66:	0d 90       	ld	r0, X+
    2b68:	00 20       	and	r0, r0
    2b6a:	11 f4       	brne	.+4      	; 0x2b70 <strtok_r+0x1e>
    2b6c:	c0 01       	movw	r24, r0
    2b6e:	13 c0       	rjmp	.+38     	; 0x2b96 <strtok_r+0x44>
    2b70:	fb 01       	movw	r30, r22
    2b72:	21 91       	ld	r18, Z+
    2b74:	22 23       	and	r18, r18
    2b76:	19 f0       	breq	.+6      	; 0x2b7e <strtok_r+0x2c>
    2b78:	20 15       	cp	r18, r0
    2b7a:	d9 f7       	brne	.-10     	; 0x2b72 <strtok_r+0x20>
    2b7c:	f3 cf       	rjmp	.-26     	; 0x2b64 <strtok_r+0x12>
    2b7e:	fb 01       	movw	r30, r22
    2b80:	21 91       	ld	r18, Z+
    2b82:	20 15       	cp	r18, r0
    2b84:	19 f4       	brne	.+6      	; 0x2b8c <strtok_r+0x3a>
    2b86:	1e 92       	st	-X, r1
    2b88:	11 96       	adiw	r26, 0x01	; 1
    2b8a:	06 c0       	rjmp	.+12     	; 0x2b98 <strtok_r+0x46>
    2b8c:	22 23       	and	r18, r18
    2b8e:	c1 f7       	brne	.-16     	; 0x2b80 <strtok_r+0x2e>
    2b90:	0d 90       	ld	r0, X+
    2b92:	00 20       	and	r0, r0
    2b94:	a1 f7       	brne	.-24     	; 0x2b7e <strtok_r+0x2c>
    2b96:	d0 01       	movw	r26, r0
    2b98:	fa 01       	movw	r30, r20
    2b9a:	a1 93       	st	Z+, r26
    2b9c:	b0 83       	st	Z, r27
    2b9e:	08 95       	ret

00002ba0 <__mulhi_const_10>:
    2ba0:	7a e0       	ldi	r23, 0x0A	; 10
    2ba2:	97 9f       	mul	r25, r23
    2ba4:	90 2d       	mov	r25, r0
    2ba6:	87 9f       	mul	r24, r23
    2ba8:	80 2d       	mov	r24, r0
    2baa:	91 0d       	add	r25, r1
    2bac:	11 24       	eor	r1, r1
    2bae:	08 95       	ret

00002bb0 <_exit>:
    2bb0:	f8 94       	cli

00002bb2 <__stop_program>:
    2bb2:	ff cf       	rjmp	.-2      	; 0x2bb2 <__stop_program>
